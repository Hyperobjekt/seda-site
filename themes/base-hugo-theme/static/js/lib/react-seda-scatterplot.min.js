!function(root, factory) {
    "object" == typeof exports && "object" == typeof module ? module.exports = factory(require("react")) : "function" == typeof define && define.amd ? define([ "react" ], factory) : "object" == typeof exports ? exports.sedaScatterplot = factory(require("react")) : root.sedaScatterplot = factory(root.React);
}(window, function(__WEBPACK_EXTERNAL_MODULE__49__) {
    return function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) return installedModules[moduleId].exports;
            var module = installedModules[moduleId] = {
                i: moduleId,
                l: !1,
                exports: {}
            };
            return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
            module.l = !0, module.exports;
        }
        return __webpack_require__.m = modules, __webpack_require__.c = installedModules, 
        __webpack_require__.d = function(exports, name, getter) {
            __webpack_require__.o(exports, name) || Object.defineProperty(exports, name, {
                enumerable: !0,
                get: getter
            });
        }, __webpack_require__.r = function(exports) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(exports, "__esModule", {
                value: !0
            });
        }, __webpack_require__.t = function(value, mode) {
            if (1 & mode && (value = __webpack_require__(value)), 8 & mode) return value;
            if (4 & mode && "object" == typeof value && value && value.__esModule) return value;
            var ns = Object.create(null);
            if (__webpack_require__.r(ns), Object.defineProperty(ns, "default", {
                enumerable: !0,
                value: value
            }), 2 & mode && "string" != typeof value) for (var key in value) __webpack_require__.d(ns, key, function(key) {
                return value[key];
            }.bind(null, key));
            return ns;
        }, __webpack_require__.n = function(module) {
            var getter = module && module.__esModule ? function() {
                return module.default;
            } : function() {
                return module;
            };
            return __webpack_require__.d(getter, "a", getter), getter;
        }, __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
        }, __webpack_require__.p = "", __webpack_require__(__webpack_require__.s = 151);
    }([ function(module, exports) {
        var BUILTIN_OBJECT = {
            "[object Function]": 1,
            "[object RegExp]": 1,
            "[object Date]": 1,
            "[object Error]": 1,
            "[object CanvasGradient]": 1,
            "[object CanvasPattern]": 1,
            "[object Image]": 1,
            "[object Canvas]": 1
        }, TYPED_ARRAY = {
            "[object Int8Array]": 1,
            "[object Uint8Array]": 1,
            "[object Uint8ClampedArray]": 1,
            "[object Int16Array]": 1,
            "[object Uint16Array]": 1,
            "[object Int32Array]": 1,
            "[object Uint32Array]": 1,
            "[object Float32Array]": 1,
            "[object Float64Array]": 1
        }, objToString = Object.prototype.toString, arrayProto = Array.prototype, nativeForEach = arrayProto.forEach, nativeFilter = arrayProto.filter, nativeSlice = arrayProto.slice, nativeMap = arrayProto.map, nativeReduce = arrayProto.reduce, methods = {};
        function clone(source) {
            if (null == source || "object" != typeof source) return source;
            var result = source, typeStr = objToString.call(source);
            if ("[object Array]" === typeStr) {
                if (!isPrimitive(source)) {
                    result = [];
                    for (var i = 0, len = source.length; i < len; i++) result[i] = clone(source[i]);
                }
            } else if (TYPED_ARRAY[typeStr]) {
                if (!isPrimitive(source)) {
                    var Ctor = source.constructor;
                    if (source.constructor.from) result = Ctor.from(source); else {
                        result = new Ctor(source.length);
                        for (i = 0, len = source.length; i < len; i++) result[i] = clone(source[i]);
                    }
                }
            } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) for (var key in result = {}, 
            source) source.hasOwnProperty(key) && (result[key] = clone(source[key]));
            return result;
        }
        function merge(target, source, overwrite) {
            if (!isObject(source) || !isObject(target)) return overwrite ? clone(source) : target;
            for (var key in source) if (source.hasOwnProperty(key)) {
                var targetProp = target[key], sourceProp = source[key];
                !isObject(sourceProp) || !isObject(targetProp) || isArray(sourceProp) || isArray(targetProp) || isDom(sourceProp) || isDom(targetProp) || isBuiltInObject(sourceProp) || isBuiltInObject(targetProp) || isPrimitive(sourceProp) || isPrimitive(targetProp) ? !overwrite && key in target || (target[key] = clone(source[key])) : merge(targetProp, sourceProp, overwrite);
            }
            return target;
        }
        function defaults(target, source, overlay) {
            for (var key in source) source.hasOwnProperty(key) && (overlay ? null != source[key] : null == target[key]) && (target[key] = source[key]);
            return target;
        }
        var _ctx, createCanvas = function() {
            return methods.createCanvas();
        };
        function each(obj, cb, context) {
            if (obj && cb) if (obj.forEach && obj.forEach === nativeForEach) obj.forEach(cb, context); else if (obj.length === +obj.length) for (var i = 0, len = obj.length; i < len; i++) cb.call(context, obj[i], i, obj); else for (var key in obj) obj.hasOwnProperty(key) && cb.call(context, obj[key], key, obj);
        }
        function bind(func, context) {
            var args = nativeSlice.call(arguments, 2);
            return function() {
                return func.apply(context, args.concat(nativeSlice.call(arguments)));
            };
        }
        function isArray(value) {
            return "[object Array]" === objToString.call(value);
        }
        function isObject(value) {
            var type = typeof value;
            return "function" === type || !!value && "object" === type;
        }
        function isBuiltInObject(value) {
            return !!BUILTIN_OBJECT[objToString.call(value)];
        }
        function isDom(value) {
            return "object" == typeof value && "number" == typeof value.nodeType && "object" == typeof value.ownerDocument;
        }
        methods.createCanvas = function() {
            return document.createElement("canvas");
        };
        var primitiveKey = "__ec_primitive__";
        function isPrimitive(obj) {
            return obj[primitiveKey];
        }
        function HashMap(obj) {
            var isArr = isArray(obj);
            this.data = {};
            var thisMap = this;
            function visit(value, key) {
                isArr ? thisMap.set(value, key) : thisMap.set(key, value);
            }
            obj instanceof HashMap ? obj.each(visit) : obj && each(obj, visit);
        }
        HashMap.prototype = {
            constructor: HashMap,
            get: function(key) {
                return this.data.hasOwnProperty(key) ? this.data[key] : null;
            },
            set: function(key, value) {
                return this.data[key] = value;
            },
            each: function(cb, context) {
                for (var key in void 0 !== context && (cb = bind(cb, context)), this.data) this.data.hasOwnProperty(key) && cb(this.data[key], key);
            },
            removeKey: function(key) {
                delete this.data[key];
            }
        }, exports.$override = function(name, fn) {
            "createCanvas" === name && (_ctx = null), methods[name] = fn;
        }, exports.clone = clone, exports.merge = merge, exports.mergeAll = function(targetAndSources, overwrite) {
            for (var result = targetAndSources[0], i = 1, len = targetAndSources.length; i < len; i++) result = merge(result, targetAndSources[i], overwrite);
            return result;
        }, exports.extend = function(target, source) {
            for (var key in source) source.hasOwnProperty(key) && (target[key] = source[key]);
            return target;
        }, exports.defaults = defaults, exports.createCanvas = createCanvas, exports.getContext = function() {
            return _ctx || (_ctx = createCanvas().getContext("2d")), _ctx;
        }, exports.indexOf = function(array, value) {
            if (array) {
                if (array.indexOf) return array.indexOf(value);
                for (var i = 0, len = array.length; i < len; i++) if (array[i] === value) return i;
            }
            return -1;
        }, exports.inherits = function(clazz, baseClazz) {
            var clazzPrototype = clazz.prototype;
            function F() {}
            for (var prop in F.prototype = baseClazz.prototype, clazz.prototype = new F(), clazzPrototype) clazz.prototype[prop] = clazzPrototype[prop];
            clazz.prototype.constructor = clazz, clazz.superClass = baseClazz;
        }, exports.mixin = function(target, source, overlay) {
            defaults(target = "prototype" in target ? target.prototype : target, source = "prototype" in source ? source.prototype : source, overlay);
        }, exports.isArrayLike = function(data) {
            if (data) return "string" != typeof data && "number" == typeof data.length;
        }, exports.each = each, exports.map = function(obj, cb, context) {
            if (obj && cb) {
                if (obj.map && obj.map === nativeMap) return obj.map(cb, context);
                for (var result = [], i = 0, len = obj.length; i < len; i++) result.push(cb.call(context, obj[i], i, obj));
                return result;
            }
        }, exports.reduce = function(obj, cb, memo, context) {
            if (obj && cb) {
                if (obj.reduce && obj.reduce === nativeReduce) return obj.reduce(cb, memo, context);
                for (var i = 0, len = obj.length; i < len; i++) memo = cb.call(context, memo, obj[i], i, obj);
                return memo;
            }
        }, exports.filter = function(obj, cb, context) {
            if (obj && cb) {
                if (obj.filter && obj.filter === nativeFilter) return obj.filter(cb, context);
                for (var result = [], i = 0, len = obj.length; i < len; i++) cb.call(context, obj[i], i, obj) && result.push(obj[i]);
                return result;
            }
        }, exports.find = function(obj, cb, context) {
            if (obj && cb) for (var i = 0, len = obj.length; i < len; i++) if (cb.call(context, obj[i], i, obj)) return obj[i];
        }, exports.bind = bind, exports.curry = function(func) {
            var args = nativeSlice.call(arguments, 1);
            return function() {
                return func.apply(this, args.concat(nativeSlice.call(arguments)));
            };
        }, exports.isArray = isArray, exports.isFunction = function(value) {
            return "function" == typeof value;
        }, exports.isString = function(value) {
            return "[object String]" === objToString.call(value);
        }, exports.isObject = isObject, exports.isBuiltInObject = isBuiltInObject, exports.isTypedArray = function(value) {
            return !!TYPED_ARRAY[objToString.call(value)];
        }, exports.isDom = isDom, exports.eqNaN = function(value) {
            return value != value;
        }, exports.retrieve = function(values) {
            for (var i = 0, len = arguments.length; i < len; i++) if (null != arguments[i]) return arguments[i];
        }, exports.retrieve2 = function(value0, value1) {
            return null != value0 ? value0 : value1;
        }, exports.retrieve3 = function(value0, value1, value2) {
            return null != value0 ? value0 : null != value1 ? value1 : value2;
        }, exports.slice = function() {
            return Function.call.apply(nativeSlice, arguments);
        }, exports.normalizeCssArray = function(val) {
            if ("number" == typeof val) return [ val, val, val, val ];
            var len = val.length;
            return 2 === len ? [ val[0], val[1], val[0], val[1] ] : 3 === len ? [ val[0], val[1], val[2], val[1] ] : val;
        }, exports.assert = function(condition, message) {
            if (!condition) throw new Error(message);
        }, exports.trim = function(str) {
            return null == str ? null : "function" == typeof str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
        }, exports.setAsPrimitive = function(obj) {
            obj[primitiveKey] = !0;
        }, exports.isPrimitive = isPrimitive, exports.createHashMap = function(obj) {
            return new HashMap(obj);
        }, exports.concatArray = function(a, b) {
            for (var newArray = new a.constructor(a.length + b.length), i = 0; i < a.length; i++) newArray[i] = a[i];
            var offset = a.length;
            for (i = 0; i < b.length; i++) newArray[i + offset] = b[i];
            return newArray;
        }, exports.noop = function() {};
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(5).__DEV__;
        var zrender = __webpack_require__(86), zrUtil = __webpack_require__(0), colorTool = __webpack_require__(20), env = __webpack_require__(7), timsort = __webpack_require__(53), Eventful = __webpack_require__(23), GlobalModel = __webpack_require__(98), ExtensionAPI = __webpack_require__(114), CoordinateSystemManager = __webpack_require__(41), OptionManager = __webpack_require__(219), backwardCompat = __webpack_require__(220), dataStack = __webpack_require__(222), ComponentModel = __webpack_require__(13), SeriesModel = __webpack_require__(24), ComponentView = __webpack_require__(64), ChartView = __webpack_require__(65), graphic = __webpack_require__(2), modelUtil = __webpack_require__(3), throttle = __webpack_require__(31).throttle, seriesColor = __webpack_require__(223), aria = __webpack_require__(224), loadingDefault = __webpack_require__(226), Scheduler = __webpack_require__(227), lightTheme = __webpack_require__(228), darkTheme = __webpack_require__(229);
        __webpack_require__(230);
        var mapDataStorage = __webpack_require__(231), assert = zrUtil.assert, each = zrUtil.each, isFunction = zrUtil.isFunction, isObject = zrUtil.isObject, parseClassType = ComponentModel.parseClassType, PRIORITY_PROCESSOR_FILTER = 1e3, PRIORITY_VISUAL_LAYOUT = 1e3, PRIORITY_VISUAL_CHART = 3e3, PRIORITY = {
            PROCESSOR: {
                FILTER: PRIORITY_PROCESSOR_FILTER,
                STATISTIC: 5e3
            },
            VISUAL: {
                LAYOUT: PRIORITY_VISUAL_LAYOUT,
                PROGRESSIVE_LAYOUT: 1100,
                GLOBAL: 2e3,
                CHART: PRIORITY_VISUAL_CHART,
                POST_CHART_LAYOUT: 3500,
                COMPONENT: 4e3,
                BRUSH: 5e3
            }
        }, IN_MAIN_PROCESS = "__flagInMainProcess", OPTION_UPDATED = "__optionUpdated", ACTION_REG = /^[a-zA-Z0-9_]+$/;
        function createRegisterEventWithLowercaseName(method) {
            return function(eventName, handler, context) {
                eventName = eventName && eventName.toLowerCase(), Eventful.prototype[method].call(this, eventName, handler, context);
            };
        }
        function MessageCenter() {
            Eventful.call(this);
        }
        function ECharts(dom, theme, opts) {
            opts = opts || {}, "string" == typeof theme && (theme = themeStorage[theme]), this.id, 
            this.group, this._dom = dom;
            var zr = this._zr = zrender.init(dom, {
                renderer: opts.renderer || "canvas",
                devicePixelRatio: opts.devicePixelRatio,
                width: opts.width,
                height: opts.height
            });
            this._throttledZrFlush = throttle(zrUtil.bind(zr.flush, zr), 17), (theme = zrUtil.clone(theme)) && backwardCompat(theme, !0), 
            this._theme = theme, this._chartsViews = [], this._chartsMap = {}, this._componentsViews = [], 
            this._componentsMap = {}, this._coordSysMgr = new CoordinateSystemManager();
            var api = this._api = function(ecInstance) {
                var coordSysMgr = ecInstance._coordSysMgr;
                return zrUtil.extend(new ExtensionAPI(ecInstance), {
                    getCoordinateSystems: zrUtil.bind(coordSysMgr.getCoordinateSystems, coordSysMgr),
                    getComponentByElement: function(el) {
                        for (;el; ) {
                            var modelInfo = el.__ecComponentInfo;
                            if (null != modelInfo) return ecInstance._model.getComponent(modelInfo.mainType, modelInfo.index);
                            el = el.parent;
                        }
                    }
                });
            }(this);
            function prioritySortFunc(a, b) {
                return a.__prio - b.__prio;
            }
            timsort(visualFuncs, prioritySortFunc), timsort(dataProcessorFuncs, prioritySortFunc), 
            this._scheduler = new Scheduler(this, api, dataProcessorFuncs, visualFuncs), Eventful.call(this, this._ecEventProcessor = new EventProcessor()), 
            this._messageCenter = new MessageCenter(), this._initEvents(), this.resize = zrUtil.bind(this.resize, this), 
            this._pendingActions = [], zr.animation.on("frame", this._onframe, this), function(zr, ecIns) {
                zr.on("rendered", function() {
                    ecIns.trigger("rendered"), !zr.animation.isFinished() || ecIns[OPTION_UPDATED] || ecIns._scheduler.unfinished || ecIns._pendingActions.length || ecIns.trigger("finished");
                });
            }(zr, this), zrUtil.setAsPrimitive(this);
        }
        MessageCenter.prototype.on = createRegisterEventWithLowercaseName("on"), MessageCenter.prototype.off = createRegisterEventWithLowercaseName("off"), 
        MessageCenter.prototype.one = createRegisterEventWithLowercaseName("one"), zrUtil.mixin(MessageCenter, Eventful);
        var echartsProto = ECharts.prototype;
        function doConvertPixel(methodName, finder, value) {
            var result, ecModel = this._model, coordSysList = this._coordSysMgr.getCoordinateSystems();
            finder = modelUtil.parseFinder(ecModel, finder);
            for (var i = 0; i < coordSysList.length; i++) {
                var coordSys = coordSysList[i];
                if (coordSys[methodName] && null != (result = coordSys[methodName](ecModel, finder, value))) return result;
            }
        }
        echartsProto._onframe = function() {
            if (!this._disposed) {
                var scheduler = this._scheduler;
                if (this[OPTION_UPDATED]) {
                    var silent = this[OPTION_UPDATED].silent;
                    this[IN_MAIN_PROCESS] = !0, prepare(this), updateMethods.update.call(this), this[IN_MAIN_PROCESS] = !1, 
                    this[OPTION_UPDATED] = !1, flushPendingActions.call(this, silent), triggerUpdatedEvent.call(this, silent);
                } else if (scheduler.unfinished) {
                    var remainTime = 1, ecModel = this._model, api = this._api;
                    scheduler.unfinished = !1;
                    do {
                        var startTime = +new Date();
                        scheduler.performSeriesTasks(ecModel), scheduler.performDataProcessorTasks(ecModel), 
                        updateStreamModes(this, ecModel), scheduler.performVisualTasks(ecModel), renderSeries(this, this._model, api, "remain"), 
                        remainTime -= +new Date() - startTime;
                    } while (remainTime > 0 && scheduler.unfinished);
                    scheduler.unfinished || this._zr.flush();
                }
            }
        }, echartsProto.getDom = function() {
            return this._dom;
        }, echartsProto.getZr = function() {
            return this._zr;
        }, echartsProto.setOption = function(option, notMerge, lazyUpdate) {
            var silent;
            if (isObject(notMerge) && (lazyUpdate = notMerge.lazyUpdate, silent = notMerge.silent, 
            notMerge = notMerge.notMerge), this[IN_MAIN_PROCESS] = !0, !this._model || notMerge) {
                var optionManager = new OptionManager(this._api), theme = this._theme, ecModel = this._model = new GlobalModel();
                ecModel.scheduler = this._scheduler, ecModel.init(null, null, theme, optionManager);
            }
            this._model.setOption(option, optionPreprocessorFuncs), lazyUpdate ? (this[OPTION_UPDATED] = {
                silent: silent
            }, this[IN_MAIN_PROCESS] = !1) : (prepare(this), updateMethods.update.call(this), 
            this._zr.flush(), this[OPTION_UPDATED] = !1, this[IN_MAIN_PROCESS] = !1, flushPendingActions.call(this, silent), 
            triggerUpdatedEvent.call(this, silent));
        }, echartsProto.setTheme = function() {
            console.error("ECharts#setTheme() is DEPRECATED in ECharts 3.0");
        }, echartsProto.getModel = function() {
            return this._model;
        }, echartsProto.getOption = function() {
            return this._model && this._model.getOption();
        }, echartsProto.getWidth = function() {
            return this._zr.getWidth();
        }, echartsProto.getHeight = function() {
            return this._zr.getHeight();
        }, echartsProto.getDevicePixelRatio = function() {
            return this._zr.painter.dpr || window.devicePixelRatio || 1;
        }, echartsProto.getRenderedCanvas = function(opts) {
            if (env.canvasSupported) return (opts = opts || {}).pixelRatio = opts.pixelRatio || 1, 
            opts.backgroundColor = opts.backgroundColor || this._model.get("backgroundColor"), 
            this._zr.painter.getRenderedCanvas(opts);
        }, echartsProto.getSvgDataUrl = function() {
            if (env.svgSupported) {
                var zr = this._zr, list = zr.storage.getDisplayList();
                return zrUtil.each(list, function(el) {
                    el.stopAnimation(!0);
                }), zr.painter.pathToDataUrl();
            }
        }, echartsProto.getDataURL = function(opts) {
            var excludeComponents = (opts = opts || {}).excludeComponents, ecModel = this._model, excludesComponentViews = [], self = this;
            each(excludeComponents, function(componentType) {
                ecModel.eachComponent({
                    mainType: componentType
                }, function(component) {
                    var view = self._componentsMap[component.__viewId];
                    view.group.ignore || (excludesComponentViews.push(view), view.group.ignore = !0);
                });
            });
            var url = "svg" === this._zr.painter.getType() ? this.getSvgDataUrl() : this.getRenderedCanvas(opts).toDataURL("image/" + (opts && opts.type || "png"));
            return each(excludesComponentViews, function(view) {
                view.group.ignore = !1;
            }), url;
        }, echartsProto.getConnectedDataURL = function(opts) {
            if (env.canvasSupported) {
                var groupId = this.group, mathMin = Math.min, mathMax = Math.max;
                if (connectedGroups[groupId]) {
                    var left = 1 / 0, top = 1 / 0, right = -1 / 0, bottom = -1 / 0, canvasList = [], dpr = opts && opts.pixelRatio || 1;
                    zrUtil.each(instances, function(chart, id) {
                        if (chart.group === groupId) {
                            var canvas = chart.getRenderedCanvas(zrUtil.clone(opts)), boundingRect = chart.getDom().getBoundingClientRect();
                            left = mathMin(boundingRect.left, left), top = mathMin(boundingRect.top, top), right = mathMax(boundingRect.right, right), 
                            bottom = mathMax(boundingRect.bottom, bottom), canvasList.push({
                                dom: canvas,
                                left: boundingRect.left,
                                top: boundingRect.top
                            });
                        }
                    });
                    var width = (right *= dpr) - (left *= dpr), height = (bottom *= dpr) - (top *= dpr), targetCanvas = zrUtil.createCanvas();
                    targetCanvas.width = width, targetCanvas.height = height;
                    var zr = zrender.init(targetCanvas);
                    return opts.connectedBackgroundColor && zr.add(new graphic.Rect({
                        shape: {
                            x: 0,
                            y: 0,
                            width: width,
                            height: height
                        },
                        style: {
                            fill: opts.connectedBackgroundColor
                        }
                    })), each(canvasList, function(item) {
                        var img = new graphic.Image({
                            style: {
                                x: item.left * dpr - left,
                                y: item.top * dpr - top,
                                image: item.dom
                            }
                        });
                        zr.add(img);
                    }), zr.refreshImmediately(), targetCanvas.toDataURL("image/" + (opts && opts.type || "png"));
                }
                return this.getDataURL(opts);
            }
        }, echartsProto.convertToPixel = zrUtil.curry(doConvertPixel, "convertToPixel"), 
        echartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, "convertFromPixel"), 
        echartsProto.containPixel = function(finder, value) {
            var result, ecModel = this._model;
            return finder = modelUtil.parseFinder(ecModel, finder), zrUtil.each(finder, function(models, key) {
                key.indexOf("Models") >= 0 && zrUtil.each(models, function(model) {
                    var coordSys = model.coordinateSystem;
                    if (coordSys && coordSys.containPoint) result |= !!coordSys.containPoint(value); else if ("seriesModels" === key) {
                        var view = this._chartsMap[model.__viewId];
                        view && view.containPoint && (result |= view.containPoint(value, model));
                    }
                }, this);
            }, this), !!result;
        }, echartsProto.getVisual = function(finder, visualType) {
            var ecModel = this._model, data = (finder = modelUtil.parseFinder(ecModel, finder, {
                defaultMainType: "series"
            })).seriesModel.getData(), dataIndexInside = finder.hasOwnProperty("dataIndexInside") ? finder.dataIndexInside : finder.hasOwnProperty("dataIndex") ? data.indexOfRawIndex(finder.dataIndex) : null;
            return null != dataIndexInside ? data.getItemVisual(dataIndexInside, visualType) : data.getVisual(visualType);
        }, echartsProto.getViewOfComponentModel = function(componentModel) {
            return this._componentsMap[componentModel.__viewId];
        }, echartsProto.getViewOfSeriesModel = function(seriesModel) {
            return this._chartsMap[seriesModel.__viewId];
        };
        var updateMethods = {
            prepareAndUpdate: function(payload) {
                prepare(this), updateMethods.update.call(this, payload);
            },
            update: function(payload) {
                var ecModel = this._model, api = this._api, zr = this._zr, coordSysMgr = this._coordSysMgr, scheduler = this._scheduler;
                if (ecModel) {
                    scheduler.restoreData(ecModel, payload), scheduler.performSeriesTasks(ecModel), 
                    coordSysMgr.create(ecModel, api), scheduler.performDataProcessorTasks(ecModel, payload), 
                    updateStreamModes(this, ecModel), coordSysMgr.update(ecModel, api), clearColorPalette(ecModel), 
                    scheduler.performVisualTasks(ecModel, payload), render(this, ecModel, api, payload);
                    var backgroundColor = ecModel.get("backgroundColor") || "transparent";
                    if (env.canvasSupported) zr.setBackgroundColor(backgroundColor); else {
                        var colorArr = colorTool.parse(backgroundColor);
                        backgroundColor = colorTool.stringify(colorArr, "rgb"), 0 === colorArr[3] && (backgroundColor = "transparent");
                    }
                    performPostUpdateFuncs(ecModel, api);
                }
            },
            updateTransform: function(payload) {
                var ecModel = this._model, ecIns = this, api = this._api;
                if (ecModel) {
                    var componentDirtyList = [];
                    ecModel.eachComponent(function(componentType, componentModel) {
                        var componentView = ecIns.getViewOfComponentModel(componentModel);
                        if (componentView && componentView.__alive) if (componentView.updateTransform) {
                            var result = componentView.updateTransform(componentModel, ecModel, api, payload);
                            result && result.update && componentDirtyList.push(componentView);
                        } else componentDirtyList.push(componentView);
                    });
                    var seriesDirtyMap = zrUtil.createHashMap();
                    ecModel.eachSeries(function(seriesModel) {
                        var chartView = ecIns._chartsMap[seriesModel.__viewId];
                        if (chartView.updateTransform) {
                            var result = chartView.updateTransform(seriesModel, ecModel, api, payload);
                            result && result.update && seriesDirtyMap.set(seriesModel.uid, 1);
                        } else seriesDirtyMap.set(seriesModel.uid, 1);
                    }), clearColorPalette(ecModel), this._scheduler.performVisualTasks(ecModel, payload, {
                        setDirty: !0,
                        dirtyMap: seriesDirtyMap
                    }), renderSeries(ecIns, ecModel, api, payload, seriesDirtyMap), performPostUpdateFuncs(ecModel, this._api);
                }
            },
            updateView: function(payload) {
                var ecModel = this._model;
                ecModel && (ChartView.markUpdateMethod(payload, "updateView"), clearColorPalette(ecModel), 
                this._scheduler.performVisualTasks(ecModel, payload, {
                    setDirty: !0
                }), render(this, this._model, this._api, payload), performPostUpdateFuncs(ecModel, this._api));
            },
            updateVisual: function(payload) {
                updateMethods.update.call(this, payload);
            },
            updateLayout: function(payload) {
                updateMethods.update.call(this, payload);
            }
        };
        function prepare(ecIns) {
            var ecModel = ecIns._model, scheduler = ecIns._scheduler;
            scheduler.restorePipelines(ecModel), scheduler.prepareStageTasks(), prepareView(ecIns, "component", ecModel, scheduler), 
            prepareView(ecIns, "chart", ecModel, scheduler), scheduler.plan();
        }
        function updateDirectly(ecIns, method, payload, mainType, subType) {
            var ecModel = ecIns._model;
            if (mainType) {
                var query = {};
                query[mainType + "Id"] = payload[mainType + "Id"], query[mainType + "Index"] = payload[mainType + "Index"], 
                query[mainType + "Name"] = payload[mainType + "Name"];
                var condition = {
                    mainType: mainType,
                    query: query
                };
                subType && (condition.subType = subType);
                var excludeSeriesId = payload.excludeSeriesId;
                null != excludeSeriesId && (excludeSeriesId = zrUtil.createHashMap(modelUtil.normalizeToArray(excludeSeriesId))), 
                ecModel && ecModel.eachComponent(condition, function(model) {
                    excludeSeriesId && null != excludeSeriesId.get(model.id) || callView(ecIns["series" === mainType ? "_chartsMap" : "_componentsMap"][model.__viewId]);
                }, ecIns);
            } else each(ecIns._componentsViews.concat(ecIns._chartsViews), callView);
            function callView(view) {
                view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload);
            }
        }
        function updateStreamModes(ecIns, ecModel) {
            var chartsMap = ecIns._chartsMap, scheduler = ecIns._scheduler;
            ecModel.eachSeries(function(seriesModel) {
                scheduler.updateStreamModes(seriesModel, chartsMap[seriesModel.__viewId]);
            });
        }
        function doDispatchAction(payload, silent) {
            var payloadType = payload.type, escapeConnect = payload.escapeConnect, actionWrap = actions[payloadType], actionInfo = actionWrap.actionInfo, cptType = (actionInfo.update || "update").split(":"), updateMethod = cptType.pop();
            cptType = null != cptType[0] && parseClassType(cptType[0]), this[IN_MAIN_PROCESS] = !0;
            var payloads = [ payload ], batched = !1;
            payload.batch && (batched = !0, payloads = zrUtil.map(payload.batch, function(item) {
                return (item = zrUtil.defaults(zrUtil.extend({}, item), payload)).batch = null, 
                item;
            }));
            var eventObj, eventObjBatch = [], isHighDown = "highlight" === payloadType || "downplay" === payloadType;
            each(payloads, function(batchItem) {
                (eventObj = (eventObj = actionWrap.action(batchItem, this._model, this._api)) || zrUtil.extend({}, batchItem)).type = actionInfo.event || eventObj.type, 
                eventObjBatch.push(eventObj), isHighDown ? updateDirectly(this, updateMethod, batchItem, "series") : cptType && updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);
            }, this), "none" === updateMethod || isHighDown || cptType || (this[OPTION_UPDATED] ? (prepare(this), 
            updateMethods.update.call(this, payload), this[OPTION_UPDATED] = !1) : updateMethods[updateMethod].call(this, payload)), 
            eventObj = batched ? {
                type: actionInfo.event || payloadType,
                escapeConnect: escapeConnect,
                batch: eventObjBatch
            } : eventObjBatch[0], this[IN_MAIN_PROCESS] = !1, !silent && this._messageCenter.trigger(eventObj.type, eventObj);
        }
        function flushPendingActions(silent) {
            for (var pendingActions = this._pendingActions; pendingActions.length; ) {
                var payload = pendingActions.shift();
                doDispatchAction.call(this, payload, silent);
            }
        }
        function triggerUpdatedEvent(silent) {
            !silent && this.trigger("updated");
        }
        function prepareView(ecIns, type, ecModel, scheduler) {
            for (var isComponent = "component" === type, viewList = isComponent ? ecIns._componentsViews : ecIns._chartsViews, viewMap = isComponent ? ecIns._componentsMap : ecIns._chartsMap, zr = ecIns._zr, api = ecIns._api, i = 0; i < viewList.length; i++) viewList[i].__alive = !1;
            function doPrepare(model) {
                var viewId = "_ec_" + model.id + "_" + model.type, view = viewMap[viewId];
                if (!view) {
                    var classType = parseClassType(model.type);
                    (view = new (isComponent ? ComponentView.getClass(classType.main, classType.sub) : ChartView.getClass(classType.sub))()).init(ecModel, api), 
                    viewMap[viewId] = view, viewList.push(view), zr.add(view.group);
                }
                model.__viewId = view.__id = viewId, view.__alive = !0, view.__model = model, view.group.__ecComponentInfo = {
                    mainType: model.mainType,
                    index: model.componentIndex
                }, !isComponent && scheduler.prepareView(view, model, ecModel, api);
            }
            isComponent ? ecModel.eachComponent(function(componentType, model) {
                "series" !== componentType && doPrepare(model);
            }) : ecModel.eachSeries(doPrepare);
            for (i = 0; i < viewList.length; ) {
                var view = viewList[i];
                view.__alive ? i++ : (!isComponent && view.renderTask.dispose(), zr.remove(view.group), 
                view.dispose(ecModel, api), viewList.splice(i, 1), delete viewMap[view.__id], view.__id = view.group.__ecComponentInfo = null);
            }
        }
        function clearColorPalette(ecModel) {
            ecModel.clearColorPalette(), ecModel.eachSeries(function(seriesModel) {
                seriesModel.clearColorPalette();
            });
        }
        function render(ecIns, ecModel, api, payload) {
            !function(ecIns, ecModel, api, payload, dirtyList) {
                each(dirtyList || ecIns._componentsViews, function(componentView) {
                    var componentModel = componentView.__model;
                    componentView.render(componentModel, ecModel, api, payload), updateZ(componentModel, componentView);
                });
            }(ecIns, ecModel, api, payload), each(ecIns._chartsViews, function(chart) {
                chart.__alive = !1;
            }), renderSeries(ecIns, ecModel, api, payload), each(ecIns._chartsViews, function(chart) {
                chart.__alive || chart.remove(ecModel, api);
            });
        }
        function renderSeries(ecIns, ecModel, api, payload, dirtyMap) {
            var unfinished, scheduler = ecIns._scheduler;
            ecModel.eachSeries(function(seriesModel) {
                var chartView = ecIns._chartsMap[seriesModel.__viewId];
                chartView.__alive = !0;
                var renderTask = chartView.renderTask;
                scheduler.updatePayload(renderTask, payload), dirtyMap && dirtyMap.get(seriesModel.uid) && renderTask.dirty(), 
                unfinished |= renderTask.perform(scheduler.getPerformArgs(renderTask)), chartView.group.silent = !!seriesModel.get("silent"), 
                updateZ(seriesModel, chartView), function(seriesModel, chartView) {
                    var blendMode = seriesModel.get("blendMode") || null;
                    chartView.group.traverse(function(el) {
                        el.isGroup || el.style.blend !== blendMode && el.setStyle("blend", blendMode), el.eachPendingDisplayable && el.eachPendingDisplayable(function(displayable) {
                            displayable.setStyle("blend", blendMode);
                        });
                    });
                }(seriesModel, chartView);
            }), scheduler.unfinished |= unfinished, function(ecIns, ecModel) {
                var elCount = 0;
                ecIns._zr.storage.traverse(function(el) {
                    elCount++;
                }), elCount > ecModel.get("hoverLayerThreshold") && !env.node && ecModel.eachSeries(function(seriesModel) {
                    if (!seriesModel.preventUsingHoverLayer) {
                        var chartView = ecIns._chartsMap[seriesModel.__viewId];
                        chartView.__alive && chartView.group.traverse(function(el) {
                            el.useHoverLayer = !0;
                        });
                    }
                });
            }(ecIns, ecModel), aria(ecIns._zr.dom, ecModel);
        }
        function performPostUpdateFuncs(ecModel, api) {
            each(postUpdateFuncs, function(func) {
                func(ecModel, api);
            });
        }
        echartsProto.resize = function(opts) {
            this._zr.resize(opts);
            var ecModel = this._model;
            if (this._loadingFX && this._loadingFX.resize(), ecModel) {
                var optionChanged = ecModel.resetOption("media"), silent = opts && opts.silent;
                this[IN_MAIN_PROCESS] = !0, optionChanged && prepare(this), updateMethods.update.call(this), 
                this[IN_MAIN_PROCESS] = !1, flushPendingActions.call(this, silent), triggerUpdatedEvent.call(this, silent);
            }
        }, echartsProto.showLoading = function(name, cfg) {
            if (isObject(name) && (cfg = name, name = ""), name = name || "default", this.hideLoading(), 
            loadingEffects[name]) {
                var el = loadingEffects[name](this._api, cfg), zr = this._zr;
                this._loadingFX = el, zr.add(el);
            }
        }, echartsProto.hideLoading = function() {
            this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null;
        }, echartsProto.makeActionFromEvent = function(eventObj) {
            var payload = zrUtil.extend({}, eventObj);
            return payload.type = eventActionMap[eventObj.type], payload;
        }, echartsProto.dispatchAction = function(payload, opt) {
            isObject(opt) || (opt = {
                silent: !!opt
            }), actions[payload.type] && this._model && (this[IN_MAIN_PROCESS] ? this._pendingActions.push(payload) : (doDispatchAction.call(this, payload, opt.silent), 
            opt.flush ? this._zr.flush(!0) : !1 !== opt.flush && env.browser.weChat && this._throttledZrFlush(), 
            flushPendingActions.call(this, opt.silent), triggerUpdatedEvent.call(this, opt.silent)));
        }, echartsProto.appendData = function(params) {
            var seriesIndex = params.seriesIndex;
            this.getModel().getSeriesByIndex(seriesIndex).appendData(params), this._scheduler.unfinished = !0;
        }, echartsProto.on = createRegisterEventWithLowercaseName("on"), echartsProto.off = createRegisterEventWithLowercaseName("off"), 
        echartsProto.one = createRegisterEventWithLowercaseName("one");
        var MOUSE_EVENT_NAMES = [ "click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu" ];
        function updateZ(model, view) {
            var z = model.get("z"), zlevel = model.get("zlevel");
            view.group.traverse(function(el) {
                "group" !== el.type && (null != z && (el.z = z), null != zlevel && (el.zlevel = zlevel));
            });
        }
        function EventProcessor() {
            this.eventInfo;
        }
        echartsProto._initEvents = function() {
            each(MOUSE_EVENT_NAMES, function(eveName) {
                var handler = function(e) {
                    var params, ecModel = this.getModel(), el = e.target;
                    if ("globalout" === eveName) params = {}; else if (el && null != el.dataIndex) {
                        var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);
                        params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType, el) || {};
                    } else el && el.eventData && (params = zrUtil.extend({}, el.eventData));
                    if (params) {
                        var componentType = params.componentType, componentIndex = params.componentIndex;
                        "markLine" !== componentType && "markPoint" !== componentType && "markArea" !== componentType || (componentType = "series", 
                        componentIndex = params.seriesIndex);
                        var model = componentType && null != componentIndex && ecModel.getComponent(componentType, componentIndex), view = model && this["series" === model.mainType ? "_chartsMap" : "_componentsMap"][model.__viewId];
                        params.event = e, params.type = eveName, this._ecEventProcessor.eventInfo = {
                            targetEl: el,
                            packedEvent: params,
                            model: model,
                            view: view
                        }, this.trigger(eveName, params);
                    }
                };
                handler.zrEventfulCallAtLast = !0, this._zr.on(eveName, handler, this);
            }, this), each(eventActionMap, function(actionType, eventType) {
                this._messageCenter.on(eventType, function(event) {
                    this.trigger(eventType, event);
                }, this);
            }, this);
        }, echartsProto.isDisposed = function() {
            return this._disposed;
        }, echartsProto.clear = function() {
            this.setOption({
                series: []
            }, !0);
        }, echartsProto.dispose = function() {
            if (!this._disposed) {
                this._disposed = !0, modelUtil.setAttribute(this.getDom(), DOM_ATTRIBUTE_KEY, "");
                var api = this._api, ecModel = this._model;
                each(this._componentsViews, function(component) {
                    component.dispose(ecModel, api);
                }), each(this._chartsViews, function(chart) {
                    chart.dispose(ecModel, api);
                }), this._zr.dispose(), delete instances[this.id];
            }
        }, zrUtil.mixin(ECharts, Eventful), EventProcessor.prototype = {
            constructor: EventProcessor,
            normalizeQuery: function(query) {
                var cptQuery = {}, dataQuery = {}, otherQuery = {};
                if (zrUtil.isString(query)) {
                    var condCptType = parseClassType(query);
                    cptQuery.mainType = condCptType.main || null, cptQuery.subType = condCptType.sub || null;
                } else {
                    var suffixes = [ "Index", "Name", "Id" ], dataKeys = {
                        name: 1,
                        dataIndex: 1,
                        dataType: 1
                    };
                    zrUtil.each(query, function(val, key) {
                        for (var reserved = !1, i = 0; i < suffixes.length; i++) {
                            var propSuffix = suffixes[i], suffixPos = key.lastIndexOf(propSuffix);
                            if (suffixPos > 0 && suffixPos === key.length - propSuffix.length) {
                                var mainType = key.slice(0, suffixPos);
                                "data" !== mainType && (cptQuery.mainType = mainType, cptQuery[propSuffix.toLowerCase()] = val, 
                                reserved = !0);
                            }
                        }
                        dataKeys.hasOwnProperty(key) && (dataQuery[key] = val, reserved = !0), reserved || (otherQuery[key] = val);
                    });
                }
                return {
                    cptQuery: cptQuery,
                    dataQuery: dataQuery,
                    otherQuery: otherQuery
                };
            },
            filter: function(eventType, query, args) {
                var eventInfo = this.eventInfo;
                if (!eventInfo) return !0;
                var targetEl = eventInfo.targetEl, packedEvent = eventInfo.packedEvent, model = eventInfo.model, view = eventInfo.view;
                if (!model || !view) return !0;
                var cptQuery = query.cptQuery, dataQuery = query.dataQuery;
                return check(cptQuery, model, "mainType") && check(cptQuery, model, "subType") && check(cptQuery, model, "index", "componentIndex") && check(cptQuery, model, "name") && check(cptQuery, model, "id") && check(dataQuery, packedEvent, "name") && check(dataQuery, packedEvent, "dataIndex") && check(dataQuery, packedEvent, "dataType") && (!view.filterForExposedEvent || view.filterForExposedEvent(eventType, query.otherQuery, targetEl, packedEvent));
                function check(query, host, prop, propOnHost) {
                    return null == query[prop] || host[propOnHost || prop] === query[prop];
                }
            },
            afterTrigger: function() {
                this.eventInfo = null;
            }
        };
        var actions = {}, eventActionMap = {}, dataProcessorFuncs = [], optionPreprocessorFuncs = [], postUpdateFuncs = [], visualFuncs = [], themeStorage = {}, loadingEffects = {}, instances = {}, connectedGroups = {}, idBase = new Date() - 0, groupIdBase = new Date() - 0, DOM_ATTRIBUTE_KEY = "_echarts_instance_";
        function disConnect(groupId) {
            connectedGroups[groupId] = !1;
        }
        var disconnect = disConnect;
        function getInstanceByDom(dom) {
            return instances[modelUtil.getAttribute(dom, DOM_ATTRIBUTE_KEY)];
        }
        function registerTheme(name, theme) {
            themeStorage[name] = theme;
        }
        function registerPreprocessor(preprocessorFunc) {
            optionPreprocessorFuncs.push(preprocessorFunc);
        }
        function registerProcessor(priority, processor) {
            normalizeRegister(dataProcessorFuncs, priority, processor, PRIORITY_PROCESSOR_FILTER);
        }
        function registerAction(actionInfo, eventName, action) {
            "function" == typeof eventName && (action = eventName, eventName = "");
            var actionType = isObject(actionInfo) ? actionInfo.type : [ actionInfo, actionInfo = {
                event: eventName
            } ][0];
            actionInfo.event = (actionInfo.event || actionType).toLowerCase(), eventName = actionInfo.event, 
            assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName)), actions[actionType] || (actions[actionType] = {
                action: action,
                actionInfo: actionInfo
            }), eventActionMap[eventName] = actionType;
        }
        function registerVisual(priority, visualTask) {
            normalizeRegister(visualFuncs, priority, visualTask, PRIORITY_VISUAL_CHART, "visual");
        }
        function normalizeRegister(targetList, priority, fn, defaultPriority, visualType) {
            (isFunction(priority) || isObject(priority)) && (fn = priority, priority = defaultPriority);
            var stageHandler = Scheduler.wrapStageHandler(fn, visualType);
            return stageHandler.__prio = priority, stageHandler.__raw = fn, targetList.push(stageHandler), 
            stageHandler;
        }
        function registerLoading(name, loadingFx) {
            loadingEffects[name] = loadingFx;
        }
        registerVisual(2e3, seriesColor), registerPreprocessor(backwardCompat), registerProcessor(5e3, dataStack), 
        registerLoading("default", loadingDefault), registerAction({
            type: "highlight",
            event: "highlight",
            update: "highlight"
        }, zrUtil.noop), registerAction({
            type: "downplay",
            event: "downplay",
            update: "downplay"
        }, zrUtil.noop), registerTheme("light", lightTheme), registerTheme("dark", darkTheme);
        exports.version = "4.3.0", exports.dependencies = {
            zrender: "4.1.0"
        }, exports.PRIORITY = PRIORITY, exports.init = function(dom, theme, opts) {
            var existInstance = getInstanceByDom(dom);
            if (existInstance) return existInstance;
            var chart = new ECharts(dom, theme, opts);
            return chart.id = "ec_" + idBase++, instances[chart.id] = chart, modelUtil.setAttribute(dom, DOM_ATTRIBUTE_KEY, chart.id), 
            function(chart) {
                var STATUS_KEY = "__connectUpdateStatus";
                function updateConnectedChartsStatus(charts, status) {
                    for (var i = 0; i < charts.length; i++) charts[i][STATUS_KEY] = status;
                }
                each(eventActionMap, function(actionType, eventType) {
                    chart._messageCenter.on(eventType, function(event) {
                        if (connectedGroups[chart.group] && 0 !== chart[STATUS_KEY]) {
                            if (event && event.escapeConnect) return;
                            var action = chart.makeActionFromEvent(event), otherCharts = [];
                            each(instances, function(otherChart) {
                                otherChart !== chart && otherChart.group === chart.group && otherCharts.push(otherChart);
                            }), updateConnectedChartsStatus(otherCharts, 0), each(otherCharts, function(otherChart) {
                                1 !== otherChart[STATUS_KEY] && otherChart.dispatchAction(action);
                            }), updateConnectedChartsStatus(otherCharts, 2);
                        }
                    });
                });
            }(chart), chart;
        }, exports.connect = function(groupId) {
            if (zrUtil.isArray(groupId)) {
                var charts = groupId;
                groupId = null, each(charts, function(chart) {
                    null != chart.group && (groupId = chart.group);
                }), groupId = groupId || "g_" + groupIdBase++, each(charts, function(chart) {
                    chart.group = groupId;
                });
            }
            return connectedGroups[groupId] = !0, groupId;
        }, exports.disConnect = disConnect, exports.disconnect = disconnect, exports.dispose = function(chart) {
            "string" == typeof chart ? chart = instances[chart] : chart instanceof ECharts || (chart = getInstanceByDom(chart)), 
            chart instanceof ECharts && !chart.isDisposed() && chart.dispose();
        }, exports.getInstanceByDom = getInstanceByDom, exports.getInstanceById = function(key) {
            return instances[key];
        }, exports.registerTheme = registerTheme, exports.registerPreprocessor = registerPreprocessor, 
        exports.registerProcessor = registerProcessor, exports.registerPostUpdate = function(postUpdateFunc) {
            postUpdateFuncs.push(postUpdateFunc);
        }, exports.registerAction = registerAction, exports.registerCoordinateSystem = function(type, CoordinateSystem) {
            CoordinateSystemManager.register(type, CoordinateSystem);
        }, exports.getCoordinateSystemDimensions = function(type) {
            var coordSysCreator = CoordinateSystemManager.get(type);
            if (coordSysCreator) return coordSysCreator.getDimensionsInfo ? coordSysCreator.getDimensionsInfo() : coordSysCreator.dimensions.slice();
        }, exports.registerLayout = function(priority, layoutTask) {
            normalizeRegister(visualFuncs, priority, layoutTask, PRIORITY_VISUAL_LAYOUT, "layout");
        }, exports.registerVisual = registerVisual, exports.registerLoading = registerLoading, 
        exports.extendComponentModel = function(opts) {
            return ComponentModel.extend(opts);
        }, exports.extendComponentView = function(opts) {
            return ComponentView.extend(opts);
        }, exports.extendSeriesModel = function(opts) {
            return SeriesModel.extend(opts);
        }, exports.extendChartView = function(opts) {
            return ChartView.extend(opts);
        }, exports.setCanvasCreator = function(creator) {
            zrUtil.$override("createCanvas", creator);
        }, exports.registerMap = function(mapName, geoJson, specialAreas) {
            mapDataStorage.registerMap(mapName, geoJson, specialAreas);
        }, exports.getMap = function(mapName) {
            var records = mapDataStorage.retrieveMap(mapName);
            return records && records[0] && {
                geoJson: records[0].geoJSON,
                specialAreas: records[0].specialAreas
            };
        }, exports.dataTool = {};
        var ___ec_export = __webpack_require__(234);
        !function() {
            for (var key in ___ec_export) ___ec_export.hasOwnProperty(key) && (exports[key] = ___ec_export[key]);
        }();
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), pathTool = __webpack_require__(99), colorTool = __webpack_require__(20), matrix = __webpack_require__(17), vector = __webpack_require__(6), Path = __webpack_require__(8), Transformable = __webpack_require__(89), ZImage = __webpack_require__(55);
        exports.Image = ZImage;
        var Group = __webpack_require__(27);
        exports.Group = Group;
        var Text = __webpack_require__(58);
        exports.Text = Text;
        var Circle = __webpack_require__(105);
        exports.Circle = Circle;
        var Sector = __webpack_require__(208);
        exports.Sector = Sector;
        var Ring = __webpack_require__(209);
        exports.Ring = Ring;
        var Polygon = __webpack_require__(107);
        exports.Polygon = Polygon;
        var Polyline = __webpack_require__(109);
        exports.Polyline = Polyline;
        var Rect = __webpack_require__(110);
        exports.Rect = Rect;
        var Line = __webpack_require__(111);
        exports.Line = Line;
        var BezierCurve = __webpack_require__(212);
        exports.BezierCurve = BezierCurve;
        var Arc = __webpack_require__(213);
        exports.Arc = Arc;
        var CompoundPath = __webpack_require__(214);
        exports.CompoundPath = CompoundPath;
        var LinearGradient = __webpack_require__(60);
        exports.LinearGradient = LinearGradient;
        var RadialGradient = __webpack_require__(215);
        exports.RadialGradient = RadialGradient;
        var BoundingRect = __webpack_require__(12);
        exports.BoundingRect = BoundingRect;
        var IncrementalDisplayable = __webpack_require__(62);
        exports.IncrementalDisplayable = IncrementalDisplayable;
        var subPixelOptimizeUtil = __webpack_require__(59), mathMax = Math.max, mathMin = Math.min, EMPTY_OBJ = {}, Z2_EMPHASIS_LIFT = 1, EMPHASIS = "emphasis", NORMAL = "normal", _highlightNextDigit = 1, _highlightKeyMap = {};
        function makePath(pathData, opts, rect, layout) {
            var path = pathTool.createFromString(pathData, opts);
            return rect && ("center" === layout && (rect = centerGraphic(rect, path.getBoundingRect())), 
            resizePath(path, rect)), path;
        }
        function centerGraphic(rect, boundingRect) {
            var height, aspect = boundingRect.width / boundingRect.height, width = rect.height * aspect;
            return height = width <= rect.width ? rect.height : (width = rect.width) / aspect, 
            {
                x: rect.x + rect.width / 2 - width / 2,
                y: rect.y + rect.height / 2 - height / 2,
                width: width,
                height: height
            };
        }
        var mergePath = pathTool.mergePath;
        function resizePath(path, rect) {
            if (path.applyTransform) {
                var m = path.getBoundingRect().calculateTransform(rect);
                path.applyTransform(m);
            }
        }
        var subPixelOptimize = subPixelOptimizeUtil.subPixelOptimize;
        function hasFillOrStroke(fillOrStroke) {
            return null != fillOrStroke && "none" !== fillOrStroke;
        }
        var liftedColorMap = zrUtil.createHashMap(), liftedColorCount = 0;
        function singleEnterEmphasis(el) {
            var hoverStl = el.__hoverStl;
            if (hoverStl && !el.__highlighted) {
                var useHoverLayer = el.useHoverLayer;
                el.__highlighted = useHoverLayer ? "layer" : "plain";
                var zr = el.__zr;
                if (!(el.isGroup || !zr && useHoverLayer)) {
                    var elTarget = el, targetStyle = el.style;
                    useHoverLayer && (targetStyle = (elTarget = zr.addHover(el)).style), rollbackDefaultTextStyle(targetStyle), 
                    useHoverLayer || function(el) {
                        if (el.__hoverStlDirty) {
                            el.__hoverStlDirty = !1;
                            var hoverStyle = el.__hoverStl;
                            if (hoverStyle) {
                                var normalStyle = el.__cachedNormalStl = {};
                                el.__cachedNormalZ2 = el.z2;
                                var elStyle = el.style;
                                for (var name in hoverStyle) null != hoverStyle[name] && (normalStyle[name] = elStyle[name]);
                                normalStyle.fill = elStyle.fill, normalStyle.stroke = elStyle.stroke;
                            } else el.__cachedNormalStl = el.__cachedNormalZ2 = null;
                        }
                    }(elTarget), targetStyle.extendFrom(hoverStl), setDefaultHoverFillStroke(targetStyle, hoverStl, "fill"), 
                    setDefaultHoverFillStroke(targetStyle, hoverStl, "stroke"), applyDefaultTextStyle(targetStyle), 
                    useHoverLayer || (el.dirty(!1), el.z2 += Z2_EMPHASIS_LIFT);
                }
            }
        }
        function setDefaultHoverFillStroke(targetStyle, hoverStyle, prop) {
            !hasFillOrStroke(hoverStyle[prop]) && hasFillOrStroke(targetStyle[prop]) && (targetStyle[prop] = function(color) {
                if ("string" != typeof color) return color;
                var liftedColor = liftedColorMap.get(color);
                return liftedColor || (liftedColor = colorTool.lift(color, -.1), liftedColorCount < 1e4 && (liftedColorMap.set(color, liftedColor), 
                liftedColorCount++)), liftedColor;
            }(targetStyle[prop]));
        }
        function singleEnterNormal(el) {
            var highlighted = el.__highlighted;
            if (highlighted && (el.__highlighted = !1, !el.isGroup)) if ("layer" === highlighted) el.__zr && el.__zr.removeHover(el); else {
                var style = el.style, normalStl = el.__cachedNormalStl;
                normalStl && (rollbackDefaultTextStyle(style), el.setStyle(normalStl), applyDefaultTextStyle(style));
                var normalZ2 = el.__cachedNormalZ2;
                null != normalZ2 && el.z2 - normalZ2 === Z2_EMPHASIS_LIFT && (el.z2 = normalZ2);
            }
        }
        function traverseUpdate(el, updater, commonParam) {
            var trigger, fromState = NORMAL, toState = NORMAL;
            el.__highlighted && (fromState = EMPHASIS, trigger = !0), updater(el, commonParam), 
            el.__highlighted && (toState = EMPHASIS, trigger = !0), el.isGroup && el.traverse(function(child) {
                !child.isGroup && updater(child, commonParam);
            }), trigger && el.__highDownOnUpdate && el.__highDownOnUpdate(fromState, toState);
        }
        function setElementHoverStyle(el, hoverStl) {
            hoverStl = el.__hoverStl = !1 !== hoverStl && (el.hoverStyle || hoverStl || {}), 
            el.__hoverStlDirty = !0, el.__highlighted && (el.__cachedNormalStl = null, singleEnterNormal(el), 
            singleEnterEmphasis(el));
        }
        function onElementMouseOver(e) {
            !shouldSilent(this, e) && !this.__highByOuter && traverseUpdate(this, singleEnterEmphasis);
        }
        function onElementMouseOut(e) {
            !shouldSilent(this, e) && !this.__highByOuter && traverseUpdate(this, singleEnterNormal);
        }
        function onElementEmphasisEvent(highlightDigit) {
            this.__highByOuter |= 1 << (highlightDigit || 0), traverseUpdate(this, singleEnterEmphasis);
        }
        function onElementNormalEvent(highlightDigit) {
            !(this.__highByOuter &= ~(1 << (highlightDigit || 0))) && traverseUpdate(this, singleEnterNormal);
        }
        function shouldSilent(el, e) {
            return el.__highDownSilentOnTouch && e.zrByTouch;
        }
        function setAsHighDownDispatcher(el, asDispatcher) {
            var disable = !1 === asDispatcher;
            if (el.__highDownSilentOnTouch = el.highDownSilentOnTouch, el.__highDownOnUpdate = el.highDownOnUpdate, 
            !disable || el.__highDownDispatcher) {
                var method = disable ? "off" : "on";
                el[method]("mouseover", onElementMouseOver)[method]("mouseout", onElementMouseOut), 
                el[method]("emphasis", onElementEmphasisEvent)[method]("normal", onElementNormalEvent), 
                el.__highByOuter = el.__highByOuter || 0, el.__highDownDispatcher = !disable;
            }
        }
        function setTextStyle(textStyle, textStyleModel, specifiedTextStyle, opt, isEmphasis) {
            return setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis), specifiedTextStyle && zrUtil.extend(textStyle, specifiedTextStyle), 
            textStyle;
        }
        function setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis) {
            if ((opt = opt || EMPTY_OBJ).isRectText) {
                var textPosition = textStyleModel.getShallow("position") || (isEmphasis ? null : "inside");
                "outside" === textPosition && (textPosition = "top"), textStyle.textPosition = textPosition, 
                textStyle.textOffset = textStyleModel.getShallow("offset");
                var labelRotate = textStyleModel.getShallow("rotate");
                null != labelRotate && (labelRotate *= Math.PI / 180), textStyle.textRotation = labelRotate, 
                textStyle.textDistance = zrUtil.retrieve2(textStyleModel.getShallow("distance"), isEmphasis ? null : 5);
            }
            var richResult, ecModel = textStyleModel.ecModel, globalTextStyle = ecModel && ecModel.option.textStyle, richItemNames = function(textStyleModel) {
                var richItemNameMap;
                for (;textStyleModel && textStyleModel !== textStyleModel.ecModel; ) {
                    var rich = (textStyleModel.option || EMPTY_OBJ).rich;
                    if (rich) for (var name in richItemNameMap = richItemNameMap || {}, rich) rich.hasOwnProperty(name) && (richItemNameMap[name] = 1);
                    textStyleModel = textStyleModel.parentModel;
                }
                return richItemNameMap;
            }(textStyleModel);
            if (richItemNames) for (var name in richResult = {}, richItemNames) if (richItemNames.hasOwnProperty(name)) {
                var richTextStyle = textStyleModel.getModel([ "rich", name ]);
                setTokenTextStyle(richResult[name] = {}, richTextStyle, globalTextStyle, opt, isEmphasis);
            }
            return textStyle.rich = richResult, setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, !0), 
            opt.forceRich && !opt.textStyle && (opt.textStyle = {}), textStyle;
        }
        function setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, isBlock) {
            globalTextStyle = !isEmphasis && globalTextStyle || EMPTY_OBJ, textStyle.textFill = getAutoColor(textStyleModel.getShallow("color"), opt) || globalTextStyle.color, 
            textStyle.textStroke = getAutoColor(textStyleModel.getShallow("textBorderColor"), opt) || globalTextStyle.textBorderColor, 
            textStyle.textStrokeWidth = zrUtil.retrieve2(textStyleModel.getShallow("textBorderWidth"), globalTextStyle.textBorderWidth), 
            isEmphasis || (isBlock && (textStyle.insideRollbackOpt = opt, applyDefaultTextStyle(textStyle)), 
            null == textStyle.textFill && (textStyle.textFill = opt.autoColor)), textStyle.fontStyle = textStyleModel.getShallow("fontStyle") || globalTextStyle.fontStyle, 
            textStyle.fontWeight = textStyleModel.getShallow("fontWeight") || globalTextStyle.fontWeight, 
            textStyle.fontSize = textStyleModel.getShallow("fontSize") || globalTextStyle.fontSize, 
            textStyle.fontFamily = textStyleModel.getShallow("fontFamily") || globalTextStyle.fontFamily, 
            textStyle.textAlign = textStyleModel.getShallow("align"), textStyle.textVerticalAlign = textStyleModel.getShallow("verticalAlign") || textStyleModel.getShallow("baseline"), 
            textStyle.textLineHeight = textStyleModel.getShallow("lineHeight"), textStyle.textWidth = textStyleModel.getShallow("width"), 
            textStyle.textHeight = textStyleModel.getShallow("height"), textStyle.textTag = textStyleModel.getShallow("tag"), 
            isBlock && opt.disableBox || (textStyle.textBackgroundColor = getAutoColor(textStyleModel.getShallow("backgroundColor"), opt), 
            textStyle.textPadding = textStyleModel.getShallow("padding"), textStyle.textBorderColor = getAutoColor(textStyleModel.getShallow("borderColor"), opt), 
            textStyle.textBorderWidth = textStyleModel.getShallow("borderWidth"), textStyle.textBorderRadius = textStyleModel.getShallow("borderRadius"), 
            textStyle.textBoxShadowColor = textStyleModel.getShallow("shadowColor"), textStyle.textBoxShadowBlur = textStyleModel.getShallow("shadowBlur"), 
            textStyle.textBoxShadowOffsetX = textStyleModel.getShallow("shadowOffsetX"), textStyle.textBoxShadowOffsetY = textStyleModel.getShallow("shadowOffsetY")), 
            textStyle.textShadowColor = textStyleModel.getShallow("textShadowColor") || globalTextStyle.textShadowColor, 
            textStyle.textShadowBlur = textStyleModel.getShallow("textShadowBlur") || globalTextStyle.textShadowBlur, 
            textStyle.textShadowOffsetX = textStyleModel.getShallow("textShadowOffsetX") || globalTextStyle.textShadowOffsetX, 
            textStyle.textShadowOffsetY = textStyleModel.getShallow("textShadowOffsetY") || globalTextStyle.textShadowOffsetY;
        }
        function getAutoColor(color, opt) {
            return "auto" !== color ? color : opt && opt.autoColor ? opt.autoColor : null;
        }
        function applyDefaultTextStyle(textStyle) {
            var insideRollback, textPosition = textStyle.textPosition, opt = textStyle.insideRollbackOpt;
            if (opt && null == textStyle.textFill) {
                var autoColor = opt.autoColor, isRectText = opt.isRectText, useInsideStyle = opt.useInsideStyle, useInsideStyleCache = !1 !== useInsideStyle && (!0 === useInsideStyle || isRectText && textPosition && "string" == typeof textPosition && textPosition.indexOf("inside") >= 0), useAutoColorCache = !useInsideStyleCache && null != autoColor;
                (useInsideStyleCache || useAutoColorCache) && (insideRollback = {
                    textFill: textStyle.textFill,
                    textStroke: textStyle.textStroke,
                    textStrokeWidth: textStyle.textStrokeWidth
                }), useInsideStyleCache && (textStyle.textFill = "#fff", null == textStyle.textStroke && (textStyle.textStroke = autoColor, 
                null == textStyle.textStrokeWidth && (textStyle.textStrokeWidth = 2))), useAutoColorCache && (textStyle.textFill = autoColor);
            }
            textStyle.insideRollback = insideRollback;
        }
        function rollbackDefaultTextStyle(style) {
            var insideRollback = style.insideRollback;
            insideRollback && (style.textFill = insideRollback.textFill, style.textStroke = insideRollback.textStroke, 
            style.textStrokeWidth = insideRollback.textStrokeWidth, style.insideRollback = null);
        }
        function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {
            if ("function" == typeof dataIndex && (cb = dataIndex, dataIndex = null), animatableModel && animatableModel.isAnimationEnabled()) {
                var postfix = isUpdate ? "Update" : "", duration = animatableModel.getShallow("animationDuration" + postfix), animationEasing = animatableModel.getShallow("animationEasing" + postfix), animationDelay = animatableModel.getShallow("animationDelay" + postfix);
                "function" == typeof animationDelay && (animationDelay = animationDelay(dataIndex, animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null)), 
                "function" == typeof duration && (duration = duration(dataIndex)), duration > 0 ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb, !!cb) : (el.stopAnimation(), 
                el.attr(props), cb && cb());
            } else el.stopAnimation(), el.attr(props), cb && cb();
        }
        function updateProps(el, props, animatableModel, dataIndex, cb) {
            animateOrSetProps(!0, el, props, animatableModel, dataIndex, cb);
        }
        function applyTransform(target, transform, invert) {
            return transform && !zrUtil.isArrayLike(transform) && (transform = Transformable.getLocalTransform(transform)), 
            invert && (transform = matrix.invert([], transform)), vector.applyTransform([], target, transform);
        }
        function lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
            var mx = a2x - a1x, my = a2y - a1y, nx = b2x - b1x, ny = b2y - b1y, nmCrossProduct = crossProduct2d(nx, ny, mx, my);
            if (function(val) {
                return val <= 1e-6 && val >= -1e-6;
            }(nmCrossProduct)) return !1;
            var b1a1x = a1x - b1x, b1a1y = a1y - b1y, q = crossProduct2d(b1a1x, b1a1y, mx, my) / nmCrossProduct;
            if (q < 0 || q > 1) return !1;
            var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;
            return !(p < 0 || p > 1);
        }
        function crossProduct2d(x1, y1, x2, y2) {
            return x1 * y2 - x2 * y1;
        }
        exports.Z2_EMPHASIS_LIFT = Z2_EMPHASIS_LIFT, exports.CACHED_LABEL_STYLE_PROPERTIES = {
            color: "textFill",
            textBorderColor: "textStroke",
            textBorderWidth: "textStrokeWidth"
        }, exports.extendShape = function(opts) {
            return Path.extend(opts);
        }, exports.extendPath = function(pathData, opts) {
            return pathTool.extendFromString(pathData, opts);
        }, exports.makePath = makePath, exports.makeImage = function(imageUrl, rect, layout) {
            var path = new ZImage({
                style: {
                    image: imageUrl,
                    x: rect.x,
                    y: rect.y,
                    width: rect.width,
                    height: rect.height
                },
                onload: function(img) {
                    if ("center" === layout) {
                        var boundingRect = {
                            width: img.width,
                            height: img.height
                        };
                        path.setStyle(centerGraphic(rect, boundingRect));
                    }
                }
            });
            return path;
        }, exports.mergePath = mergePath, exports.resizePath = resizePath, exports.subPixelOptimizeLine = function(param) {
            return subPixelOptimizeUtil.subPixelOptimizeLine(param.shape, param.shape, param.style), 
            param;
        }, exports.subPixelOptimizeRect = function(param) {
            return subPixelOptimizeUtil.subPixelOptimizeRect(param.shape, param.shape, param.style), 
            param;
        }, exports.subPixelOptimize = subPixelOptimize, exports.setElementHoverStyle = setElementHoverStyle, 
        exports.setHoverStyle = function(el, hoverStyle) {
            setAsHighDownDispatcher(el, !0), traverseUpdate(el, setElementHoverStyle, hoverStyle);
        }, exports.setAsHighDownDispatcher = setAsHighDownDispatcher, exports.isHighDownDispatcher = function(el) {
            return !(!el || !el.__highDownDispatcher);
        }, exports.getHighlightDigit = function(highlightKey) {
            var highlightDigit = _highlightKeyMap[highlightKey];
            return null == highlightDigit && _highlightNextDigit <= 32 && (highlightDigit = _highlightKeyMap[highlightKey] = _highlightNextDigit++), 
            highlightDigit;
        }, exports.setLabelStyle = function(normalStyle, emphasisStyle, normalModel, emphasisModel, opt, normalSpecified, emphasisSpecified) {
            var baseText, labelFetcher = (opt = opt || EMPTY_OBJ).labelFetcher, labelDataIndex = opt.labelDataIndex, labelDimIndex = opt.labelDimIndex, showNormal = normalModel.getShallow("show"), showEmphasis = emphasisModel.getShallow("show");
            (showNormal || showEmphasis) && (labelFetcher && (baseText = labelFetcher.getFormattedLabel(labelDataIndex, "normal", null, labelDimIndex)), 
            null == baseText && (baseText = zrUtil.isFunction(opt.defaultText) ? opt.defaultText(labelDataIndex, opt) : opt.defaultText));
            var normalStyleText = showNormal ? baseText : null, emphasisStyleText = showEmphasis ? zrUtil.retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, "emphasis", null, labelDimIndex) : null, baseText) : null;
            null == normalStyleText && null == emphasisStyleText || (setTextStyle(normalStyle, normalModel, normalSpecified, opt), 
            setTextStyle(emphasisStyle, emphasisModel, emphasisSpecified, opt, !0)), normalStyle.text = normalStyleText, 
            emphasisStyle.text = emphasisStyleText;
        }, exports.modifyLabelStyle = function(el, normalStyleProps, emphasisStyleProps) {
            var elStyle = el.style;
            normalStyleProps && (rollbackDefaultTextStyle(elStyle), el.setStyle(normalStyleProps), 
            applyDefaultTextStyle(elStyle)), elStyle = el.__hoverStl, emphasisStyleProps && elStyle && (rollbackDefaultTextStyle(elStyle), 
            zrUtil.extend(elStyle, emphasisStyleProps), applyDefaultTextStyle(elStyle));
        }, exports.setTextStyle = setTextStyle, exports.setText = function(textStyle, labelModel, defaultColor) {
            var isEmphasis, opt = {
                isRectText: !0
            };
            !1 === defaultColor ? isEmphasis = !0 : opt.autoColor = defaultColor, setTextStyleCommon(textStyle, labelModel, opt, isEmphasis);
        }, exports.getFont = function(opt, ecModel) {
            var gTextStyleModel = ecModel || ecModel.getModel("textStyle");
            return zrUtil.trim([ opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow("fontStyle") || "", opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow("fontWeight") || "", (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow("fontSize") || 12) + "px", opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow("fontFamily") || "sans-serif" ].join(" "));
        }, exports.updateProps = updateProps, exports.initProps = function(el, props, animatableModel, dataIndex, cb) {
            animateOrSetProps(!1, el, props, animatableModel, dataIndex, cb);
        }, exports.getTransform = function(target, ancestor) {
            for (var mat = matrix.identity([]); target && target !== ancestor; ) matrix.mul(mat, target.getLocalTransform(), mat), 
            target = target.parent;
            return mat;
        }, exports.applyTransform = applyTransform, exports.transformDirection = function(direction, transform, invert) {
            var hBase = 0 === transform[4] || 0 === transform[5] || 0 === transform[0] ? 1 : Math.abs(2 * transform[4] / transform[0]), vBase = 0 === transform[4] || 0 === transform[5] || 0 === transform[2] ? 1 : Math.abs(2 * transform[4] / transform[2]), vertex = [ "left" === direction ? -hBase : "right" === direction ? hBase : 0, "top" === direction ? -vBase : "bottom" === direction ? vBase : 0 ];
            return vertex = applyTransform(vertex, transform, invert), Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? "right" : "left" : vertex[1] > 0 ? "bottom" : "top";
        }, exports.groupTransition = function(g1, g2, animatableModel, cb) {
            if (g1 && g2) {
                var elMap1 = function(g) {
                    var elMap = {};
                    return g.traverse(function(el) {
                        !el.isGroup && el.anid && (elMap[el.anid] = el);
                    }), elMap;
                }(g1);
                g2.traverse(function(el) {
                    if (!el.isGroup && el.anid) {
                        var oldEl = elMap1[el.anid];
                        if (oldEl) {
                            var newProp = getAnimatableProps(el);
                            el.attr(getAnimatableProps(oldEl)), updateProps(el, newProp, animatableModel, el.dataIndex);
                        }
                    }
                });
            }
            function getAnimatableProps(el) {
                var obj = {
                    position: vector.clone(el.position),
                    rotation: el.rotation
                };
                return el.shape && (obj.shape = zrUtil.extend({}, el.shape)), obj;
            }
        }, exports.clipPointsByRect = function(points, rect) {
            return zrUtil.map(points, function(point) {
                var x = point[0];
                x = mathMax(x, rect.x), x = mathMin(x, rect.x + rect.width);
                var y = point[1];
                return y = mathMax(y, rect.y), [ x, y = mathMin(y, rect.y + rect.height) ];
            });
        }, exports.clipRectByRect = function(targetRect, rect) {
            var x = mathMax(targetRect.x, rect.x), x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width), y = mathMax(targetRect.y, rect.y), y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height);
            if (x2 >= x && y2 >= y) return {
                x: x,
                y: y,
                width: x2 - x,
                height: y2 - y
            };
        }, exports.createIcon = function(iconStr, opt, rect) {
            var style = (opt = zrUtil.extend({
                rectHover: !0
            }, opt)).style = {
                strokeNoScale: !0
            };
            if (rect = rect || {
                x: -1,
                y: -1,
                width: 2,
                height: 2
            }, iconStr) return 0 === iconStr.indexOf("image://") ? (style.image = iconStr.slice(8), 
            zrUtil.defaults(style, rect), new ZImage(opt)) : makePath(iconStr.replace("path://", ""), opt, rect, "center");
        }, exports.linePolygonIntersect = function(a1x, a1y, a2x, a2y, points) {
            for (var i = 0, p2 = points[points.length - 1]; i < points.length; i++) {
                var p = points[i];
                if (lineLineIntersect(a1x, a1y, a2x, a2y, p[0], p[1], p2[0], p2[1])) return !0;
                p2 = p;
            }
        }, exports.lineLineIntersect = lineLineIntersect;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), env = __webpack_require__(7), each = zrUtil.each, isObject = zrUtil.isObject, isArray = zrUtil.isArray, DUMMY_COMPONENT_NAME_PREFIX = "series\0";
        function normalizeToArray(value) {
            return value instanceof Array ? value : null == value ? [] : [ value ];
        }
        function isIdInner(cptOption) {
            return isObject(cptOption) && cptOption.id && 0 === (cptOption.id + "").indexOf("\0_ec_\0");
        }
        var innerUniqueIndex = 0;
        function has(obj, prop) {
            return obj && obj.hasOwnProperty(prop);
        }
        exports.normalizeToArray = normalizeToArray, exports.defaultEmphasis = function(opt, key, subOpts) {
            if (opt) {
                opt[key] = opt[key] || {}, opt.emphasis = opt.emphasis || {}, opt.emphasis[key] = opt.emphasis[key] || {};
                for (var i = 0, len = subOpts.length; i < len; i++) {
                    var subOptName = subOpts[i];
                    !opt.emphasis[key].hasOwnProperty(subOptName) && opt[key].hasOwnProperty(subOptName) && (opt.emphasis[key][subOptName] = opt[key][subOptName]);
                }
            }
        }, exports.TEXT_STYLE_OPTIONS = [ "fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding" ], 
        exports.getDataItemValue = function(dataItem) {
            return !isObject(dataItem) || isArray(dataItem) || dataItem instanceof Date ? dataItem : dataItem.value;
        }, exports.isDataItemOption = function(dataItem) {
            return isObject(dataItem) && !(dataItem instanceof Array);
        }, exports.mappingToExists = function(exists, newCptOptions) {
            newCptOptions = (newCptOptions || []).slice();
            var result = zrUtil.map(exists || [], function(obj, index) {
                return {
                    exist: obj
                };
            });
            return each(newCptOptions, function(cptOption, index) {
                if (isObject(cptOption)) {
                    for (var i = 0; i < result.length; i++) if (!result[i].option && null != cptOption.id && result[i].exist.id === cptOption.id + "") return result[i].option = cptOption, 
                    void (newCptOptions[index] = null);
                    for (i = 0; i < result.length; i++) {
                        var exist = result[i].exist;
                        if (!(result[i].option || null != exist.id && null != cptOption.id || null == cptOption.name || isIdInner(cptOption) || isIdInner(exist) || exist.name !== cptOption.name + "")) return result[i].option = cptOption, 
                        void (newCptOptions[index] = null);
                    }
                }
            }), each(newCptOptions, function(cptOption, index) {
                if (isObject(cptOption)) {
                    for (var i = 0; i < result.length; i++) {
                        var exist = result[i].exist;
                        if (!result[i].option && !isIdInner(exist) && null == cptOption.id) {
                            result[i].option = cptOption;
                            break;
                        }
                    }
                    i >= result.length && result.push({
                        option: cptOption
                    });
                }
            }), result;
        }, exports.makeIdAndName = function(mapResult) {
            var idMap = zrUtil.createHashMap();
            each(mapResult, function(item, index) {
                var existCpt = item.exist;
                existCpt && idMap.set(existCpt.id, item);
            }), each(mapResult, function(item, index) {
                var opt = item.option;
                zrUtil.assert(!opt || null == opt.id || !idMap.get(opt.id) || idMap.get(opt.id) === item, "id duplicates: " + (opt && opt.id)), 
                opt && null != opt.id && idMap.set(opt.id, item), !item.keyInfo && (item.keyInfo = {});
            }), each(mapResult, function(item, index) {
                var existCpt = item.exist, opt = item.option, keyInfo = item.keyInfo;
                if (isObject(opt)) {
                    if (keyInfo.name = null != opt.name ? opt.name + "" : existCpt ? existCpt.name : DUMMY_COMPONENT_NAME_PREFIX + index, 
                    existCpt) keyInfo.id = existCpt.id; else if (null != opt.id) keyInfo.id = opt.id + ""; else {
                        var idNum = 0;
                        do {
                            keyInfo.id = "\0" + keyInfo.name + "\0" + idNum++;
                        } while (idMap.get(keyInfo.id));
                    }
                    idMap.set(keyInfo.id, item);
                }
            });
        }, exports.isNameSpecified = function(componentModel) {
            var name = componentModel.name;
            return !(!name || !name.indexOf(DUMMY_COMPONENT_NAME_PREFIX));
        }, exports.isIdInner = isIdInner, exports.compressBatches = function(batchA, batchB) {
            var mapA = {}, mapB = {};
            return makeMap(batchA || [], mapA), makeMap(batchB || [], mapB, mapA), [ mapToArray(mapA), mapToArray(mapB) ];
            function makeMap(sourceBatch, map, otherMap) {
                for (var i = 0, len = sourceBatch.length; i < len; i++) for (var seriesId = sourceBatch[i].seriesId, dataIndices = normalizeToArray(sourceBatch[i].dataIndex), otherDataIndices = otherMap && otherMap[seriesId], j = 0, lenj = dataIndices.length; j < lenj; j++) {
                    var dataIndex = dataIndices[j];
                    otherDataIndices && otherDataIndices[dataIndex] ? otherDataIndices[dataIndex] = null : (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;
                }
            }
            function mapToArray(map, isData) {
                var result = [];
                for (var i in map) if (map.hasOwnProperty(i) && null != map[i]) if (isData) result.push(+i); else {
                    var dataIndices = mapToArray(map[i], !0);
                    dataIndices.length && result.push({
                        seriesId: i,
                        dataIndex: dataIndices
                    });
                }
                return result;
            }
        }, exports.queryDataIndex = function(data, payload) {
            return null != payload.dataIndexInside ? payload.dataIndexInside : null != payload.dataIndex ? zrUtil.isArray(payload.dataIndex) ? zrUtil.map(payload.dataIndex, function(value) {
                return data.indexOfRawIndex(value);
            }) : data.indexOfRawIndex(payload.dataIndex) : null != payload.name ? zrUtil.isArray(payload.name) ? zrUtil.map(payload.name, function(value) {
                return data.indexOfName(value);
            }) : data.indexOfName(payload.name) : void 0;
        }, exports.makeInner = function() {
            var key = "__\0ec_inner_" + innerUniqueIndex++ + "_" + Math.random().toFixed(5);
            return function(hostObj) {
                return hostObj[key] || (hostObj[key] = {});
            };
        }, exports.parseFinder = function(ecModel, finder, opt) {
            if (zrUtil.isString(finder)) {
                var obj = {};
                obj[finder + "Index"] = 0, finder = obj;
            }
            var defaultMainType = opt && opt.defaultMainType;
            !defaultMainType || has(finder, defaultMainType + "Index") || has(finder, defaultMainType + "Id") || has(finder, defaultMainType + "Name") || (finder[defaultMainType + "Index"] = 0);
            var result = {};
            return each(finder, function(value, key) {
                if (value = finder[key], "dataIndex" !== key && "dataIndexInside" !== key) {
                    var parsedKey = key.match(/^(\w+)(Index|Id|Name)$/) || [], mainType = parsedKey[1], queryType = (parsedKey[2] || "").toLowerCase();
                    if (!(!mainType || !queryType || null == value || "index" === queryType && "none" === value || opt && opt.includeMainTypes && zrUtil.indexOf(opt.includeMainTypes, mainType) < 0)) {
                        var queryParam = {
                            mainType: mainType
                        };
                        "index" === queryType && "all" === value || (queryParam[queryType] = value);
                        var models = ecModel.queryComponents(queryParam);
                        result[mainType + "Models"] = models, result[mainType + "Model"] = models[0];
                    }
                } else result[key] = value;
            }), result;
        }, exports.setAttribute = function(dom, key, value) {
            dom.setAttribute ? dom.setAttribute(key, value) : dom[key] = value;
        }, exports.getAttribute = function(dom, key) {
            return dom.getAttribute ? dom.getAttribute(key) : dom[key];
        }, exports.getTooltipRenderMode = function(renderModeOption) {
            return "auto" === renderModeOption ? env.domSupported ? "html" : "richText" : renderModeOption || "html";
        }, exports.groupData = function(array, getKey) {
            var buckets = zrUtil.createHashMap(), keys = [];
            return zrUtil.each(array, function(item) {
                var key = getKey(item);
                (buckets.get(key) || (keys.push(key), buckets.set(key, []))).push(item);
            }), {
                keys: keys,
                buckets: buckets
            };
        };
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), RADIAN_EPSILON = 1e-4;
        var TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d\d)(?::(\d\d)(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
        function quantityExponent(val) {
            return Math.floor(Math.log(val) / Math.LN10);
        }
        exports.linearMap = function(val, domain, range, clamp) {
            var subDomain = domain[1] - domain[0], subRange = range[1] - range[0];
            if (0 === subDomain) return 0 === subRange ? range[0] : (range[0] + range[1]) / 2;
            if (clamp) if (subDomain > 0) {
                if (val <= domain[0]) return range[0];
                if (val >= domain[1]) return range[1];
            } else {
                if (val >= domain[0]) return range[0];
                if (val <= domain[1]) return range[1];
            } else {
                if (val === domain[0]) return range[0];
                if (val === domain[1]) return range[1];
            }
            return (val - domain[0]) / subDomain * subRange + range[0];
        }, exports.parsePercent = function(percent, all) {
            switch (percent) {
              case "center":
              case "middle":
                percent = "50%";
                break;

              case "left":
              case "top":
                percent = "0%";
                break;

              case "right":
              case "bottom":
                percent = "100%";
            }
            return "string" == typeof percent ? function(str) {
                return str.replace(/^\s+/, "").replace(/\s+$/, "");
            }(percent).match(/%$/) ? parseFloat(percent) / 100 * all : parseFloat(percent) : null == percent ? NaN : +percent;
        }, exports.round = function(x, precision, returnStr) {
            return null == precision && (precision = 10), precision = Math.min(Math.max(0, precision), 20), 
            x = (+x).toFixed(precision), returnStr ? x : +x;
        }, exports.asc = function(arr) {
            return arr.sort(function(a, b) {
                return a - b;
            }), arr;
        }, exports.getPrecision = function(val) {
            if (val = +val, isNaN(val)) return 0;
            for (var e = 1, count = 0; Math.round(val * e) / e !== val; ) e *= 10, count++;
            return count;
        }, exports.getPrecisionSafe = function(val) {
            var str = val.toString(), eIndex = str.indexOf("e");
            if (eIndex > 0) {
                var precision = +str.slice(eIndex + 1);
                return precision < 0 ? -precision : 0;
            }
            var dotIndex = str.indexOf(".");
            return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;
        }, exports.getPixelPrecision = function(dataExtent, pixelExtent) {
            var log = Math.log, LN10 = Math.LN10, dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10), sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10), precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);
            return isFinite(precision) ? precision : 20;
        }, exports.getPercentWithPrecision = function(valueList, idx, precision) {
            if (!valueList[idx]) return 0;
            var sum = zrUtil.reduce(valueList, function(acc, val) {
                return acc + (isNaN(val) ? 0 : val);
            }, 0);
            if (0 === sum) return 0;
            for (var digits = Math.pow(10, precision), votesPerQuota = zrUtil.map(valueList, function(val) {
                return (isNaN(val) ? 0 : val) / sum * digits * 100;
            }), targetSeats = 100 * digits, seats = zrUtil.map(votesPerQuota, function(votes) {
                return Math.floor(votes);
            }), currentSum = zrUtil.reduce(seats, function(acc, val) {
                return acc + val;
            }, 0), remainder = zrUtil.map(votesPerQuota, function(votes, idx) {
                return votes - seats[idx];
            }); currentSum < targetSeats; ) {
                for (var max = Number.NEGATIVE_INFINITY, maxId = null, i = 0, len = remainder.length; i < len; ++i) remainder[i] > max && (max = remainder[i], 
                maxId = i);
                ++seats[maxId], remainder[maxId] = 0, ++currentSum;
            }
            return seats[idx] / digits;
        }, exports.MAX_SAFE_INTEGER = 9007199254740991, exports.remRadian = function(radian) {
            var pi2 = 2 * Math.PI;
            return (radian % pi2 + pi2) % pi2;
        }, exports.isRadianAroundZero = function(val) {
            return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;
        }, exports.parseDate = function(value) {
            if (value instanceof Date) return value;
            if ("string" == typeof value) {
                var match = TIME_REG.exec(value);
                if (!match) return new Date(NaN);
                if (match[8]) {
                    var hour = +match[4] || 0;
                    return "Z" !== match[8].toUpperCase() && (hour -= match[8].slice(0, 3)), new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, +match[7] || 0));
                }
                return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, +match[7] || 0);
            }
            return null == value ? new Date(NaN) : new Date(Math.round(value));
        }, exports.quantity = function(val) {
            return Math.pow(10, quantityExponent(val));
        }, exports.nice = function(val, round) {
            var exponent = quantityExponent(val), exp10 = Math.pow(10, exponent), f = val / exp10;
            return val = (round ? f < 1.5 ? 1 : f < 2.5 ? 2 : f < 4 ? 3 : f < 7 ? 5 : 10 : f < 1 ? 1 : f < 2 ? 2 : f < 3 ? 3 : f < 5 ? 5 : 10) * exp10, 
            exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;
        }, exports.quantile = function(ascArr, p) {
            var H = (ascArr.length - 1) * p + 1, h = Math.floor(H), v = +ascArr[h - 1], e = H - h;
            return e ? v + e * (ascArr[h] - v) : v;
        }, exports.reformIntervals = function(list) {
            list.sort(function(a, b) {
                return function littleThan(a, b, lg) {
                    return a.interval[lg] < b.interval[lg] || a.interval[lg] === b.interval[lg] && (a.close[lg] - b.close[lg] == (lg ? -1 : 1) || !lg && littleThan(a, b, 1));
                }(a, b, 0) ? -1 : 1;
            });
            for (var curr = -1 / 0, currClose = 1, i = 0; i < list.length; ) {
                for (var interval = list[i].interval, close = list[i].close, lg = 0; lg < 2; lg++) interval[lg] <= curr && (interval[lg] = curr, 
                close[lg] = lg ? 1 : 1 - currClose), curr = interval[lg], currClose = close[lg];
                interval[0] === interval[1] && close[0] * close[1] != 1 ? list.splice(i, 1) : i++;
            }
            return list;
        }, exports.isNumeric = function(v) {
            return v - parseFloat(v) >= 0;
        };
    }, function(module, exports, __webpack_require__) {
        (function(global) {
            var dev;
            "undefined" != typeof window ? dev = window.__DEV__ : void 0 !== global && (dev = global.__DEV__), 
            void 0 === dev && (dev = !0);
            var __DEV__ = dev;
            exports.__DEV__ = __DEV__;
        }).call(this, __webpack_require__(52));
    }, function(module, exports) {
        var ArrayCtor = "undefined" == typeof Float32Array ? Array : Float32Array;
        function len(v) {
            return Math.sqrt(lenSquare(v));
        }
        var length = len;
        function lenSquare(v) {
            return v[0] * v[0] + v[1] * v[1];
        }
        var lengthSquare = lenSquare;
        function distance(v1, v2) {
            return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
        }
        var dist = distance;
        function distanceSquare(v1, v2) {
            return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
        }
        var distSquare = distanceSquare;
        exports.create = function(x, y) {
            var out = new ArrayCtor(2);
            return null == x && (x = 0), null == y && (y = 0), out[0] = x, out[1] = y, out;
        }, exports.copy = function(out, v) {
            return out[0] = v[0], out[1] = v[1], out;
        }, exports.clone = function(v) {
            var out = new ArrayCtor(2);
            return out[0] = v[0], out[1] = v[1], out;
        }, exports.set = function(out, a, b) {
            return out[0] = a, out[1] = b, out;
        }, exports.add = function(out, v1, v2) {
            return out[0] = v1[0] + v2[0], out[1] = v1[1] + v2[1], out;
        }, exports.scaleAndAdd = function(out, v1, v2, a) {
            return out[0] = v1[0] + v2[0] * a, out[1] = v1[1] + v2[1] * a, out;
        }, exports.sub = function(out, v1, v2) {
            return out[0] = v1[0] - v2[0], out[1] = v1[1] - v2[1], out;
        }, exports.len = len, exports.length = length, exports.lenSquare = lenSquare, exports.lengthSquare = lengthSquare, 
        exports.mul = function(out, v1, v2) {
            return out[0] = v1[0] * v2[0], out[1] = v1[1] * v2[1], out;
        }, exports.div = function(out, v1, v2) {
            return out[0] = v1[0] / v2[0], out[1] = v1[1] / v2[1], out;
        }, exports.dot = function(v1, v2) {
            return v1[0] * v2[0] + v1[1] * v2[1];
        }, exports.scale = function(out, v, s) {
            return out[0] = v[0] * s, out[1] = v[1] * s, out;
        }, exports.normalize = function(out, v) {
            var d = len(v);
            return 0 === d ? (out[0] = 0, out[1] = 0) : (out[0] = v[0] / d, out[1] = v[1] / d), 
            out;
        }, exports.distance = distance, exports.dist = dist, exports.distanceSquare = distanceSquare, 
        exports.distSquare = distSquare, exports.negate = function(out, v) {
            return out[0] = -v[0], out[1] = -v[1], out;
        }, exports.lerp = function(out, v1, v2, t) {
            return out[0] = v1[0] + t * (v2[0] - v1[0]), out[1] = v1[1] + t * (v2[1] - v1[1]), 
            out;
        }, exports.applyTransform = function(out, v, m) {
            var x = v[0], y = v[1];
            return out[0] = m[0] * x + m[2] * y + m[4], out[1] = m[1] * x + m[3] * y + m[5], 
            out;
        }, exports.min = function(out, v1, v2) {
            return out[0] = Math.min(v1[0], v2[0]), out[1] = Math.min(v1[1], v2[1]), out;
        }, exports.max = function(out, v1, v2) {
            return out[0] = Math.max(v1[0], v2[0]), out[1] = Math.max(v1[1], v2[1]), out;
        };
    }, function(module, exports) {
        var _default = "object" == typeof wx && "function" == typeof wx.getSystemInfoSync ? {
            browser: {},
            os: {},
            node: !1,
            wxa: !0,
            canvasSupported: !0,
            svgSupported: !1,
            touchEventsSupported: !0,
            domSupported: !1
        } : "undefined" == typeof document && "undefined" != typeof self ? {
            browser: {},
            os: {},
            node: !1,
            worker: !0,
            canvasSupported: !0,
            domSupported: !1
        } : "undefined" == typeof navigator ? {
            browser: {},
            os: {},
            node: !0,
            worker: !1,
            canvasSupported: !0,
            svgSupported: !0,
            domSupported: !1
        } : function(ua) {
            var browser = {}, firefox = ua.match(/Firefox\/([\d.]+)/), ie = ua.match(/MSIE\s([\d.]+)/) || ua.match(/Trident\/.+?rv:(([\d.]+))/), edge = ua.match(/Edge\/([\d.]+)/), weChat = /micromessenger/i.test(ua);
            firefox && (browser.firefox = !0, browser.version = firefox[1]);
            ie && (browser.ie = !0, browser.version = ie[1]);
            edge && (browser.edge = !0, browser.version = edge[1]);
            weChat && (browser.weChat = !0);
            return {
                browser: browser,
                os: {},
                node: !1,
                canvasSupported: !!document.createElement("canvas").getContext,
                svgSupported: "undefined" != typeof SVGRect,
                touchEventsSupported: "ontouchstart" in window && !browser.ie && !browser.edge,
                pointerEventsSupported: "onpointerdown" in window && (browser.edge || browser.ie && browser.version >= 11),
                domSupported: "undefined" != typeof document
            };
        }(navigator.userAgent);
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var Displayable = __webpack_require__(37), zrUtil = __webpack_require__(0), PathProxy = __webpack_require__(38), pathContain = __webpack_require__(204), getCanvasPattern = __webpack_require__(94).prototype.getCanvasPattern, abs = Math.abs, pathProxyForDraw = new PathProxy(!0);
        function Path(opts) {
            Displayable.call(this, opts), this.path = null;
        }
        Path.prototype = {
            constructor: Path,
            type: "path",
            __dirtyPath: !0,
            strokeContainThreshold: 5,
            segmentIgnoreThreshold: 0,
            subPixelOptimize: !1,
            brush: function(ctx, prevEl) {
                var rect, style = this.style, path = this.path || pathProxyForDraw, hasStroke = style.hasStroke(), hasFill = style.hasFill(), fill = style.fill, stroke = style.stroke, hasFillGradient = hasFill && !!fill.colorStops, hasStrokeGradient = hasStroke && !!stroke.colorStops, hasFillPattern = hasFill && !!fill.image, hasStrokePattern = hasStroke && !!stroke.image;
                (style.bind(ctx, this, prevEl), this.setTransform(ctx), this.__dirty) && (hasFillGradient && (rect = rect || this.getBoundingRect(), 
                this._fillGradient = style.getGradient(ctx, fill, rect)), hasStrokeGradient && (rect = rect || this.getBoundingRect(), 
                this._strokeGradient = style.getGradient(ctx, stroke, rect)));
                hasFillGradient ? ctx.fillStyle = this._fillGradient : hasFillPattern && (ctx.fillStyle = getCanvasPattern.call(fill, ctx)), 
                hasStrokeGradient ? ctx.strokeStyle = this._strokeGradient : hasStrokePattern && (ctx.strokeStyle = getCanvasPattern.call(stroke, ctx));
                var lineDash = style.lineDash, lineDashOffset = style.lineDashOffset, ctxLineDash = !!ctx.setLineDash, scale = this.getGlobalScale();
                if (path.setScale(scale[0], scale[1], this.segmentIgnoreThreshold), this.__dirtyPath || lineDash && !ctxLineDash && hasStroke ? (path.beginPath(ctx), 
                lineDash && !ctxLineDash && (path.setLineDash(lineDash), path.setLineDashOffset(lineDashOffset)), 
                this.buildPath(path, this.shape, !1), this.path && (this.__dirtyPath = !1)) : (ctx.beginPath(), 
                this.path.rebuildPath(ctx)), hasFill) if (null != style.fillOpacity) {
                    var originalGlobalAlpha = ctx.globalAlpha;
                    ctx.globalAlpha = style.fillOpacity * style.opacity, path.fill(ctx), ctx.globalAlpha = originalGlobalAlpha;
                } else path.fill(ctx);
                if (lineDash && ctxLineDash && (ctx.setLineDash(lineDash), ctx.lineDashOffset = lineDashOffset), 
                hasStroke) if (null != style.strokeOpacity) {
                    originalGlobalAlpha = ctx.globalAlpha;
                    ctx.globalAlpha = style.strokeOpacity * style.opacity, path.stroke(ctx), ctx.globalAlpha = originalGlobalAlpha;
                } else path.stroke(ctx);
                lineDash && ctxLineDash && ctx.setLineDash([]), null != style.text && (this.restoreTransform(ctx), 
                this.drawRectText(ctx, this.getBoundingRect()));
            },
            buildPath: function(ctx, shapeCfg, inBundle) {},
            createPathProxy: function() {
                this.path = new PathProxy();
            },
            getBoundingRect: function() {
                var rect = this._rect, style = this.style, needsUpdateRect = !rect;
                if (needsUpdateRect) {
                    var path = this.path;
                    path || (path = this.path = new PathProxy()), this.__dirtyPath && (path.beginPath(), 
                    this.buildPath(path, this.shape, !1)), rect = path.getBoundingRect();
                }
                if (this._rect = rect, style.hasStroke()) {
                    var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());
                    if (this.__dirty || needsUpdateRect) {
                        rectWithStroke.copy(rect);
                        var w = style.lineWidth, lineScale = style.strokeNoScale ? this.getLineScale() : 1;
                        style.hasFill() || (w = Math.max(w, this.strokeContainThreshold || 4)), lineScale > 1e-10 && (rectWithStroke.width += w / lineScale, 
                        rectWithStroke.height += w / lineScale, rectWithStroke.x -= w / lineScale / 2, rectWithStroke.y -= w / lineScale / 2);
                    }
                    return rectWithStroke;
                }
                return rect;
            },
            contain: function(x, y) {
                var localPos = this.transformCoordToLocal(x, y), rect = this.getBoundingRect(), style = this.style;
                if (x = localPos[0], y = localPos[1], rect.contain(x, y)) {
                    var pathData = this.path.data;
                    if (style.hasStroke()) {
                        var lineWidth = style.lineWidth, lineScale = style.strokeNoScale ? this.getLineScale() : 1;
                        if (lineScale > 1e-10 && (style.hasFill() || (lineWidth = Math.max(lineWidth, this.strokeContainThreshold)), 
                        pathContain.containStroke(pathData, lineWidth / lineScale, x, y))) return !0;
                    }
                    if (style.hasFill()) return pathContain.contain(pathData, x, y);
                }
                return !1;
            },
            dirty: function(dirtyPath) {
                null == dirtyPath && (dirtyPath = !0), dirtyPath && (this.__dirtyPath = dirtyPath, 
                this._rect = null), this.__dirty = this.__dirtyText = !0, this.__zr && this.__zr.refresh(), 
                this.__clipTarget && this.__clipTarget.dirty();
            },
            animateShape: function(loop) {
                return this.animate("shape", loop);
            },
            attrKV: function(key, value) {
                "shape" === key ? (this.setShape(value), this.__dirtyPath = !0, this._rect = null) : Displayable.prototype.attrKV.call(this, key, value);
            },
            setShape: function(key, value) {
                var shape = this.shape;
                if (shape) {
                    if (zrUtil.isObject(key)) for (var name in key) key.hasOwnProperty(name) && (shape[name] = key[name]); else shape[key] = value;
                    this.dirty(!0);
                }
                return this;
            },
            getLineScale: function() {
                var m = this.transform;
                return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;
            }
        }, Path.extend = function(defaults) {
            var Sub = function(opts) {
                Path.call(this, opts), defaults.style && this.style.extendFrom(defaults.style, !1);
                var defaultShape = defaults.shape;
                if (defaultShape) {
                    this.shape = this.shape || {};
                    var thisShape = this.shape;
                    for (var name in defaultShape) !thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name) && (thisShape[name] = defaultShape[name]);
                }
                defaults.init && defaults.init.call(this, opts);
            };
            for (var name in zrUtil.inherits(Sub, Path), defaults) "style" !== name && "shape" !== name && (Sub.prototype[name] = defaults[name]);
            return Sub;
        }, zrUtil.inherits(Path, Displayable);
        var _default = Path;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), textContain = __webpack_require__(21), numberUtil = __webpack_require__(4);
        var normalizeCssArray = zrUtil.normalizeCssArray, replaceReg = /([&<>"'])/g, replaceMap = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;"
        };
        function encodeHTML(source) {
            return null == source ? "" : (source + "").replace(replaceReg, function(str, c) {
                return replaceMap[c];
            });
        }
        var TPL_VAR_ALIAS = [ "a", "b", "c", "d", "e", "f", "g" ], wrapVar = function(varName, seriesIdx) {
            return "{" + varName + (null == seriesIdx ? "" : seriesIdx) + "}";
        };
        function pad(str, len) {
            return "0000".substr(0, len - (str += "").length) + str;
        }
        var truncateText = textContain.truncateText;
        exports.addCommas = function(x) {
            return isNaN(x) ? "-" : (x = (x + "").split("."))[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (x.length > 1 ? "." + x[1] : "");
        }, exports.toCamelCase = function(str, upperCaseFirst) {
            return str = (str || "").toLowerCase().replace(/-(.)/g, function(match, group1) {
                return group1.toUpperCase();
            }), upperCaseFirst && str && (str = str.charAt(0).toUpperCase() + str.slice(1)), 
            str;
        }, exports.normalizeCssArray = normalizeCssArray, exports.encodeHTML = encodeHTML, 
        exports.formatTpl = function(tpl, paramsList, encode) {
            zrUtil.isArray(paramsList) || (paramsList = [ paramsList ]);
            var seriesLen = paramsList.length;
            if (!seriesLen) return "";
            for (var $vars = paramsList[0].$vars || [], i = 0; i < $vars.length; i++) {
                var alias = TPL_VAR_ALIAS[i];
                tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));
            }
            for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) for (var k = 0; k < $vars.length; k++) {
                var val = paramsList[seriesIdx][$vars[k]];
                tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), encode ? encodeHTML(val) : val);
            }
            return tpl;
        }, exports.formatTplSimple = function(tpl, param, encode) {
            return zrUtil.each(param, function(value, key) {
                tpl = tpl.replace("{" + key + "}", encode ? encodeHTML(value) : value);
            }), tpl;
        }, exports.getTooltipMarker = function(opt, extraCssText) {
            var color = (opt = zrUtil.isString(opt) ? {
                color: opt,
                extraCssText: extraCssText
            } : opt || {}).color, type = opt.type, renderMode = (extraCssText = opt.extraCssText, 
            opt.renderMode || "html"), markerId = opt.markerId || "X";
            return color ? "html" === renderMode ? "subItem" === type ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + encodeHTML(color) + ";" + (extraCssText || "") + '"></span>' : '<span style="display:inline-block;margin-right:5px;border-radius:10px;width:10px;height:10px;background-color:' + encodeHTML(color) + ";" + (extraCssText || "") + '"></span>' : {
                renderMode: renderMode,
                content: "{marker" + markerId + "|}  ",
                style: {
                    color: color
                }
            } : "";
        }, exports.formatTime = function(tpl, value, isUTC) {
            "week" !== tpl && "month" !== tpl && "quarter" !== tpl && "half-year" !== tpl && "year" !== tpl || (tpl = "MM-dd\nyyyy");
            var date = numberUtil.parseDate(value), utc = isUTC ? "UTC" : "", y = date["get" + utc + "FullYear"](), M = date["get" + utc + "Month"]() + 1, d = date["get" + utc + "Date"](), h = date["get" + utc + "Hours"](), m = date["get" + utc + "Minutes"](), s = date["get" + utc + "Seconds"](), S = date["get" + utc + "Milliseconds"]();
            return tpl = tpl.replace("MM", pad(M, 2)).replace("M", M).replace("yyyy", y).replace("yy", y % 100).replace("dd", pad(d, 2)).replace("d", d).replace("hh", pad(h, 2)).replace("h", h).replace("mm", pad(m, 2)).replace("m", m).replace("ss", pad(s, 2)).replace("s", s).replace("SSS", pad(S, 3));
        }, exports.capitalFirst = function(str) {
            return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;
        }, exports.truncateText = truncateText, exports.getTextBoundingRect = function(opt) {
            return textContain.getBoundingRect(opt.text, opt.font, opt.textAlign, opt.textVerticalAlign, opt.textPadding, opt.textLineHeight, opt.rich, opt.truncate);
        }, exports.getTextRect = function(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate, textLineHeight) {
            return textContain.getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate);
        };
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), BoundingRect = __webpack_require__(12), parsePercent = __webpack_require__(4).parsePercent, formatUtil = __webpack_require__(9), each = zrUtil.each, LOCATION_PARAMS = [ "left", "right", "top", "bottom", "width", "height" ], HV_NAMES = [ [ "width", "left", "right" ], [ "height", "top", "bottom" ] ];
        function boxLayout(orient, group, gap, maxWidth, maxHeight) {
            var x = 0, y = 0;
            null == maxWidth && (maxWidth = 1 / 0), null == maxHeight && (maxHeight = 1 / 0);
            var currentLineMaxSize = 0;
            group.eachChild(function(child, idx) {
                var nextX, nextY, position = child.position, rect = child.getBoundingRect(), nextChild = group.childAt(idx + 1), nextChildRect = nextChild && nextChild.getBoundingRect();
                if ("horizontal" === orient) {
                    var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);
                    (nextX = x + moveX) > maxWidth || child.newline ? (x = 0, nextX = moveX, y += currentLineMaxSize + gap, 
                    currentLineMaxSize = rect.height) : currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
                } else {
                    var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);
                    (nextY = y + moveY) > maxHeight || child.newline ? (x += currentLineMaxSize + gap, 
                    y = 0, nextY = moveY, currentLineMaxSize = rect.width) : currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
                }
                child.newline || (position[0] = x, position[1] = y, "horizontal" === orient ? x = nextX + gap : y = nextY + gap);
            });
        }
        var box = boxLayout, vbox = zrUtil.curry(boxLayout, "vertical"), hbox = zrUtil.curry(boxLayout, "horizontal");
        function getLayoutRect(positionInfo, containerRect, margin) {
            margin = formatUtil.normalizeCssArray(margin || 0);
            var containerWidth = containerRect.width, containerHeight = containerRect.height, left = parsePercent(positionInfo.left, containerWidth), top = parsePercent(positionInfo.top, containerHeight), right = parsePercent(positionInfo.right, containerWidth), bottom = parsePercent(positionInfo.bottom, containerHeight), width = parsePercent(positionInfo.width, containerWidth), height = parsePercent(positionInfo.height, containerHeight), verticalMargin = margin[2] + margin[0], horizontalMargin = margin[1] + margin[3], aspect = positionInfo.aspect;
            switch (isNaN(width) && (width = containerWidth - right - horizontalMargin - left), 
            isNaN(height) && (height = containerHeight - bottom - verticalMargin - top), null != aspect && (isNaN(width) && isNaN(height) && (aspect > containerWidth / containerHeight ? width = .8 * containerWidth : height = .8 * containerHeight), 
            isNaN(width) && (width = aspect * height), isNaN(height) && (height = width / aspect)), 
            isNaN(left) && (left = containerWidth - right - width - horizontalMargin), isNaN(top) && (top = containerHeight - bottom - height - verticalMargin), 
            positionInfo.left || positionInfo.right) {
              case "center":
                left = containerWidth / 2 - width / 2 - margin[3];
                break;

              case "right":
                left = containerWidth - width - horizontalMargin;
            }
            switch (positionInfo.top || positionInfo.bottom) {
              case "middle":
              case "center":
                top = containerHeight / 2 - height / 2 - margin[0];
                break;

              case "bottom":
                top = containerHeight - height - verticalMargin;
            }
            left = left || 0, top = top || 0, isNaN(width) && (width = containerWidth - horizontalMargin - left - (right || 0)), 
            isNaN(height) && (height = containerHeight - verticalMargin - top - (bottom || 0));
            var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);
            return rect.margin = margin, rect;
        }
        function copyLayoutParams(target, source) {
            return source && target && each(LOCATION_PARAMS, function(name) {
                source.hasOwnProperty(name) && (target[name] = source[name]);
            }), target;
        }
        exports.LOCATION_PARAMS = LOCATION_PARAMS, exports.HV_NAMES = HV_NAMES, exports.box = box, 
        exports.vbox = vbox, exports.hbox = hbox, exports.getAvailableSize = function(positionInfo, containerRect, margin) {
            var containerWidth = containerRect.width, containerHeight = containerRect.height, x = parsePercent(positionInfo.x, containerWidth), y = parsePercent(positionInfo.y, containerHeight), x2 = parsePercent(positionInfo.x2, containerWidth), y2 = parsePercent(positionInfo.y2, containerHeight);
            return (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0), (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth), 
            (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0), (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight), 
            margin = formatUtil.normalizeCssArray(margin || 0), {
                width: Math.max(x2 - x - margin[1] - margin[3], 0),
                height: Math.max(y2 - y - margin[0] - margin[2], 0)
            };
        }, exports.getLayoutRect = getLayoutRect, exports.positionElement = function(el, positionInfo, containerRect, margin, opt) {
            var h = !opt || !opt.hv || opt.hv[0], v = !opt || !opt.hv || opt.hv[1], boundingMode = opt && opt.boundingMode || "all";
            if (h || v) {
                var rect;
                if ("raw" === boundingMode) rect = "group" === el.type ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect(); else if (rect = el.getBoundingRect(), 
                el.needLocalTransform()) {
                    var transform = el.getLocalTransform();
                    (rect = rect.clone()).applyTransform(transform);
                }
                positionInfo = getLayoutRect(zrUtil.defaults({
                    width: rect.width,
                    height: rect.height
                }, positionInfo), containerRect, margin);
                var elPos = el.position, dx = h ? positionInfo.x - rect.x : 0, dy = v ? positionInfo.y - rect.y : 0;
                el.attr("position", "raw" === boundingMode ? [ dx, dy ] : [ elPos[0] + dx, elPos[1] + dy ]);
            }
        }, exports.sizeCalculable = function(option, hvIdx) {
            return null != option[HV_NAMES[hvIdx][0]] || null != option[HV_NAMES[hvIdx][1]] && null != option[HV_NAMES[hvIdx][2]];
        }, exports.mergeLayoutParam = function(targetOption, newOption, opt) {
            !zrUtil.isObject(opt) && (opt = {});
            var ignoreSize = opt.ignoreSize;
            !zrUtil.isArray(ignoreSize) && (ignoreSize = [ ignoreSize, ignoreSize ]);
            var hResult = merge(HV_NAMES[0], 0), vResult = merge(HV_NAMES[1], 1);
            function merge(names, hvIdx) {
                var newParams = {}, newValueCount = 0, merged = {}, mergedValueCount = 0;
                if (each(names, function(name) {
                    merged[name] = targetOption[name];
                }), each(names, function(name) {
                    hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]), 
                    hasValue(newParams, name) && newValueCount++, hasValue(merged, name) && mergedValueCount++;
                }), ignoreSize[hvIdx]) return hasValue(newOption, names[1]) ? merged[names[2]] = null : hasValue(newOption, names[2]) && (merged[names[1]] = null), 
                merged;
                if (2 !== mergedValueCount && newValueCount) {
                    if (newValueCount >= 2) return newParams;
                    for (var i = 0; i < names.length; i++) {
                        var name = names[i];
                        if (!hasProp(newParams, name) && hasProp(targetOption, name)) {
                            newParams[name] = targetOption[name];
                            break;
                        }
                    }
                    return newParams;
                }
                return merged;
            }
            function hasProp(obj, name) {
                return obj.hasOwnProperty(name);
            }
            function hasValue(obj, name) {
                return null != obj[name] && "auto" !== obj[name];
            }
            function copy(names, target, source) {
                each(names, function(name) {
                    target[name] = source[name];
                });
            }
            copy(HV_NAMES[0], targetOption, hResult), copy(HV_NAMES[1], targetOption, vResult);
        }, exports.getLayoutParams = function(source) {
            return copyLayoutParams({}, source);
        }, exports.copyLayoutParams = copyLayoutParams;
    }, function(module, exports, __webpack_require__) {
        "use strict";
        var bind = __webpack_require__(77), isBuffer = __webpack_require__(156), toString = Object.prototype.toString;
        function isArray(val) {
            return "[object Array]" === toString.call(val);
        }
        function isObject(val) {
            return null !== val && "object" == typeof val;
        }
        function isFunction(val) {
            return "[object Function]" === toString.call(val);
        }
        function forEach(obj, fn) {
            if (null !== obj && void 0 !== obj) if ("object" != typeof obj && (obj = [ obj ]), 
            isArray(obj)) for (var i = 0, l = obj.length; i < l; i++) fn.call(null, obj[i], i, obj); else for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && fn.call(null, obj[key], key, obj);
        }
        module.exports = {
            isArray: isArray,
            isArrayBuffer: function(val) {
                return "[object ArrayBuffer]" === toString.call(val);
            },
            isBuffer: isBuffer,
            isFormData: function(val) {
                return "undefined" != typeof FormData && val instanceof FormData;
            },
            isArrayBufferView: function(val) {
                return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(val) : val && val.buffer && val.buffer instanceof ArrayBuffer;
            },
            isString: function(val) {
                return "string" == typeof val;
            },
            isNumber: function(val) {
                return "number" == typeof val;
            },
            isObject: isObject,
            isUndefined: function(val) {
                return void 0 === val;
            },
            isDate: function(val) {
                return "[object Date]" === toString.call(val);
            },
            isFile: function(val) {
                return "[object File]" === toString.call(val);
            },
            isBlob: function(val) {
                return "[object Blob]" === toString.call(val);
            },
            isFunction: isFunction,
            isStream: function(val) {
                return isObject(val) && isFunction(val.pipe);
            },
            isURLSearchParams: function(val) {
                return "undefined" != typeof URLSearchParams && val instanceof URLSearchParams;
            },
            isStandardBrowserEnv: function() {
                return ("undefined" == typeof navigator || "ReactNative" !== navigator.product) && "undefined" != typeof window && "undefined" != typeof document;
            },
            forEach: forEach,
            merge: function merge() {
                var result = {};
                function assignValue(val, key) {
                    "object" == typeof result[key] && "object" == typeof val ? result[key] = merge(result[key], val) : result[key] = val;
                }
                for (var i = 0, l = arguments.length; i < l; i++) forEach(arguments[i], assignValue);
                return result;
            },
            extend: function(a, b, thisArg) {
                return forEach(b, function(val, key) {
                    a[key] = thisArg && "function" == typeof val ? bind(val, thisArg) : val;
                }), a;
            },
            trim: function(str) {
                return str.replace(/^\s*/, "").replace(/\s*$/, "");
            }
        };
    }, function(module, exports, __webpack_require__) {
        var vec2 = __webpack_require__(6), matrix = __webpack_require__(17), v2ApplyTransform = vec2.applyTransform, mathMin = Math.min, mathMax = Math.max;
        function BoundingRect(x, y, width, height) {
            width < 0 && (x += width, width = -width), height < 0 && (y += height, height = -height), 
            this.x = x, this.y = y, this.width = width, this.height = height;
        }
        BoundingRect.prototype = {
            constructor: BoundingRect,
            union: function(other) {
                var x = mathMin(other.x, this.x), y = mathMin(other.y, this.y);
                this.width = mathMax(other.x + other.width, this.x + this.width) - x, this.height = mathMax(other.y + other.height, this.y + this.height) - y, 
                this.x = x, this.y = y;
            },
            applyTransform: function() {
                var lt = [], rb = [], lb = [], rt = [];
                return function(m) {
                    if (m) {
                        lt[0] = lb[0] = this.x, lt[1] = rt[1] = this.y, rb[0] = rt[0] = this.x + this.width, 
                        rb[1] = lb[1] = this.y + this.height, v2ApplyTransform(lt, lt, m), v2ApplyTransform(rb, rb, m), 
                        v2ApplyTransform(lb, lb, m), v2ApplyTransform(rt, rt, m), this.x = mathMin(lt[0], rb[0], lb[0], rt[0]), 
                        this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);
                        var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]), maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);
                        this.width = maxX - this.x, this.height = maxY - this.y;
                    }
                };
            }(),
            calculateTransform: function(b) {
                var a = this, sx = b.width / a.width, sy = b.height / a.height, m = matrix.create();
                return matrix.translate(m, m, [ -a.x, -a.y ]), matrix.scale(m, m, [ sx, sy ]), matrix.translate(m, m, [ b.x, b.y ]), 
                m;
            },
            intersect: function(b) {
                if (!b) return !1;
                b instanceof BoundingRect || (b = BoundingRect.create(b));
                var a = this, ax0 = a.x, ax1 = a.x + a.width, ay0 = a.y, ay1 = a.y + a.height, bx0 = b.x, bx1 = b.x + b.width, by0 = b.y, by1 = b.y + b.height;
                return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
            },
            contain: function(x, y) {
                return x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height;
            },
            clone: function() {
                return new BoundingRect(this.x, this.y, this.width, this.height);
            },
            copy: function(other) {
                this.x = other.x, this.y = other.y, this.width = other.width, this.height = other.height;
            },
            plain: function() {
                return {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };
            }
        }, BoundingRect.create = function(rect) {
            return new BoundingRect(rect.x, rect.y, rect.width, rect.height);
        };
        var _default = BoundingRect;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), Model = __webpack_require__(14), componentUtil = __webpack_require__(39), _clazz = __webpack_require__(18), enableClassManagement = _clazz.enableClassManagement, parseClassType = _clazz.parseClassType, makeInner = __webpack_require__(3).makeInner, layout = __webpack_require__(10), boxLayoutMixin = __webpack_require__(217), inner = makeInner(), ComponentModel = Model.extend({
            type: "component",
            id: "",
            name: "",
            mainType: "",
            subType: "",
            componentIndex: 0,
            defaultOption: null,
            ecModel: null,
            dependentModels: [],
            uid: null,
            layoutMode: null,
            $constructor: function(option, parentModel, ecModel, extraOpt) {
                Model.call(this, option, parentModel, ecModel, extraOpt), this.uid = componentUtil.getUID("ec_cpt_model");
            },
            init: function(option, parentModel, ecModel, extraOpt) {
                this.mergeDefaultAndTheme(option, ecModel);
            },
            mergeDefaultAndTheme: function(option, ecModel) {
                var layoutMode = this.layoutMode, inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {}, themeModel = ecModel.getTheme();
                zrUtil.merge(option, themeModel.get(this.mainType)), zrUtil.merge(option, this.getDefaultOption()), 
                layoutMode && layout.mergeLayoutParam(option, inputPositionParams, layoutMode);
            },
            mergeOption: function(option, extraOpt) {
                zrUtil.merge(this.option, option, !0);
                var layoutMode = this.layoutMode;
                layoutMode && layout.mergeLayoutParam(this.option, option, layoutMode);
            },
            optionUpdated: function(newCptOption, isInit) {},
            getDefaultOption: function() {
                var fields = inner(this);
                if (!fields.defaultOption) {
                    for (var optList = [], Class = this.constructor; Class; ) {
                        var opt = Class.prototype.defaultOption;
                        opt && optList.push(opt), Class = Class.superClass;
                    }
                    for (var defaultOption = {}, i = optList.length - 1; i >= 0; i--) defaultOption = zrUtil.merge(defaultOption, optList[i], !0);
                    fields.defaultOption = defaultOption;
                }
                return fields.defaultOption;
            },
            getReferringComponents: function(mainType) {
                return this.ecModel.queryComponents({
                    mainType: mainType,
                    index: this.get(mainType + "Index", !0),
                    id: this.get(mainType + "Id", !0)
                });
            }
        });
        enableClassManagement(ComponentModel, {
            registerWhenExtend: !0
        }), componentUtil.enableSubTypeDefaulter(ComponentModel), componentUtil.enableTopologicalTravel(ComponentModel, function(componentType) {
            var deps = [];
            zrUtil.each(ComponentModel.getClassesByMainType(componentType), function(Clazz) {
                deps = deps.concat(Clazz.prototype.dependencies || []);
            }), deps = zrUtil.map(deps, function(type) {
                return parseClassType(type).main;
            }), "dataset" !== componentType && zrUtil.indexOf(deps, "dataset") <= 0 && deps.unshift("dataset");
            return deps;
        }), zrUtil.mixin(ComponentModel, boxLayoutMixin);
        var _default = ComponentModel;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), env = __webpack_require__(7), makeInner = __webpack_require__(3).makeInner, _clazz = __webpack_require__(18), enableClassExtend = _clazz.enableClassExtend, enableClassCheck = _clazz.enableClassCheck, lineStyleMixin = __webpack_require__(201), areaStyleMixin = __webpack_require__(202), textStyleMixin = __webpack_require__(203), itemStyleMixin = __webpack_require__(216), mixin = zrUtil.mixin, inner = makeInner();
        function Model(option, parentModel, ecModel) {
            this.parentModel = parentModel, this.ecModel = ecModel, this.option = option;
        }
        function doGet(obj, pathArr, parentModel) {
            for (var i = 0; i < pathArr.length && (!pathArr[i] || null != (obj = obj && "object" == typeof obj ? obj[pathArr[i]] : null)); i++) ;
            return null == obj && parentModel && (obj = parentModel.get(pathArr)), obj;
        }
        function getParent(model, path) {
            var getParentMethod = inner(model).getParent;
            return getParentMethod ? getParentMethod.call(model, path) : model.parentModel;
        }
        Model.prototype = {
            constructor: Model,
            init: null,
            mergeOption: function(option) {
                zrUtil.merge(this.option, option, !0);
            },
            get: function(path, ignoreParent) {
                return null == path ? this.option : doGet(this.option, this.parsePath(path), !ignoreParent && getParent(this, path));
            },
            getShallow: function(key, ignoreParent) {
                var option = this.option, val = null == option ? option : option[key], parentModel = !ignoreParent && getParent(this, key);
                return null == val && parentModel && (val = parentModel.getShallow(key)), val;
            },
            getModel: function(path, parentModel) {
                var thisParentModel;
                return new Model(null == path ? this.option : doGet(this.option, path = this.parsePath(path)), parentModel = parentModel || (thisParentModel = getParent(this, path)) && thisParentModel.getModel(path), this.ecModel);
            },
            isEmpty: function() {
                return null == this.option;
            },
            restoreData: function() {},
            clone: function() {
                return new (0, this.constructor)(zrUtil.clone(this.option));
            },
            setReadOnly: function(properties) {},
            parsePath: function(path) {
                return "string" == typeof path && (path = path.split(".")), path;
            },
            customizeGetParent: function(getParentMethod) {
                inner(this).getParent = getParentMethod;
            },
            isAnimationEnabled: function() {
                if (!env.node) {
                    if (null != this.option.animation) return !!this.option.animation;
                    if (this.parentModel) return this.parentModel.isAnimationEnabled();
                }
            }
        }, enableClassExtend(Model), enableClassCheck(Model), mixin(Model, lineStyleMixin), 
        mixin(Model, areaStyleMixin), mixin(Model, textStyleMixin), mixin(Model, itemStyleMixin);
        var _default = Model;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var Eventful = __webpack_require__(23);
        exports.Dispatcher = Eventful;
        var env = __webpack_require__(7), buildTransformer = __webpack_require__(190).buildTransformer, isDomLevel2 = "undefined" != typeof window && !!window.addEventListener, MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, EVENT_SAVED_PROP = "___zrEVENTSAVED", _calcOut = [];
        function clientToLocal(el, e, out, calculate) {
            return out = out || {}, calculate || !env.canvasSupported ? calculateZrXY(el, e, out) : env.browser.firefox && null != e.layerX && e.layerX !== e.offsetX ? (out.zrX = e.layerX, 
            out.zrY = e.layerY) : null != e.offsetX ? (out.zrX = e.offsetX, out.zrY = e.offsetY) : calculateZrXY(el, e, out), 
            out;
        }
        function calculateZrXY(el, e, out) {
            if (el.getBoundingClientRect && env.domSupported) {
                var ex = e.clientX, ey = e.clientY;
                if ("CANVAS" === el.nodeName.toUpperCase()) {
                    var box = el.getBoundingClientRect();
                    return out.zrX = ex - box.left, void (out.zrY = ey - box.top);
                }
                var saved = el[EVENT_SAVED_PROP] || (el[EVENT_SAVED_PROP] = {}), transformer = function(markers, saved) {
                    for (var transformer = saved.transformer, oldSrcCoords = saved.srcCoords, useOld = !0, srcCoords = [], destCoords = [], i = 0; i < 4; i++) {
                        var rect = markers[i].getBoundingClientRect(), ii = 2 * i, x = rect.left, y = rect.top;
                        srcCoords.push(x, y), useOld &= oldSrcCoords && x === oldSrcCoords[ii] && y === oldSrcCoords[ii + 1], 
                        destCoords.push(markers[i].offsetLeft, markers[i].offsetTop);
                    }
                    return useOld ? transformer : (saved.srcCoords = srcCoords, saved.transformer = buildTransformer(srcCoords, destCoords));
                }(function(el, saved) {
                    var markers = saved.markers;
                    if (markers) return markers;
                    markers = saved.markers = [];
                    for (var propLR = [ "left", "right" ], propTB = [ "top", "bottom" ], i = 0; i < 4; i++) {
                        var marker = document.createElement("div"), stl = marker.style, idxLR = i % 2, idxTB = (i >> 1) % 2;
                        stl.cssText = [ "position:absolute", "visibility: hidden", "padding: 0", "margin: 0", "border-width: 0", "width:0", "height:0", propLR[idxLR] + ":0", propTB[idxTB] + ":0", propLR[1 - idxLR] + ":auto", propTB[1 - idxTB] + ":auto", "" ].join("!important;"), 
                        el.appendChild(marker), markers.push(marker);
                    }
                    return markers;
                }(el, saved), saved);
                if (transformer) return transformer(_calcOut, ex, ey), out.zrX = _calcOut[0], void (out.zrY = _calcOut[1]);
            }
            out.zrX = out.zrY = 0;
        }
        var stop = isDomLevel2 ? function(e) {
            e.preventDefault(), e.stopPropagation(), e.cancelBubble = !0;
        } : function(e) {
            e.returnValue = !1, e.cancelBubble = !0;
        };
        exports.clientToLocal = clientToLocal, exports.normalizeEvent = function(el, e, calculate) {
            if (null != (e = e || window.event).zrX) return e;
            var eventType = e.type;
            if (eventType && eventType.indexOf("touch") >= 0) {
                var touch = "touchend" !== eventType ? e.targetTouches[0] : e.changedTouches[0];
                touch && clientToLocal(el, touch, e, calculate);
            } else clientToLocal(el, e, e, calculate), e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
            var button = e.button;
            return null == e.which && void 0 !== button && MOUSE_EVENT_REG.test(e.type) && (e.which = 1 & button ? 1 : 2 & button ? 3 : 4 & button ? 2 : 0), 
            e;
        }, exports.addEventListener = function(el, name, handler) {
            isDomLevel2 ? el.addEventListener(name, handler) : el.attachEvent("on" + name, handler);
        }, exports.removeEventListener = function(el, name, handler) {
            isDomLevel2 ? el.removeEventListener(name, handler) : el.detachEvent("on" + name, handler);
        }, exports.stop = stop, exports.isMiddleOrRightButtonOnMouseUpDown = function(e) {
            return 2 === e.which || 3 === e.which;
        }, exports.notLeftMouse = function(e) {
            return e.which > 1;
        };
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), graphic = __webpack_require__(2), BoundingRect = __webpack_require__(12), calculateTextPosition = __webpack_require__(21).calculateTextPosition, Triangle = graphic.extendShape({
            type: "triangle",
            shape: {
                cx: 0,
                cy: 0,
                width: 0,
                height: 0
            },
            buildPath: function(path, shape) {
                var cx = shape.cx, cy = shape.cy, width = shape.width / 2, height = shape.height / 2;
                path.moveTo(cx, cy - height), path.lineTo(cx + width, cy + height), path.lineTo(cx - width, cy + height), 
                path.closePath();
            }
        }), Diamond = graphic.extendShape({
            type: "diamond",
            shape: {
                cx: 0,
                cy: 0,
                width: 0,
                height: 0
            },
            buildPath: function(path, shape) {
                var cx = shape.cx, cy = shape.cy, width = shape.width / 2, height = shape.height / 2;
                path.moveTo(cx, cy - height), path.lineTo(cx + width, cy), path.lineTo(cx, cy + height), 
                path.lineTo(cx - width, cy), path.closePath();
            }
        }), Pin = graphic.extendShape({
            type: "pin",
            shape: {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            },
            buildPath: function(path, shape) {
                var x = shape.x, y = shape.y, w = shape.width / 5 * 3, h = Math.max(w, shape.height), r = w / 2, dy = r * r / (h - r), cy = y - h + r + dy, angle = Math.asin(dy / r), dx = Math.cos(angle) * r, tanX = Math.sin(angle), tanY = Math.cos(angle), cpLen = .6 * r, cpLen2 = .7 * r;
                path.moveTo(x - dx, cy + dy), path.arc(x, cy, r, Math.PI - angle, 2 * Math.PI + angle), 
                path.bezierCurveTo(x + dx - tanX * cpLen, cy + dy + tanY * cpLen, x, y - cpLen2, x, y), 
                path.bezierCurveTo(x, y - cpLen2, x - dx + tanX * cpLen, cy + dy + tanY * cpLen, x - dx, cy + dy), 
                path.closePath();
            }
        }), Arrow = graphic.extendShape({
            type: "arrow",
            shape: {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            },
            buildPath: function(ctx, shape) {
                var height = shape.height, width = shape.width, x = shape.x, y = shape.y, dx = width / 3 * 2;
                ctx.moveTo(x, y), ctx.lineTo(x + dx, y + height), ctx.lineTo(x, y + height / 4 * 3), 
                ctx.lineTo(x - dx, y + height), ctx.lineTo(x, y), ctx.closePath();
            }
        }), symbolCtors = {
            line: graphic.Line,
            rect: graphic.Rect,
            roundRect: graphic.Rect,
            square: graphic.Rect,
            circle: graphic.Circle,
            diamond: Diamond,
            pin: Pin,
            arrow: Arrow,
            triangle: Triangle
        }, symbolShapeMakers = {
            line: function(x, y, w, h, shape) {
                shape.x1 = x, shape.y1 = y + h / 2, shape.x2 = x + w, shape.y2 = y + h / 2;
            },
            rect: function(x, y, w, h, shape) {
                shape.x = x, shape.y = y, shape.width = w, shape.height = h;
            },
            roundRect: function(x, y, w, h, shape) {
                shape.x = x, shape.y = y, shape.width = w, shape.height = h, shape.r = Math.min(w, h) / 4;
            },
            square: function(x, y, w, h, shape) {
                var size = Math.min(w, h);
                shape.x = x, shape.y = y, shape.width = size, shape.height = size;
            },
            circle: function(x, y, w, h, shape) {
                shape.cx = x + w / 2, shape.cy = y + h / 2, shape.r = Math.min(w, h) / 2;
            },
            diamond: function(x, y, w, h, shape) {
                shape.cx = x + w / 2, shape.cy = y + h / 2, shape.width = w, shape.height = h;
            },
            pin: function(x, y, w, h, shape) {
                shape.x = x + w / 2, shape.y = y + h / 2, shape.width = w, shape.height = h;
            },
            arrow: function(x, y, w, h, shape) {
                shape.x = x + w / 2, shape.y = y + h / 2, shape.width = w, shape.height = h;
            },
            triangle: function(x, y, w, h, shape) {
                shape.cx = x + w / 2, shape.cy = y + h / 2, shape.width = w, shape.height = h;
            }
        }, symbolBuildProxies = {};
        zrUtil.each(symbolCtors, function(Ctor, name) {
            symbolBuildProxies[name] = new Ctor();
        });
        var SymbolClz = graphic.extendShape({
            type: "symbol",
            shape: {
                symbolType: "",
                x: 0,
                y: 0,
                width: 0,
                height: 0
            },
            calculateTextPosition: function(out, style, rect) {
                var res = calculateTextPosition(out, style, rect), shape = this.shape;
                return shape && "pin" === shape.symbolType && "inside" === style.textPosition && (res.y = rect.y + .4 * rect.height), 
                res;
            },
            buildPath: function(ctx, shape, inBundle) {
                var symbolType = shape.symbolType;
                if ("none" !== symbolType) {
                    var proxySymbol = symbolBuildProxies[symbolType];
                    proxySymbol || (proxySymbol = symbolBuildProxies[symbolType = "rect"]), symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape), 
                    proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);
                }
            }
        });
        function symbolPathSetColor(color, innerColor) {
            if ("image" !== this.type) {
                var symbolStyle = this.style, symbolShape = this.shape;
                symbolShape && "line" === symbolShape.symbolType ? symbolStyle.stroke = color : this.__isEmptyBrush ? (symbolStyle.stroke = color, 
                symbolStyle.fill = innerColor || "#fff") : (symbolStyle.fill && (symbolStyle.fill = color), 
                symbolStyle.stroke && (symbolStyle.stroke = color)), this.dirty(!1);
            }
        }
        exports.createSymbol = function(symbolType, x, y, w, h, color, keepAspect) {
            var symbolPath, isEmpty = 0 === symbolType.indexOf("empty");
            return isEmpty && (symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6)), 
            (symbolPath = 0 === symbolType.indexOf("image://") ? graphic.makeImage(symbolType.slice(8), new BoundingRect(x, y, w, h), keepAspect ? "center" : "cover") : 0 === symbolType.indexOf("path://") ? graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h), keepAspect ? "center" : "cover") : new SymbolClz({
                shape: {
                    symbolType: symbolType,
                    x: x,
                    y: y,
                    width: w,
                    height: h
                }
            })).__isEmptyBrush = isEmpty, symbolPath.setColor = symbolPathSetColor, symbolPath.setColor(color), 
            symbolPath;
        };
    }, function(module, exports) {
        var ArrayCtor = "undefined" == typeof Float32Array ? Array : Float32Array;
        function create() {
            var out = new ArrayCtor(6);
            return identity(out), out;
        }
        function identity(out) {
            return out[0] = 1, out[1] = 0, out[2] = 0, out[3] = 1, out[4] = 0, out[5] = 0, out;
        }
        function copy(out, m) {
            return out[0] = m[0], out[1] = m[1], out[2] = m[2], out[3] = m[3], out[4] = m[4], 
            out[5] = m[5], out;
        }
        exports.create = create, exports.identity = identity, exports.copy = copy, exports.mul = function(out, m1, m2) {
            var out0 = m1[0] * m2[0] + m1[2] * m2[1], out1 = m1[1] * m2[0] + m1[3] * m2[1], out2 = m1[0] * m2[2] + m1[2] * m2[3], out3 = m1[1] * m2[2] + m1[3] * m2[3], out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4], out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
            return out[0] = out0, out[1] = out1, out[2] = out2, out[3] = out3, out[4] = out4, 
            out[5] = out5, out;
        }, exports.translate = function(out, a, v) {
            return out[0] = a[0], out[1] = a[1], out[2] = a[2], out[3] = a[3], out[4] = a[4] + v[0], 
            out[5] = a[5] + v[1], out;
        }, exports.rotate = function(out, a, rad) {
            var aa = a[0], ac = a[2], atx = a[4], ab = a[1], ad = a[3], aty = a[5], st = Math.sin(rad), ct = Math.cos(rad);
            return out[0] = aa * ct + ab * st, out[1] = -aa * st + ab * ct, out[2] = ac * ct + ad * st, 
            out[3] = -ac * st + ct * ad, out[4] = ct * atx + st * aty, out[5] = ct * aty - st * atx, 
            out;
        }, exports.scale = function(out, a, v) {
            var vx = v[0], vy = v[1];
            return out[0] = a[0] * vx, out[1] = a[1] * vy, out[2] = a[2] * vx, out[3] = a[3] * vy, 
            out[4] = a[4] * vx, out[5] = a[5] * vy, out;
        }, exports.invert = function(out, a) {
            var aa = a[0], ac = a[2], atx = a[4], ab = a[1], ad = a[3], aty = a[5], det = aa * ad - ab * ac;
            return det ? (det = 1 / det, out[0] = ad * det, out[1] = -ab * det, out[2] = -ac * det, 
            out[3] = aa * det, out[4] = (ac * aty - ad * atx) * det, out[5] = (ab * atx - aa * aty) * det, 
            out) : null;
        }, exports.clone = function(a) {
            var b = create();
            return copy(b, a), b;
        };
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(5).__DEV__;
        var zrUtil = __webpack_require__(0), TYPE_DELIMITER = ".", IS_CONTAINER = "___EC__COMPONENT__CONTAINER___";
        function parseClassType(componentType) {
            var ret = {
                main: "",
                sub: ""
            };
            return componentType && (componentType = componentType.split(TYPE_DELIMITER), ret.main = componentType[0] || "", 
            ret.sub = componentType[1] || ""), ret;
        }
        var classBase = 0;
        function superCall(context, methodName) {
            var args = zrUtil.slice(arguments, 2);
            return this.superClass.prototype[methodName].apply(context, args);
        }
        function superApply(context, methodName, args) {
            return this.superClass.prototype[methodName].apply(context, args);
        }
        exports.parseClassType = parseClassType, exports.enableClassExtend = function(RootClass, mandatoryMethods) {
            RootClass.$constructor = RootClass, RootClass.extend = function(proto) {
                var superClass = this, ExtendedClass = function() {
                    proto.$constructor ? proto.$constructor.apply(this, arguments) : superClass.apply(this, arguments);
                };
                return zrUtil.extend(ExtendedClass.prototype, proto), ExtendedClass.extend = this.extend, 
                ExtendedClass.superCall = superCall, ExtendedClass.superApply = superApply, zrUtil.inherits(ExtendedClass, this), 
                ExtendedClass.superClass = superClass, ExtendedClass;
            };
        }, exports.enableClassCheck = function(Clz) {
            var classAttr = [ "__\0is_clz", classBase++, Math.random().toFixed(3) ].join("_");
            Clz.prototype[classAttr] = !0, Clz.isInstance = function(obj) {
                return !(!obj || !obj[classAttr]);
            };
        }, exports.enableClassManagement = function(entity, options) {
            options = options || {};
            var storage = {};
            if (entity.registerClass = function(Clazz, componentType) {
                return componentType && (function(componentType) {
                    zrUtil.assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), 'componentType "' + componentType + '" illegal');
                }(componentType), (componentType = parseClassType(componentType)).sub ? componentType.sub !== IS_CONTAINER && ((function(componentType) {
                    var container = storage[componentType.main];
                    return container && container[IS_CONTAINER] || ((container = storage[componentType.main] = {})[IS_CONTAINER] = !0), 
                    container;
                }(componentType))[componentType.sub] = Clazz) : storage[componentType.main] = Clazz), 
                Clazz;
            }, entity.getClass = function(componentMainType, subType, throwWhenNotFound) {
                var Clazz = storage[componentMainType];
                if (Clazz && Clazz[IS_CONTAINER] && (Clazz = subType ? Clazz[subType] : null), throwWhenNotFound && !Clazz) throw new Error(subType ? "Component " + componentMainType + "." + (subType || "") + " not exists. Load it first." : componentMainType + ".type should be specified.");
                return Clazz;
            }, entity.getClassesByMainType = function(componentType) {
                componentType = parseClassType(componentType);
                var result = [], obj = storage[componentType.main];
                return obj && obj[IS_CONTAINER] ? zrUtil.each(obj, function(o, type) {
                    type !== IS_CONTAINER && result.push(o);
                }) : result.push(obj), result;
            }, entity.hasClass = function(componentType) {
                return componentType = parseClassType(componentType), !!storage[componentType.main];
            }, entity.getAllClassMainTypes = function() {
                var types = [];
                return zrUtil.each(storage, function(obj, type) {
                    types.push(type);
                }), types;
            }, entity.hasSubTypes = function(componentType) {
                componentType = parseClassType(componentType);
                var obj = storage[componentType.main];
                return obj && obj[IS_CONTAINER];
            }, entity.parseClassType = parseClassType, options.registerWhenExtend) {
                var originalExtend = entity.extend;
                originalExtend && (entity.extend = function(proto) {
                    var ExtendedClass = originalExtend.call(this, proto);
                    return entity.registerClass(ExtendedClass, proto.type);
                });
            }
            return entity;
        }, exports.setReadOnly = function(obj, properties) {};
    }, function(module, exports, __webpack_require__) {
        var _util = __webpack_require__(0), each = _util.each, isString = _util.isString;
        function isDimensionStacked(data, stackedDim) {
            return !!stackedDim && stackedDim === data.getCalculationInfo("stackedDimension");
        }
        exports.enableDataStack = function(seriesModel, dimensionInfoList, opt) {
            var stackedByDimInfo, stackedDimInfo, stackResultDimension, stackedOverDimension, byIndex = (opt = opt || {}).byIndex, stackedCoordDimension = opt.stackedCoordDimension, mayStack = !(!seriesModel || !seriesModel.get("stack"));
            if (each(dimensionInfoList, function(dimensionInfo, index) {
                isString(dimensionInfo) && (dimensionInfoList[index] = dimensionInfo = {
                    name: dimensionInfo
                }), mayStack && !dimensionInfo.isExtraCoord && (byIndex || stackedByDimInfo || !dimensionInfo.ordinalMeta || (stackedByDimInfo = dimensionInfo), 
                stackedDimInfo || "ordinal" === dimensionInfo.type || "time" === dimensionInfo.type || stackedCoordDimension && stackedCoordDimension !== dimensionInfo.coordDim || (stackedDimInfo = dimensionInfo));
            }), !stackedDimInfo || byIndex || stackedByDimInfo || (byIndex = !0), stackedDimInfo) {
                stackResultDimension = "__\0ecstackresult", stackedOverDimension = "__\0ecstackedover", 
                stackedByDimInfo && (stackedByDimInfo.createInvertedIndices = !0);
                var stackedDimCoordDim = stackedDimInfo.coordDim, stackedDimType = stackedDimInfo.type, stackedDimCoordIndex = 0;
                each(dimensionInfoList, function(dimensionInfo) {
                    dimensionInfo.coordDim === stackedDimCoordDim && stackedDimCoordIndex++;
                }), dimensionInfoList.push({
                    name: stackResultDimension,
                    coordDim: stackedDimCoordDim,
                    coordDimIndex: stackedDimCoordIndex,
                    type: stackedDimType,
                    isExtraCoord: !0,
                    isCalculationCoord: !0
                }), stackedDimCoordIndex++, dimensionInfoList.push({
                    name: stackedOverDimension,
                    coordDim: stackedOverDimension,
                    coordDimIndex: stackedDimCoordIndex,
                    type: stackedDimType,
                    isExtraCoord: !0,
                    isCalculationCoord: !0
                });
            }
            return {
                stackedDimension: stackedDimInfo && stackedDimInfo.name,
                stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,
                isStackedByIndex: byIndex,
                stackedOverDimension: stackedOverDimension,
                stackResultDimension: stackResultDimension
            };
        }, exports.isDimensionStacked = isDimensionStacked, exports.getStackedDimension = function(data, targetDim) {
            return isDimensionStacked(data, targetDim) ? data.getCalculationInfo("stackResultDimension") : targetDim;
        };
    }, function(module, exports, __webpack_require__) {
        var kCSSColorTable = {
            transparent: [ 0, 0, 0, 0 ],
            aliceblue: [ 240, 248, 255, 1 ],
            antiquewhite: [ 250, 235, 215, 1 ],
            aqua: [ 0, 255, 255, 1 ],
            aquamarine: [ 127, 255, 212, 1 ],
            azure: [ 240, 255, 255, 1 ],
            beige: [ 245, 245, 220, 1 ],
            bisque: [ 255, 228, 196, 1 ],
            black: [ 0, 0, 0, 1 ],
            blanchedalmond: [ 255, 235, 205, 1 ],
            blue: [ 0, 0, 255, 1 ],
            blueviolet: [ 138, 43, 226, 1 ],
            brown: [ 165, 42, 42, 1 ],
            burlywood: [ 222, 184, 135, 1 ],
            cadetblue: [ 95, 158, 160, 1 ],
            chartreuse: [ 127, 255, 0, 1 ],
            chocolate: [ 210, 105, 30, 1 ],
            coral: [ 255, 127, 80, 1 ],
            cornflowerblue: [ 100, 149, 237, 1 ],
            cornsilk: [ 255, 248, 220, 1 ],
            crimson: [ 220, 20, 60, 1 ],
            cyan: [ 0, 255, 255, 1 ],
            darkblue: [ 0, 0, 139, 1 ],
            darkcyan: [ 0, 139, 139, 1 ],
            darkgoldenrod: [ 184, 134, 11, 1 ],
            darkgray: [ 169, 169, 169, 1 ],
            darkgreen: [ 0, 100, 0, 1 ],
            darkgrey: [ 169, 169, 169, 1 ],
            darkkhaki: [ 189, 183, 107, 1 ],
            darkmagenta: [ 139, 0, 139, 1 ],
            darkolivegreen: [ 85, 107, 47, 1 ],
            darkorange: [ 255, 140, 0, 1 ],
            darkorchid: [ 153, 50, 204, 1 ],
            darkred: [ 139, 0, 0, 1 ],
            darksalmon: [ 233, 150, 122, 1 ],
            darkseagreen: [ 143, 188, 143, 1 ],
            darkslateblue: [ 72, 61, 139, 1 ],
            darkslategray: [ 47, 79, 79, 1 ],
            darkslategrey: [ 47, 79, 79, 1 ],
            darkturquoise: [ 0, 206, 209, 1 ],
            darkviolet: [ 148, 0, 211, 1 ],
            deeppink: [ 255, 20, 147, 1 ],
            deepskyblue: [ 0, 191, 255, 1 ],
            dimgray: [ 105, 105, 105, 1 ],
            dimgrey: [ 105, 105, 105, 1 ],
            dodgerblue: [ 30, 144, 255, 1 ],
            firebrick: [ 178, 34, 34, 1 ],
            floralwhite: [ 255, 250, 240, 1 ],
            forestgreen: [ 34, 139, 34, 1 ],
            fuchsia: [ 255, 0, 255, 1 ],
            gainsboro: [ 220, 220, 220, 1 ],
            ghostwhite: [ 248, 248, 255, 1 ],
            gold: [ 255, 215, 0, 1 ],
            goldenrod: [ 218, 165, 32, 1 ],
            gray: [ 128, 128, 128, 1 ],
            green: [ 0, 128, 0, 1 ],
            greenyellow: [ 173, 255, 47, 1 ],
            grey: [ 128, 128, 128, 1 ],
            honeydew: [ 240, 255, 240, 1 ],
            hotpink: [ 255, 105, 180, 1 ],
            indianred: [ 205, 92, 92, 1 ],
            indigo: [ 75, 0, 130, 1 ],
            ivory: [ 255, 255, 240, 1 ],
            khaki: [ 240, 230, 140, 1 ],
            lavender: [ 230, 230, 250, 1 ],
            lavenderblush: [ 255, 240, 245, 1 ],
            lawngreen: [ 124, 252, 0, 1 ],
            lemonchiffon: [ 255, 250, 205, 1 ],
            lightblue: [ 173, 216, 230, 1 ],
            lightcoral: [ 240, 128, 128, 1 ],
            lightcyan: [ 224, 255, 255, 1 ],
            lightgoldenrodyellow: [ 250, 250, 210, 1 ],
            lightgray: [ 211, 211, 211, 1 ],
            lightgreen: [ 144, 238, 144, 1 ],
            lightgrey: [ 211, 211, 211, 1 ],
            lightpink: [ 255, 182, 193, 1 ],
            lightsalmon: [ 255, 160, 122, 1 ],
            lightseagreen: [ 32, 178, 170, 1 ],
            lightskyblue: [ 135, 206, 250, 1 ],
            lightslategray: [ 119, 136, 153, 1 ],
            lightslategrey: [ 119, 136, 153, 1 ],
            lightsteelblue: [ 176, 196, 222, 1 ],
            lightyellow: [ 255, 255, 224, 1 ],
            lime: [ 0, 255, 0, 1 ],
            limegreen: [ 50, 205, 50, 1 ],
            linen: [ 250, 240, 230, 1 ],
            magenta: [ 255, 0, 255, 1 ],
            maroon: [ 128, 0, 0, 1 ],
            mediumaquamarine: [ 102, 205, 170, 1 ],
            mediumblue: [ 0, 0, 205, 1 ],
            mediumorchid: [ 186, 85, 211, 1 ],
            mediumpurple: [ 147, 112, 219, 1 ],
            mediumseagreen: [ 60, 179, 113, 1 ],
            mediumslateblue: [ 123, 104, 238, 1 ],
            mediumspringgreen: [ 0, 250, 154, 1 ],
            mediumturquoise: [ 72, 209, 204, 1 ],
            mediumvioletred: [ 199, 21, 133, 1 ],
            midnightblue: [ 25, 25, 112, 1 ],
            mintcream: [ 245, 255, 250, 1 ],
            mistyrose: [ 255, 228, 225, 1 ],
            moccasin: [ 255, 228, 181, 1 ],
            navajowhite: [ 255, 222, 173, 1 ],
            navy: [ 0, 0, 128, 1 ],
            oldlace: [ 253, 245, 230, 1 ],
            olive: [ 128, 128, 0, 1 ],
            olivedrab: [ 107, 142, 35, 1 ],
            orange: [ 255, 165, 0, 1 ],
            orangered: [ 255, 69, 0, 1 ],
            orchid: [ 218, 112, 214, 1 ],
            palegoldenrod: [ 238, 232, 170, 1 ],
            palegreen: [ 152, 251, 152, 1 ],
            paleturquoise: [ 175, 238, 238, 1 ],
            palevioletred: [ 219, 112, 147, 1 ],
            papayawhip: [ 255, 239, 213, 1 ],
            peachpuff: [ 255, 218, 185, 1 ],
            peru: [ 205, 133, 63, 1 ],
            pink: [ 255, 192, 203, 1 ],
            plum: [ 221, 160, 221, 1 ],
            powderblue: [ 176, 224, 230, 1 ],
            purple: [ 128, 0, 128, 1 ],
            red: [ 255, 0, 0, 1 ],
            rosybrown: [ 188, 143, 143, 1 ],
            royalblue: [ 65, 105, 225, 1 ],
            saddlebrown: [ 139, 69, 19, 1 ],
            salmon: [ 250, 128, 114, 1 ],
            sandybrown: [ 244, 164, 96, 1 ],
            seagreen: [ 46, 139, 87, 1 ],
            seashell: [ 255, 245, 238, 1 ],
            sienna: [ 160, 82, 45, 1 ],
            silver: [ 192, 192, 192, 1 ],
            skyblue: [ 135, 206, 235, 1 ],
            slateblue: [ 106, 90, 205, 1 ],
            slategray: [ 112, 128, 144, 1 ],
            slategrey: [ 112, 128, 144, 1 ],
            snow: [ 255, 250, 250, 1 ],
            springgreen: [ 0, 255, 127, 1 ],
            steelblue: [ 70, 130, 180, 1 ],
            tan: [ 210, 180, 140, 1 ],
            teal: [ 0, 128, 128, 1 ],
            thistle: [ 216, 191, 216, 1 ],
            tomato: [ 255, 99, 71, 1 ],
            turquoise: [ 64, 224, 208, 1 ],
            violet: [ 238, 130, 238, 1 ],
            wheat: [ 245, 222, 179, 1 ],
            white: [ 255, 255, 255, 1 ],
            whitesmoke: [ 245, 245, 245, 1 ],
            yellow: [ 255, 255, 0, 1 ],
            yellowgreen: [ 154, 205, 50, 1 ]
        };
        function clampCssByte(i) {
            return (i = Math.round(i)) < 0 ? 0 : i > 255 ? 255 : i;
        }
        function clampCssFloat(f) {
            return f < 0 ? 0 : f > 1 ? 1 : f;
        }
        function parseCssInt(str) {
            return str.length && "%" === str.charAt(str.length - 1) ? clampCssByte(parseFloat(str) / 100 * 255) : clampCssByte(parseInt(str, 10));
        }
        function parseCssFloat(str) {
            return str.length && "%" === str.charAt(str.length - 1) ? clampCssFloat(parseFloat(str) / 100) : clampCssFloat(parseFloat(str));
        }
        function cssHueToRgb(m1, m2, h) {
            return h < 0 ? h += 1 : h > 1 && (h -= 1), 6 * h < 1 ? m1 + (m2 - m1) * h * 6 : 2 * h < 1 ? m2 : 3 * h < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1;
        }
        function lerpNumber(a, b, p) {
            return a + (b - a) * p;
        }
        function setRgba(out, r, g, b, a) {
            return out[0] = r, out[1] = g, out[2] = b, out[3] = a, out;
        }
        function copyRgba(out, a) {
            return out[0] = a[0], out[1] = a[1], out[2] = a[2], out[3] = a[3], out;
        }
        var colorCache = new (__webpack_require__(91))(20), lastRemovedArr = null;
        function putToCache(colorStr, rgbaArr) {
            lastRemovedArr && copyRgba(lastRemovedArr, rgbaArr), lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());
        }
        function parse(colorStr, rgbaArr) {
            if (colorStr) {
                rgbaArr = rgbaArr || [];
                var cached = colorCache.get(colorStr);
                if (cached) return copyRgba(rgbaArr, cached);
                var iv, str = (colorStr += "").replace(/ /g, "").toLowerCase();
                if (str in kCSSColorTable) return copyRgba(rgbaArr, kCSSColorTable[str]), putToCache(colorStr, rgbaArr), 
                rgbaArr;
                if ("#" === str.charAt(0)) return 4 === str.length ? (iv = parseInt(str.substr(1), 16)) >= 0 && iv <= 4095 ? (setRgba(rgbaArr, (3840 & iv) >> 4 | (3840 & iv) >> 8, 240 & iv | (240 & iv) >> 4, 15 & iv | (15 & iv) << 4, 1), 
                putToCache(colorStr, rgbaArr), rgbaArr) : void setRgba(rgbaArr, 0, 0, 0, 1) : 7 === str.length ? (iv = parseInt(str.substr(1), 16)) >= 0 && iv <= 16777215 ? (setRgba(rgbaArr, (16711680 & iv) >> 16, (65280 & iv) >> 8, 255 & iv, 1), 
                putToCache(colorStr, rgbaArr), rgbaArr) : void setRgba(rgbaArr, 0, 0, 0, 1) : void 0;
                var op = str.indexOf("("), ep = str.indexOf(")");
                if (-1 !== op && ep + 1 === str.length) {
                    var fname = str.substr(0, op), params = str.substr(op + 1, ep - (op + 1)).split(","), alpha = 1;
                    switch (fname) {
                      case "rgba":
                        if (4 !== params.length) return void setRgba(rgbaArr, 0, 0, 0, 1);
                        alpha = parseCssFloat(params.pop());

                      case "rgb":
                        return 3 !== params.length ? void setRgba(rgbaArr, 0, 0, 0, 1) : (setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha), 
                        putToCache(colorStr, rgbaArr), rgbaArr);

                      case "hsla":
                        return 4 !== params.length ? void setRgba(rgbaArr, 0, 0, 0, 1) : (params[3] = parseCssFloat(params[3]), 
                        hsla2rgba(params, rgbaArr), putToCache(colorStr, rgbaArr), rgbaArr);

                      case "hsl":
                        return 3 !== params.length ? void setRgba(rgbaArr, 0, 0, 0, 1) : (hsla2rgba(params, rgbaArr), 
                        putToCache(colorStr, rgbaArr), rgbaArr);

                      default:
                        return;
                    }
                }
                setRgba(rgbaArr, 0, 0, 0, 1);
            }
        }
        function hsla2rgba(hsla, rgba) {
            var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360, s = parseCssFloat(hsla[1]), l = parseCssFloat(hsla[2]), m2 = l <= .5 ? l * (s + 1) : l + s - l * s, m1 = 2 * l - m2;
            return setRgba(rgba = rgba || [], clampCssByte(255 * cssHueToRgb(m1, m2, h + 1 / 3)), clampCssByte(255 * cssHueToRgb(m1, m2, h)), clampCssByte(255 * cssHueToRgb(m1, m2, h - 1 / 3)), 1), 
            4 === hsla.length && (rgba[3] = hsla[3]), rgba;
        }
        function fastLerp(normalizedValue, colors, out) {
            if (colors && colors.length && normalizedValue >= 0 && normalizedValue <= 1) {
                out = out || [];
                var value = normalizedValue * (colors.length - 1), leftIndex = Math.floor(value), rightIndex = Math.ceil(value), leftColor = colors[leftIndex], rightColor = colors[rightIndex], dv = value - leftIndex;
                return out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), 
                out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv)), 
                out;
            }
        }
        var fastMapToColor = fastLerp;
        function lerp(normalizedValue, colors, fullOutput) {
            if (colors && colors.length && normalizedValue >= 0 && normalizedValue <= 1) {
                var value = normalizedValue * (colors.length - 1), leftIndex = Math.floor(value), rightIndex = Math.ceil(value), leftColor = parse(colors[leftIndex]), rightColor = parse(colors[rightIndex]), dv = value - leftIndex, color = stringify([ clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv)) ], "rgba");
                return fullOutput ? {
                    color: color,
                    leftIndex: leftIndex,
                    rightIndex: rightIndex,
                    value: value
                } : color;
            }
        }
        var mapToColor = lerp;
        function stringify(arrColor, type) {
            if (arrColor && arrColor.length) {
                var colorStr = arrColor[0] + "," + arrColor[1] + "," + arrColor[2];
                return "rgba" !== type && "hsva" !== type && "hsla" !== type || (colorStr += "," + arrColor[3]), 
                type + "(" + colorStr + ")";
            }
        }
        exports.parse = parse, exports.lift = function(color, level) {
            var colorArr = parse(color);
            if (colorArr) {
                for (var i = 0; i < 3; i++) colorArr[i] = level < 0 ? colorArr[i] * (1 - level) | 0 : (255 - colorArr[i]) * level + colorArr[i] | 0, 
                colorArr[i] > 255 ? colorArr[i] = 255 : color[i] < 0 && (colorArr[i] = 0);
                return stringify(colorArr, 4 === colorArr.length ? "rgba" : "rgb");
            }
        }, exports.toHex = function(color) {
            var colorArr = parse(color);
            if (colorArr) return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);
        }, exports.fastLerp = fastLerp, exports.fastMapToColor = fastMapToColor, exports.lerp = lerp, 
        exports.mapToColor = mapToColor, exports.modifyHSL = function(color, h, s, l) {
            if (color = parse(color)) return color = function(rgba) {
                if (rgba) {
                    var H, S, R = rgba[0] / 255, G = rgba[1] / 255, B = rgba[2] / 255, vMin = Math.min(R, G, B), vMax = Math.max(R, G, B), delta = vMax - vMin, L = (vMax + vMin) / 2;
                    if (0 === delta) H = 0, S = 0; else {
                        S = L < .5 ? delta / (vMax + vMin) : delta / (2 - vMax - vMin);
                        var deltaR = ((vMax - R) / 6 + delta / 2) / delta, deltaG = ((vMax - G) / 6 + delta / 2) / delta, deltaB = ((vMax - B) / 6 + delta / 2) / delta;
                        R === vMax ? H = deltaB - deltaG : G === vMax ? H = 1 / 3 + deltaR - deltaB : B === vMax && (H = 2 / 3 + deltaG - deltaR), 
                        H < 0 && (H += 1), H > 1 && (H -= 1);
                    }
                    var hsla = [ 360 * H, S, L ];
                    return null != rgba[3] && hsla.push(rgba[3]), hsla;
                }
            }(color), null != h && (color[0] = function(i) {
                return (i = Math.round(i)) < 0 ? 0 : i > 360 ? 360 : i;
            }(h)), null != s && (color[1] = parseCssFloat(s)), null != l && (color[2] = parseCssFloat(l)), 
            stringify(hsla2rgba(color), "rgba");
        }, exports.modifyAlpha = function(color, alpha) {
            if ((color = parse(color)) && null != alpha) return color[3] = clampCssFloat(alpha), 
            stringify(color, "rgba");
        }, exports.stringify = stringify;
    }, function(module, exports, __webpack_require__) {
        var BoundingRect = __webpack_require__(12), imageHelper = __webpack_require__(56), _util = __webpack_require__(0), getContext = _util.getContext, extend = _util.extend, retrieve2 = _util.retrieve2, retrieve3 = _util.retrieve3, trim = _util.trim, textWidthCache = {}, textWidthCacheCounter = 0, TEXT_CACHE_MAX = 5e3, STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g, DEFAULT_FONT = "12px sans-serif", methods = {};
        function getWidth(text, font) {
            var key = text + ":" + (font = font || DEFAULT_FONT);
            if (textWidthCache[key]) return textWidthCache[key];
            for (var textLines = (text + "").split("\n"), width = 0, i = 0, l = textLines.length; i < l; i++) width = Math.max(measureText(textLines[i], font).width, width);
            return textWidthCacheCounter > TEXT_CACHE_MAX && (textWidthCacheCounter = 0, textWidthCache = {}), 
            textWidthCacheCounter++, textWidthCache[key] = width, width;
        }
        function adjustTextX(x, width, textAlign) {
            return "right" === textAlign ? x -= width : "center" === textAlign && (x -= width / 2), 
            x;
        }
        function adjustTextY(y, height, textVerticalAlign) {
            return "middle" === textVerticalAlign ? y -= height / 2 : "bottom" === textVerticalAlign && (y -= height), 
            y;
        }
        function calculateTextPosition(out, style, rect) {
            var textPosition = style.textPosition, distance = style.textDistance, x = rect.x, y = rect.y, height = rect.height, width = rect.width, halfHeight = height / 2, textAlign = "left", textVerticalAlign = "top";
            switch (textPosition) {
              case "left":
                x -= distance, y += halfHeight, textAlign = "right", textVerticalAlign = "middle";
                break;

              case "right":
                x += distance + width, y += halfHeight, textVerticalAlign = "middle";
                break;

              case "top":
                x += width / 2, y -= distance, textAlign = "center", textVerticalAlign = "bottom";
                break;

              case "bottom":
                x += width / 2, y += height + distance, textAlign = "center";
                break;

              case "inside":
                x += width / 2, y += halfHeight, textAlign = "center", textVerticalAlign = "middle";
                break;

              case "insideLeft":
                x += distance, y += halfHeight, textVerticalAlign = "middle";
                break;

              case "insideRight":
                x += width - distance, y += halfHeight, textAlign = "right", textVerticalAlign = "middle";
                break;

              case "insideTop":
                x += width / 2, y += distance, textAlign = "center";
                break;

              case "insideBottom":
                x += width / 2, y += height - distance, textAlign = "center", textVerticalAlign = "bottom";
                break;

              case "insideTopLeft":
                x += distance, y += distance;
                break;

              case "insideTopRight":
                x += width - distance, y += distance, textAlign = "right";
                break;

              case "insideBottomLeft":
                x += distance, y += height - distance, textVerticalAlign = "bottom";
                break;

              case "insideBottomRight":
                x += width - distance, y += height - distance, textAlign = "right", textVerticalAlign = "bottom";
            }
            return (out = out || {}).x = x, out.y = y, out.textAlign = textAlign, out.textVerticalAlign = textVerticalAlign, 
            out;
        }
        function truncateText(text, containerWidth, font, ellipsis, options) {
            if (!containerWidth) return "";
            var textLines = (text + "").split("\n");
            options = prepareTruncateOptions(containerWidth, font, ellipsis, options);
            for (var i = 0, len = textLines.length; i < len; i++) textLines[i] = truncateSingleLine(textLines[i], options);
            return textLines.join("\n");
        }
        function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
            (options = extend({}, options)).font = font;
            ellipsis = retrieve2(ellipsis, "...");
            options.maxIterations = retrieve2(options.maxIterations, 2);
            var minChar = options.minChar = retrieve2(options.minChar, 0);
            options.cnCharWidth = getWidth("国", font);
            var ascCharWidth = options.ascCharWidth = getWidth("a", font);
            options.placeholder = retrieve2(options.placeholder, "");
            for (var contentWidth = containerWidth = Math.max(0, containerWidth - 1), i = 0; i < minChar && contentWidth >= ascCharWidth; i++) contentWidth -= ascCharWidth;
            var ellipsisWidth = getWidth(ellipsis, font);
            return ellipsisWidth > contentWidth && (ellipsis = "", ellipsisWidth = 0), contentWidth = containerWidth - ellipsisWidth, 
            options.ellipsis = ellipsis, options.ellipsisWidth = ellipsisWidth, options.contentWidth = contentWidth, 
            options.containerWidth = containerWidth, options;
        }
        function truncateSingleLine(textLine, options) {
            var containerWidth = options.containerWidth, font = options.font, contentWidth = options.contentWidth;
            if (!containerWidth) return "";
            var lineWidth = getWidth(textLine, font);
            if (lineWidth <= containerWidth) return textLine;
            for (var j = 0; ;j++) {
                if (lineWidth <= contentWidth || j >= options.maxIterations) {
                    textLine += options.ellipsis;
                    break;
                }
                var subLength = 0 === j ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;
                lineWidth = getWidth(textLine = textLine.substr(0, subLength), font);
            }
            return "" === textLine && (textLine = options.placeholder), textLine;
        }
        function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
            for (var width = 0, i = 0, len = text.length; i < len && width < contentWidth; i++) {
                var charCode = text.charCodeAt(i);
                width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;
            }
            return i;
        }
        function getLineHeight(font) {
            return getWidth("国", font);
        }
        function measureText(text, font) {
            return methods.measureText(text, font);
        }
        function parsePlainText(text, font, padding, textLineHeight, truncate) {
            null != text && (text += "");
            var lineHeight = retrieve2(textLineHeight, getLineHeight(font)), lines = text ? text.split("\n") : [], height = lines.length * lineHeight, outerHeight = height;
            if (padding && (outerHeight += padding[0] + padding[2]), text && truncate) {
                var truncOuterHeight = truncate.outerHeight, truncOuterWidth = truncate.outerWidth;
                if (null != truncOuterHeight && outerHeight > truncOuterHeight) text = "", lines = []; else if (null != truncOuterWidth) for (var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {
                    minChar: truncate.minChar,
                    placeholder: truncate.placeholder
                }), i = 0, len = lines.length; i < len; i++) lines[i] = truncateSingleLine(lines[i], options);
            }
            return {
                lines: lines,
                height: height,
                outerHeight: outerHeight,
                lineHeight: lineHeight
            };
        }
        function parseRichText(text, style) {
            var contentBlock = {
                lines: [],
                width: 0,
                height: 0
            };
            if (null != text && (text += ""), !text) return contentBlock;
            for (var result, lastIndex = STYLE_REG.lastIndex = 0; null != (result = STYLE_REG.exec(text)); ) {
                var matchedIndex = result.index;
                matchedIndex > lastIndex && pushTokens(contentBlock, text.substring(lastIndex, matchedIndex)), 
                pushTokens(contentBlock, result[2], result[1]), lastIndex = STYLE_REG.lastIndex;
            }
            lastIndex < text.length && pushTokens(contentBlock, text.substring(lastIndex, text.length));
            var lines = contentBlock.lines, contentHeight = 0, contentWidth = 0, pendingList = [], stlPadding = style.textPadding, truncate = style.truncate, truncateWidth = truncate && truncate.outerWidth, truncateHeight = truncate && truncate.outerHeight;
            stlPadding && (null != truncateWidth && (truncateWidth -= stlPadding[1] + stlPadding[3]), 
            null != truncateHeight && (truncateHeight -= stlPadding[0] + stlPadding[2]));
            for (var i = 0; i < lines.length; i++) {
                for (var line = lines[i], lineHeight = 0, lineWidth = 0, j = 0; j < line.tokens.length; j++) {
                    var tokenStyle = (token = line.tokens[j]).styleName && style.rich[token.styleName] || {}, textPadding = token.textPadding = tokenStyle.textPadding, font = token.font = tokenStyle.font || style.font, tokenHeight = token.textHeight = retrieve2(tokenStyle.textHeight, getLineHeight(font));
                    if (textPadding && (tokenHeight += textPadding[0] + textPadding[2]), token.height = tokenHeight, 
                    token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight), 
                    token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign, token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || "middle", 
                    null != truncateHeight && contentHeight + token.lineHeight > truncateHeight) return {
                        lines: [],
                        width: 0,
                        height: 0
                    };
                    token.textWidth = getWidth(token.text, font);
                    var tokenWidth = tokenStyle.textWidth, tokenWidthNotSpecified = null == tokenWidth || "auto" === tokenWidth;
                    if ("string" == typeof tokenWidth && "%" === tokenWidth.charAt(tokenWidth.length - 1)) token.percentWidth = tokenWidth, 
                    pendingList.push(token), tokenWidth = 0; else {
                        if (tokenWidthNotSpecified) {
                            tokenWidth = token.textWidth;
                            var textBackgroundColor = tokenStyle.textBackgroundColor, bgImg = textBackgroundColor && textBackgroundColor.image;
                            bgImg && (bgImg = imageHelper.findExistImage(bgImg), imageHelper.isImageReady(bgImg) && (tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height)));
                        }
                        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;
                        tokenWidth += paddingW;
                        var remianTruncWidth = null != truncateWidth ? truncateWidth - lineWidth : null;
                        null != remianTruncWidth && remianTruncWidth < tokenWidth && (!tokenWidthNotSpecified || remianTruncWidth < paddingW ? (token.text = "", 
                        token.textWidth = tokenWidth = 0) : (token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {
                            minChar: truncate.minChar
                        }), token.textWidth = getWidth(token.text, font), tokenWidth = token.textWidth + paddingW));
                    }
                    lineWidth += token.width = tokenWidth, tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
                }
                line.width = lineWidth, line.lineHeight = lineHeight, contentHeight += lineHeight, 
                contentWidth = Math.max(contentWidth, lineWidth);
            }
            contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth), 
            contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight), 
            stlPadding && (contentBlock.outerWidth += stlPadding[1] + stlPadding[3], contentBlock.outerHeight += stlPadding[0] + stlPadding[2]);
            for (i = 0; i < pendingList.length; i++) {
                var token, percentWidth = (token = pendingList[i]).percentWidth;
                token.width = parseInt(percentWidth, 10) / 100 * contentWidth;
            }
            return contentBlock;
        }
        function pushTokens(block, str, styleName) {
            for (var isEmptyStr = "" === str, strs = str.split("\n"), lines = block.lines, i = 0; i < strs.length; i++) {
                var text = strs[i], token = {
                    styleName: styleName,
                    text: text,
                    isLineHolder: !text && !isEmptyStr
                };
                if (i) lines.push({
                    tokens: [ token ]
                }); else {
                    var tokens = (lines[lines.length - 1] || (lines[0] = {
                        tokens: []
                    })).tokens, tokensLen = tokens.length;
                    1 === tokensLen && tokens[0].isLineHolder ? tokens[0] = token : (text || !tokensLen || isEmptyStr) && tokens.push(token);
                }
            }
        }
        methods.measureText = function(text, font) {
            var ctx = getContext();
            return ctx.font = font || DEFAULT_FONT, ctx.measureText(text);
        }, exports.DEFAULT_FONT = DEFAULT_FONT, exports.$override = function(name, fn) {
            methods[name] = fn;
        }, exports.getWidth = getWidth, exports.getBoundingRect = function(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {
            return rich ? function(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {
                var contentBlock = parseRichText(text, {
                    rich: rich,
                    truncate: truncate,
                    font: font,
                    textAlign: textAlign,
                    textPadding: textPadding,
                    textLineHeight: textLineHeight
                }), outerWidth = contentBlock.outerWidth, outerHeight = contentBlock.outerHeight, x = adjustTextX(0, outerWidth, textAlign), y = adjustTextY(0, outerHeight, textVerticalAlign);
                return new BoundingRect(x, y, outerWidth, outerHeight);
            }(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) : function(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate) {
                var contentBlock = parsePlainText(text, font, textPadding, textLineHeight, truncate), outerWidth = getWidth(text, font);
                textPadding && (outerWidth += textPadding[1] + textPadding[3]);
                var outerHeight = contentBlock.outerHeight, x = adjustTextX(0, outerWidth, textAlign), y = adjustTextY(0, outerHeight, textVerticalAlign), rect = new BoundingRect(x, y, outerWidth, outerHeight);
                return rect.lineHeight = contentBlock.lineHeight, rect;
            }(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate);
        }, exports.adjustTextX = adjustTextX, exports.adjustTextY = adjustTextY, exports.calculateTextPosition = calculateTextPosition, 
        exports.adjustTextPositionOnRect = function(textPosition, rect, distance) {
            return calculateTextPosition({}, {
                textPosition: textPosition,
                textDistance: distance
            }, rect);
        }, exports.truncateText = truncateText, exports.getLineHeight = getLineHeight, exports.measureText = measureText, 
        exports.parsePlainText = parsePlainText, exports.parseRichText = parseRichText, 
        exports.makeFont = function(style) {
            var font = (style.fontSize || style.fontFamily) && [ style.fontStyle, style.fontWeight, (style.fontSize || 12) + "px", style.fontFamily || "sans-serif" ].join(" ");
            return font && trim(font) || style.textFont || style.font;
        };
    }, function(module, exports, __webpack_require__) {
        var _vector = __webpack_require__(6), v2Create = _vector.create, v2DistSquare = _vector.distSquare, mathPow = Math.pow, mathSqrt = Math.sqrt, EPSILON = 1e-8, EPSILON_NUMERIC = 1e-4, THREE_SQRT = mathSqrt(3), ONE_THIRD = 1 / 3, _v0 = v2Create(), _v1 = v2Create(), _v2 = v2Create();
        function isAroundZero(val) {
            return val > -EPSILON && val < EPSILON;
        }
        function isNotAroundZero(val) {
            return val > EPSILON || val < -EPSILON;
        }
        function cubicAt(p0, p1, p2, p3, t) {
            var onet = 1 - t;
            return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
        }
        function quadraticAt(p0, p1, p2, t) {
            var onet = 1 - t;
            return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
        }
        exports.cubicAt = cubicAt, exports.cubicDerivativeAt = function(p0, p1, p2, p3, t) {
            var onet = 1 - t;
            return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
        }, exports.cubicRootAt = function(p0, p1, p2, p3, val, roots) {
            var a = p3 + 3 * (p1 - p2) - p0, b = 3 * (p2 - 2 * p1 + p0), c = 3 * (p1 - p0), d = p0 - val, A = b * b - 3 * a * c, B = b * c - 9 * a * d, C = c * c - 3 * b * d, n = 0;
            if (isAroundZero(A) && isAroundZero(B)) isAroundZero(b) ? roots[0] = 0 : (t1 = -c / b) >= 0 && t1 <= 1 && (roots[n++] = t1); else {
                var disc = B * B - 4 * A * C;
                if (isAroundZero(disc)) {
                    var K = B / A, t2 = -K / 2;
                    (t1 = -b / a + K) >= 0 && t1 <= 1 && (roots[n++] = t1), t2 >= 0 && t2 <= 1 && (roots[n++] = t2);
                } else if (disc > 0) {
                    var discSqrt = mathSqrt(disc), Y1 = A * b + 1.5 * a * (-B + discSqrt), Y2 = A * b + 1.5 * a * (-B - discSqrt);
                    (t1 = (-b - ((Y1 = Y1 < 0 ? -mathPow(-Y1, ONE_THIRD) : mathPow(Y1, ONE_THIRD)) + (Y2 = Y2 < 0 ? -mathPow(-Y2, ONE_THIRD) : mathPow(Y2, ONE_THIRD)))) / (3 * a)) >= 0 && t1 <= 1 && (roots[n++] = t1);
                } else {
                    var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A)), theta = Math.acos(T) / 3, ASqrt = mathSqrt(A), tmp = Math.cos(theta), t1 = (-b - 2 * ASqrt * tmp) / (3 * a), t3 = (t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a), 
                    (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a));
                    t1 >= 0 && t1 <= 1 && (roots[n++] = t1), t2 >= 0 && t2 <= 1 && (roots[n++] = t2), 
                    t3 >= 0 && t3 <= 1 && (roots[n++] = t3);
                }
            }
            return n;
        }, exports.cubicExtrema = function(p0, p1, p2, p3, extrema) {
            var b = 6 * p2 - 12 * p1 + 6 * p0, a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2, c = 3 * p1 - 3 * p0, n = 0;
            if (isAroundZero(a)) isNotAroundZero(b) && (t1 = -c / b) >= 0 && t1 <= 1 && (extrema[n++] = t1); else {
                var disc = b * b - 4 * a * c;
                if (isAroundZero(disc)) extrema[0] = -b / (2 * a); else if (disc > 0) {
                    var t1, discSqrt = mathSqrt(disc), t2 = (-b - discSqrt) / (2 * a);
                    (t1 = (-b + discSqrt) / (2 * a)) >= 0 && t1 <= 1 && (extrema[n++] = t1), t2 >= 0 && t2 <= 1 && (extrema[n++] = t2);
                }
            }
            return n;
        }, exports.cubicSubdivide = function(p0, p1, p2, p3, t, out) {
            var p01 = (p1 - p0) * t + p0, p12 = (p2 - p1) * t + p1, p23 = (p3 - p2) * t + p2, p012 = (p12 - p01) * t + p01, p123 = (p23 - p12) * t + p12, p0123 = (p123 - p012) * t + p012;
            out[0] = p0, out[1] = p01, out[2] = p012, out[3] = p0123, out[4] = p0123, out[5] = p123, 
            out[6] = p23, out[7] = p3;
        }, exports.cubicProjectPoint = function(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
            var t, prev, next, d1, d2, interval = .005, d = 1 / 0;
            _v0[0] = x, _v0[1] = y;
            for (var _t = 0; _t < 1; _t += .05) _v1[0] = cubicAt(x0, x1, x2, x3, _t), _v1[1] = cubicAt(y0, y1, y2, y3, _t), 
            (d1 = v2DistSquare(_v0, _v1)) < d && (t = _t, d = d1);
            d = 1 / 0;
            for (var i = 0; i < 32 && !(interval < EPSILON_NUMERIC); i++) prev = t - interval, 
            next = t + interval, _v1[0] = cubicAt(x0, x1, x2, x3, prev), _v1[1] = cubicAt(y0, y1, y2, y3, prev), 
            d1 = v2DistSquare(_v1, _v0), prev >= 0 && d1 < d ? (t = prev, d = d1) : (_v2[0] = cubicAt(x0, x1, x2, x3, next), 
            _v2[1] = cubicAt(y0, y1, y2, y3, next), d2 = v2DistSquare(_v2, _v0), next <= 1 && d2 < d ? (t = next, 
            d = d2) : interval *= .5);
            return out && (out[0] = cubicAt(x0, x1, x2, x3, t), out[1] = cubicAt(y0, y1, y2, y3, t)), 
            mathSqrt(d);
        }, exports.quadraticAt = quadraticAt, exports.quadraticDerivativeAt = function(p0, p1, p2, t) {
            return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
        }, exports.quadraticRootAt = function(p0, p1, p2, val, roots) {
            var a = p0 - 2 * p1 + p2, b = 2 * (p1 - p0), c = p0 - val, n = 0;
            if (isAroundZero(a)) isNotAroundZero(b) && (t1 = -c / b) >= 0 && t1 <= 1 && (roots[n++] = t1); else {
                var disc = b * b - 4 * a * c;
                if (isAroundZero(disc)) (t1 = -b / (2 * a)) >= 0 && t1 <= 1 && (roots[n++] = t1); else if (disc > 0) {
                    var t1, discSqrt = mathSqrt(disc), t2 = (-b - discSqrt) / (2 * a);
                    (t1 = (-b + discSqrt) / (2 * a)) >= 0 && t1 <= 1 && (roots[n++] = t1), t2 >= 0 && t2 <= 1 && (roots[n++] = t2);
                }
            }
            return n;
        }, exports.quadraticExtremum = function(p0, p1, p2) {
            var divider = p0 + p2 - 2 * p1;
            return 0 === divider ? .5 : (p0 - p1) / divider;
        }, exports.quadraticSubdivide = function(p0, p1, p2, t, out) {
            var p01 = (p1 - p0) * t + p0, p12 = (p2 - p1) * t + p1, p012 = (p12 - p01) * t + p01;
            out[0] = p0, out[1] = p01, out[2] = p012, out[3] = p012, out[4] = p12, out[5] = p2;
        }, exports.quadraticProjectPoint = function(x0, y0, x1, y1, x2, y2, x, y, out) {
            var t, interval = .005, d = 1 / 0;
            _v0[0] = x, _v0[1] = y;
            for (var _t = 0; _t < 1; _t += .05) _v1[0] = quadraticAt(x0, x1, x2, _t), _v1[1] = quadraticAt(y0, y1, y2, _t), 
            (d1 = v2DistSquare(_v0, _v1)) < d && (t = _t, d = d1);
            d = 1 / 0;
            for (var i = 0; i < 32 && !(interval < EPSILON_NUMERIC); i++) {
                var prev = t - interval, next = t + interval;
                _v1[0] = quadraticAt(x0, x1, x2, prev), _v1[1] = quadraticAt(y0, y1, y2, prev);
                var d1 = v2DistSquare(_v1, _v0);
                if (prev >= 0 && d1 < d) t = prev, d = d1; else {
                    _v2[0] = quadraticAt(x0, x1, x2, next), _v2[1] = quadraticAt(y0, y1, y2, next);
                    var d2 = v2DistSquare(_v2, _v0);
                    next <= 1 && d2 < d ? (t = next, d = d2) : interval *= .5;
                }
            }
            return out && (out[0] = quadraticAt(x0, x1, x2, t), out[1] = quadraticAt(y0, y1, y2, t)), 
            mathSqrt(d);
        };
    }, function(module, exports) {
        var arrySlice = Array.prototype.slice, Eventful = function(eventProcessor) {
            this._$handlers = {}, this._$eventProcessor = eventProcessor;
        };
        function on(eventful, event, query, handler, context, isOnce) {
            var _h = eventful._$handlers;
            if ("function" == typeof query && (context = handler, handler = query, query = null), 
            !handler || !event) return eventful;
            query = function(host, query) {
                var eventProcessor = host._$eventProcessor;
                return null != query && eventProcessor && eventProcessor.normalizeQuery && (query = eventProcessor.normalizeQuery(query)), 
                query;
            }(eventful, query), _h[event] || (_h[event] = []);
            for (var i = 0; i < _h[event].length; i++) if (_h[event][i].h === handler) return eventful;
            var wrap = {
                h: handler,
                one: isOnce,
                query: query,
                ctx: context || eventful,
                callAtLast: handler.zrEventfulCallAtLast
            }, lastIndex = _h[event].length - 1, lastWrap = _h[event][lastIndex];
            return lastWrap && lastWrap.callAtLast ? _h[event].splice(lastIndex, 0, wrap) : _h[event].push(wrap), 
            eventful;
        }
        Eventful.prototype = {
            constructor: Eventful,
            one: function(event, query, handler, context) {
                return on(this, event, query, handler, context, !0);
            },
            on: function(event, query, handler, context) {
                return on(this, event, query, handler, context, !1);
            },
            isSilent: function(event) {
                var _h = this._$handlers;
                return !_h[event] || !_h[event].length;
            },
            off: function(event, handler) {
                var _h = this._$handlers;
                if (!event) return this._$handlers = {}, this;
                if (handler) {
                    if (_h[event]) {
                        for (var newList = [], i = 0, l = _h[event].length; i < l; i++) _h[event][i].h !== handler && newList.push(_h[event][i]);
                        _h[event] = newList;
                    }
                    _h[event] && 0 === _h[event].length && delete _h[event];
                } else delete _h[event];
                return this;
            },
            trigger: function(type) {
                var _h = this._$handlers[type], eventProcessor = this._$eventProcessor;
                if (_h) {
                    var args = arguments, argLen = args.length;
                    argLen > 3 && (args = arrySlice.call(args, 1));
                    for (var len = _h.length, i = 0; i < len; ) {
                        var hItem = _h[i];
                        if (eventProcessor && eventProcessor.filter && null != hItem.query && !eventProcessor.filter(type, hItem.query)) i++; else {
                            switch (argLen) {
                              case 1:
                                hItem.h.call(hItem.ctx);
                                break;

                              case 2:
                                hItem.h.call(hItem.ctx, args[1]);
                                break;

                              case 3:
                                hItem.h.call(hItem.ctx, args[1], args[2]);
                                break;

                              default:
                                hItem.h.apply(hItem.ctx, args);
                            }
                            hItem.one ? (_h.splice(i, 1), len--) : i++;
                        }
                    }
                }
                return eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type), 
                this;
            },
            triggerWithContext: function(type) {
                var _h = this._$handlers[type], eventProcessor = this._$eventProcessor;
                if (_h) {
                    var args = arguments, argLen = args.length;
                    argLen > 4 && (args = arrySlice.call(args, 1, args.length - 1));
                    for (var ctx = args[args.length - 1], len = _h.length, i = 0; i < len; ) {
                        var hItem = _h[i];
                        if (eventProcessor && eventProcessor.filter && null != hItem.query && !eventProcessor.filter(type, hItem.query)) i++; else {
                            switch (argLen) {
                              case 1:
                                hItem.h.call(ctx);
                                break;

                              case 2:
                                hItem.h.call(ctx, args[1]);
                                break;

                              case 3:
                                hItem.h.call(ctx, args[1], args[2]);
                                break;

                              default:
                                hItem.h.apply(ctx, args);
                            }
                            hItem.one ? (_h.splice(i, 1), len--) : i++;
                        }
                    }
                }
                return eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type), 
                this;
            }
        };
        var _default = Eventful;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(5).__DEV__;
        var zrUtil = __webpack_require__(0), env = __webpack_require__(7), _format = __webpack_require__(9), formatTime = _format.formatTime, encodeHTML = _format.encodeHTML, addCommas = _format.addCommas, getTooltipMarker = _format.getTooltipMarker, modelUtil = __webpack_require__(3), ComponentModel = __webpack_require__(13), colorPaletteMixin = __webpack_require__(112), dataFormatMixin = __webpack_require__(115), _layout = __webpack_require__(10), getLayoutParams = _layout.getLayoutParams, mergeLayoutParam = _layout.mergeLayoutParam, createTask = __webpack_require__(63).createTask, _sourceHelper = __webpack_require__(40), prepareSource = _sourceHelper.prepareSource, getSource = _sourceHelper.getSource, retrieveRawValue = __webpack_require__(30).retrieveRawValue, inner = modelUtil.makeInner(), SeriesModel = ComponentModel.extend({
            type: "series.__base__",
            seriesIndex: 0,
            coordinateSystem: null,
            defaultOption: null,
            legendDataProvider: null,
            visualColorAccessPath: "itemStyle.color",
            layoutMode: null,
            init: function(option, parentModel, ecModel, extraOpt) {
                this.seriesIndex = this.componentIndex, this.dataTask = createTask({
                    count: dataTaskCount,
                    reset: dataTaskReset
                }), this.dataTask.context = {
                    model: this
                }, this.mergeDefaultAndTheme(option, ecModel), prepareSource(this);
                var data = this.getInitialData(option, ecModel);
                wrapData(data, this), this.dataTask.context.data = data, inner(this).dataBeforeProcessed = data, 
                autoSeriesName(this);
            },
            mergeDefaultAndTheme: function(option, ecModel) {
                var layoutMode = this.layoutMode, inputPositionParams = layoutMode ? getLayoutParams(option) : {}, themeSubType = this.subType;
                ComponentModel.hasClass(themeSubType) && (themeSubType += "Series"), zrUtil.merge(option, ecModel.getTheme().get(this.subType)), 
                zrUtil.merge(option, this.getDefaultOption()), modelUtil.defaultEmphasis(option, "label", [ "show" ]), 
                this.fillDataTextStyle(option.data), layoutMode && mergeLayoutParam(option, inputPositionParams, layoutMode);
            },
            mergeOption: function(newSeriesOption, ecModel) {
                newSeriesOption = zrUtil.merge(this.option, newSeriesOption, !0), this.fillDataTextStyle(newSeriesOption.data);
                var layoutMode = this.layoutMode;
                layoutMode && mergeLayoutParam(this.option, newSeriesOption, layoutMode), prepareSource(this);
                var data = this.getInitialData(newSeriesOption, ecModel);
                wrapData(data, this), this.dataTask.dirty(), this.dataTask.context.data = data, 
                inner(this).dataBeforeProcessed = data, autoSeriesName(this);
            },
            fillDataTextStyle: function(data) {
                if (data && !zrUtil.isTypedArray(data)) for (var props = [ "show" ], i = 0; i < data.length; i++) data[i] && data[i].label && modelUtil.defaultEmphasis(data[i], "label", props);
            },
            getInitialData: function() {},
            appendData: function(params) {
                this.getRawData().appendData(params.data);
            },
            getData: function(dataType) {
                var task = getCurrentTask(this);
                if (task) {
                    var data = task.context.data;
                    return null == dataType ? data : data.getLinkedData(dataType);
                }
                return inner(this).data;
            },
            setData: function(data) {
                var task = getCurrentTask(this);
                if (task) {
                    var context = task.context;
                    context.data !== data && task.modifyOutputEnd && task.setOutputEnd(data.count()), 
                    context.outputData = data, task !== this.dataTask && (context.data = data);
                }
                inner(this).data = data;
            },
            getSource: function() {
                return getSource(this);
            },
            getRawData: function() {
                return inner(this).dataBeforeProcessed;
            },
            getBaseAxis: function() {
                var coordSys = this.coordinateSystem;
                return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();
            },
            formatTooltip: function(dataIndex, multipleSeries, dataType, renderMode) {
                var series = this, newLine = "html" === (renderMode = renderMode || "html") ? "<br/>" : "\n", isRichText = "richText" === renderMode, markers = {}, markerId = 0;
                function formatSingleValue(val) {
                    return {
                        renderMode: renderMode,
                        content: encodeHTML(addCommas(val)),
                        style: markers
                    };
                }
                var data = this.getData(), tooltipDims = data.mapDimension("defaultedTooltip", !0), tooltipDimLen = tooltipDims.length, value = this.getRawValue(dataIndex), isValueArr = zrUtil.isArray(value), color = data.getItemVisual(dataIndex, "color");
                zrUtil.isObject(color) && color.colorStops && (color = (color.colorStops[0] || {}).color), 
                color = color || "transparent";
                var content = (tooltipDimLen > 1 || isValueArr && !tooltipDimLen ? function(value) {
                    var vertially = zrUtil.reduce(value, function(vertially, val, idx) {
                        var dimItem = data.getDimensionInfo(idx);
                        return vertially | (dimItem && !1 !== dimItem.tooltip && null != dimItem.displayName);
                    }, 0), result = [];
                    function setEachItem(val, dim) {
                        var dimInfo = data.getDimensionInfo(dim);
                        if (dimInfo && !1 !== dimInfo.otherDims.tooltip) {
                            var dimType = dimInfo.type, markName = "sub" + series.seriesIndex + "at" + markerId, dimHead = getTooltipMarker({
                                color: color,
                                type: "subItem",
                                renderMode: renderMode,
                                markerId: markName
                            }), dimHeadStr = "string" == typeof dimHead ? dimHead : dimHead.content, valStr = (vertially ? dimHeadStr + encodeHTML(dimInfo.displayName || "-") + ": " : "") + encodeHTML("ordinal" === dimType ? val + "" : "time" === dimType ? multipleSeries ? "" : formatTime("yyyy/MM/dd hh:mm:ss", val) : addCommas(val));
                            valStr && result.push(valStr), isRichText && (markers[markName] = color, ++markerId);
                        }
                    }
                    tooltipDims.length ? zrUtil.each(tooltipDims, function(dim) {
                        setEachItem(retrieveRawValue(data, dataIndex, dim), dim);
                    }) : zrUtil.each(value, setEachItem);
                    var newLine = vertially ? isRichText ? "\n" : "<br/>" : "", content = newLine + result.join(newLine || ", ");
                    return {
                        renderMode: renderMode,
                        content: content,
                        style: markers
                    };
                }(value) : formatSingleValue(tooltipDimLen ? retrieveRawValue(data, dataIndex, tooltipDims[0]) : isValueArr ? value[0] : value)).content, markName = series.seriesIndex + "at" + markerId, colorEl = getTooltipMarker({
                    color: color,
                    type: "item",
                    renderMode: renderMode,
                    markerId: markName
                });
                markers[markName] = color, ++markerId;
                var name = data.getName(dataIndex), seriesName = this.name;
                modelUtil.isNameSpecified(this) || (seriesName = ""), seriesName = seriesName ? encodeHTML(seriesName) + (multipleSeries ? ": " : newLine) : "";
                var colorStr = "string" == typeof colorEl ? colorEl : colorEl.content;
                return {
                    html: multipleSeries ? colorStr + seriesName + content : seriesName + colorStr + (name ? encodeHTML(name) + ": " + content : content),
                    markers: markers
                };
            },
            isAnimationEnabled: function() {
                if (env.node) return !1;
                var animationEnabled = this.getShallow("animation");
                return animationEnabled && this.getData().count() > this.getShallow("animationThreshold") && (animationEnabled = !1), 
                animationEnabled;
            },
            restoreData: function() {
                this.dataTask.dirty();
            },
            getColorFromPalette: function(name, scope, requestColorNum) {
                var ecModel = this.ecModel, color = colorPaletteMixin.getColorFromPalette.call(this, name, scope, requestColorNum);
                return color || (color = ecModel.getColorFromPalette(name, scope, requestColorNum)), 
                color;
            },
            coordDimToDataDim: function(coordDim) {
                return this.getRawData().mapDimension(coordDim, !0);
            },
            getProgressive: function() {
                return this.get("progressive");
            },
            getProgressiveThreshold: function() {
                return this.get("progressiveThreshold");
            },
            getAxisTooltipData: null,
            getTooltipPosition: null,
            pipeTask: null,
            preventIncremental: null,
            pipelineContext: null
        });
        function autoSeriesName(seriesModel) {
            var name = seriesModel.name;
            modelUtil.isNameSpecified(seriesModel) || (seriesModel.name = function(seriesModel) {
                var data = seriesModel.getRawData(), dataDims = data.mapDimension("seriesName", !0), nameArr = [];
                return zrUtil.each(dataDims, function(dataDim) {
                    var dimInfo = data.getDimensionInfo(dataDim);
                    dimInfo.displayName && nameArr.push(dimInfo.displayName);
                }), nameArr.join(" ");
            }(seriesModel) || name);
        }
        function dataTaskCount(context) {
            return context.model.getRawData().count();
        }
        function dataTaskReset(context) {
            var seriesModel = context.model;
            return seriesModel.setData(seriesModel.getRawData().cloneShallow()), dataTaskProgress;
        }
        function dataTaskProgress(param, context) {
            param.end > context.outputData.count() && context.model.getRawData().cloneShallow(context.outputData);
        }
        function wrapData(data, seriesModel) {
            zrUtil.each(data.CHANGABLE_METHODS, function(methodName) {
                data.wrapMethod(methodName, zrUtil.curry(onDataSelfChange, seriesModel));
            });
        }
        function onDataSelfChange(seriesModel) {
            var task = getCurrentTask(seriesModel);
            task && task.setOutputEnd(this.count());
        }
        function getCurrentTask(seriesModel) {
            var scheduler = (seriesModel.ecModel || {}).scheduler, pipeline = scheduler && scheduler.getPipeline(seriesModel.uid);
            if (pipeline) {
                var task = pipeline.currentTask;
                if (task) {
                    var agentStubMap = task.agentStubMap;
                    agentStubMap && (task = agentStubMap.get(seriesModel.uid));
                }
                return task;
            }
        }
        zrUtil.mixin(SeriesModel, dataFormatMixin), zrUtil.mixin(SeriesModel, colorPaletteMixin);
        var _default = SeriesModel;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(5).__DEV__;
        var zrUtil = __webpack_require__(0), Model = __webpack_require__(14), DataDiffer = __webpack_require__(116), Source = __webpack_require__(28), _dataProvider = __webpack_require__(30), defaultDimValueGetters = _dataProvider.defaultDimValueGetters, DefaultDataProvider = _dataProvider.DefaultDataProvider, summarizeDimensions = __webpack_require__(66).summarizeDimensions, isObject = zrUtil.isObject, INDEX_NOT_FOUND = -1, ID_PREFIX = "e\0\0", dataCtors = {
            float: "undefined" == typeof Float64Array ? Array : Float64Array,
            int: "undefined" == typeof Int32Array ? Array : Int32Array,
            ordinal: Array,
            number: Array,
            time: Array
        }, CtorUint32Array = "undefined" == typeof Uint32Array ? Array : Uint32Array, CtorInt32Array = "undefined" == typeof Int32Array ? Array : Int32Array, CtorUint16Array = "undefined" == typeof Uint16Array ? Array : Uint16Array;
        function getIndicesCtor(list) {
            return list._rawCount > 65535 ? CtorUint32Array : CtorUint16Array;
        }
        function cloneChunk(originalChunk) {
            var Ctor = originalChunk.constructor;
            return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);
        }
        var TRANSFERABLE_PROPERTIES = [ "hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_rawData", "_chunkSize", "_chunkCount", "_dimValueGetter", "_count", "_rawCount", "_nameDimIdx", "_idDimIdx" ], CLONE_PROPERTIES = [ "_extent", "_approximateExtent", "_rawExtent" ];
        function transferProperties(target, source) {
            zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function(propName) {
                source.hasOwnProperty(propName) && (target[propName] = source[propName]);
            }), target.__wrappedMethods = source.__wrappedMethods, zrUtil.each(CLONE_PROPERTIES, function(propName) {
                target[propName] = zrUtil.clone(source[propName]);
            }), target._calculationInfo = zrUtil.extend(source._calculationInfo);
        }
        var List = function(dimensions, hostModel) {
            dimensions = dimensions || [ "x", "y" ];
            for (var dimensionInfos = {}, dimensionNames = [], invertedIndicesMap = {}, i = 0; i < dimensions.length; i++) {
                var dimensionInfo = dimensions[i];
                zrUtil.isString(dimensionInfo) && (dimensionInfo = {
                    name: dimensionInfo
                });
                var dimensionName = dimensionInfo.name;
                dimensionInfo.type = dimensionInfo.type || "float", dimensionInfo.coordDim || (dimensionInfo.coordDim = dimensionName, 
                dimensionInfo.coordDimIndex = 0), dimensionInfo.otherDims = dimensionInfo.otherDims || {}, 
                dimensionNames.push(dimensionName), dimensionInfos[dimensionName] = dimensionInfo, 
                dimensionInfo.index = i, dimensionInfo.createInvertedIndices && (invertedIndicesMap[dimensionName] = []);
            }
            this.dimensions = dimensionNames, this._dimensionInfos = dimensionInfos, this.hostModel = hostModel, 
            this.dataType, this._indices = null, this._count = 0, this._rawCount = 0, this._storage = {}, 
            this._nameList = [], this._idList = [], this._optionModels = [], this._visual = {}, 
            this._layout = {}, this._itemVisuals = [], this.hasItemVisual = {}, this._itemLayouts = [], 
            this._graphicEls = [], this._chunkSize = 1e5, this._chunkCount = 0, this._rawData, 
            this._rawExtent = {}, this._extent = {}, this._approximateExtent = {}, this._dimensionsSummary = summarizeDimensions(this), 
            this._invertedIndicesMap = invertedIndicesMap, this._calculationInfo = {}, this.userOutput = this._dimensionsSummary.userOutput;
        }, listProto = List.prototype;
        function prepareChunks(storage, dimInfo, chunkSize, chunkCount, end) {
            var DataCtor = dataCtors[dimInfo.type], lastChunkIndex = chunkCount - 1, dim = dimInfo.name, resizeChunkArray = storage[dim][lastChunkIndex];
            if (resizeChunkArray && resizeChunkArray.length < chunkSize) {
                for (var newStore = new DataCtor(Math.min(end - lastChunkIndex * chunkSize, chunkSize)), j = 0; j < resizeChunkArray.length; j++) newStore[j] = resizeChunkArray[j];
                storage[dim][lastChunkIndex] = newStore;
            }
            for (var k = chunkCount * chunkSize; k < end; k += chunkSize) storage[dim].push(new DataCtor(Math.min(end - k, chunkSize)));
        }
        function prepareInvertedIndex(list) {
            var invertedIndicesMap = list._invertedIndicesMap;
            zrUtil.each(invertedIndicesMap, function(invertedIndices, dim) {
                var ordinalMeta = list._dimensionInfos[dim].ordinalMeta;
                if (ordinalMeta) {
                    invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length);
                    for (var i = 0; i < invertedIndices.length; i++) invertedIndices[i] = INDEX_NOT_FOUND;
                    for (i = 0; i < list._count; i++) invertedIndices[list.get(dim, i)] = i;
                }
            });
        }
        function getRawValueFromStore(list, dimIndex, rawIndex) {
            var val;
            if (null != dimIndex) {
                var chunkSize = list._chunkSize, chunkIndex = Math.floor(rawIndex / chunkSize), chunkOffset = rawIndex % chunkSize, dim = list.dimensions[dimIndex], chunk = list._storage[dim][chunkIndex];
                if (chunk) {
                    val = chunk[chunkOffset];
                    var ordinalMeta = list._dimensionInfos[dim].ordinalMeta;
                    ordinalMeta && ordinalMeta.categories.length && (val = ordinalMeta.categories[val]);
                }
            }
            return val;
        }
        function getRawIndexWithoutIndices(idx) {
            return idx;
        }
        function getRawIndexWithIndices(idx) {
            return idx < this._count && idx >= 0 ? this._indices[idx] : -1;
        }
        function getId(list, rawIndex) {
            var id = list._idList[rawIndex];
            return null == id && (id = getRawValueFromStore(list, list._idDimIdx, rawIndex)), 
            null == id && (id = ID_PREFIX + rawIndex), id;
        }
        function normalizeDimensions(dimensions) {
            return zrUtil.isArray(dimensions) || (dimensions = [ dimensions ]), dimensions;
        }
        function cloneListForMapAndSample(original, excludeDimensions) {
            var allDimensions = original.dimensions, list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel);
            transferProperties(list, original);
            for (var storage = list._storage = {}, originalStorage = original._storage, i = 0; i < allDimensions.length; i++) {
                var dim = allDimensions[i];
                originalStorage[dim] && (zrUtil.indexOf(excludeDimensions, dim) >= 0 ? (storage[dim] = cloneDimStore(originalStorage[dim]), 
                list._rawExtent[dim] = getInitialExtent(), list._extent[dim] = null) : storage[dim] = originalStorage[dim]);
            }
            return list;
        }
        function cloneDimStore(originalDimStore) {
            for (var newDimStore = new Array(originalDimStore.length), j = 0; j < originalDimStore.length; j++) newDimStore[j] = cloneChunk(originalDimStore[j]);
            return newDimStore;
        }
        function getInitialExtent() {
            return [ 1 / 0, -1 / 0 ];
        }
        listProto.type = "list", listProto.hasItemOption = !0, listProto.getDimension = function(dim) {
            return "number" != typeof dim && (isNaN(dim) || this._dimensionInfos.hasOwnProperty(dim)) || (dim = this.dimensions[dim]), 
            dim;
        }, listProto.getDimensionInfo = function(dim) {
            return this._dimensionInfos[this.getDimension(dim)];
        }, listProto.getDimensionsOnCoord = function() {
            return this._dimensionsSummary.dataDimsOnCoord.slice();
        }, listProto.mapDimension = function(coordDim, idx) {
            var dimensionsSummary = this._dimensionsSummary;
            if (null == idx) return dimensionsSummary.encodeFirstDimNotExtra[coordDim];
            var dims = dimensionsSummary.encode[coordDim];
            return !0 === idx ? (dims || []).slice() : dims && dims[idx];
        }, listProto.initData = function(data, nameList, dimValueGetter) {
            (Source.isInstance(data) || zrUtil.isArrayLike(data)) && (data = new DefaultDataProvider(data, this.dimensions.length)), 
            this._rawData = data, this._storage = {}, this._indices = null, this._nameList = nameList || [], 
            this._idList = [], this._nameRepeatCount = {}, dimValueGetter || (this.hasItemOption = !1), 
            this.defaultDimValueGetter = defaultDimValueGetters[this._rawData.getSource().sourceFormat], 
            this._dimValueGetter = dimValueGetter = dimValueGetter || this.defaultDimValueGetter, 
            this._dimValueGetterArrayRows = defaultDimValueGetters.arrayRows, this._rawExtent = {}, 
            this._initDataFromProvider(0, data.count()), data.pure && (this.hasItemOption = !1);
        }, listProto.getProvider = function() {
            return this._rawData;
        }, listProto.appendData = function(data) {
            var rawData = this._rawData, start = this.count();
            rawData.appendData(data);
            var end = rawData.count();
            rawData.persistent || (end += start), this._initDataFromProvider(start, end);
        }, listProto.appendValues = function(values, names) {
            for (var chunkSize = this._chunkSize, storage = this._storage, dimensions = this.dimensions, dimLen = dimensions.length, rawExtent = this._rawExtent, start = this.count(), end = start + Math.max(values.length, names ? names.length : 0), originalChunkCount = this._chunkCount, i = 0; i < dimLen; i++) {
                rawExtent[dim = dimensions[i]] || (rawExtent[dim] = getInitialExtent()), storage[dim] || (storage[dim] = []), 
                prepareChunks(storage, this._dimensionInfos[dim], chunkSize, originalChunkCount, end), 
                this._chunkCount = storage[dim].length;
            }
            for (var emptyDataItem = new Array(dimLen), idx = start; idx < end; idx++) {
                for (var sourceIdx = idx - start, chunkIndex = Math.floor(idx / chunkSize), chunkOffset = idx % chunkSize, k = 0; k < dimLen; k++) {
                    var dim = dimensions[k], val = this._dimValueGetterArrayRows(values[sourceIdx] || emptyDataItem, dim, sourceIdx, k);
                    storage[dim][chunkIndex][chunkOffset] = val;
                    var dimRawExtent = rawExtent[dim];
                    val < dimRawExtent[0] && (dimRawExtent[0] = val), val > dimRawExtent[1] && (dimRawExtent[1] = val);
                }
                names && (this._nameList[idx] = names[sourceIdx]);
            }
            this._rawCount = this._count = end, this._extent = {}, prepareInvertedIndex(this);
        }, listProto._initDataFromProvider = function(start, end) {
            if (!(start >= end)) {
                for (var nameDimIdx, chunkSize = this._chunkSize, rawData = this._rawData, storage = this._storage, dimensions = this.dimensions, dimLen = dimensions.length, dimensionInfoMap = this._dimensionInfos, nameList = this._nameList, idList = this._idList, rawExtent = this._rawExtent, nameRepeatCount = this._nameRepeatCount = {}, originalChunkCount = this._chunkCount, i = 0; i < dimLen; i++) {
                    rawExtent[dim = dimensions[i]] || (rawExtent[dim] = getInitialExtent());
                    var dimInfo = dimensionInfoMap[dim];
                    0 === dimInfo.otherDims.itemName && (nameDimIdx = this._nameDimIdx = i), 0 === dimInfo.otherDims.itemId && (this._idDimIdx = i), 
                    storage[dim] || (storage[dim] = []), prepareChunks(storage, dimInfo, chunkSize, originalChunkCount, end), 
                    this._chunkCount = storage[dim].length;
                }
                for (var dataItem = new Array(dimLen), idx = start; idx < end; idx++) {
                    dataItem = rawData.getItem(idx, dataItem);
                    for (var chunkIndex = Math.floor(idx / chunkSize), chunkOffset = idx % chunkSize, k = 0; k < dimLen; k++) {
                        var dim, dimStorage = storage[dim = dimensions[k]][chunkIndex], val = this._dimValueGetter(dataItem, dim, idx, k);
                        dimStorage[chunkOffset] = val;
                        var dimRawExtent = rawExtent[dim];
                        val < dimRawExtent[0] && (dimRawExtent[0] = val), val > dimRawExtent[1] && (dimRawExtent[1] = val);
                    }
                    if (!rawData.pure) {
                        var name = nameList[idx];
                        if (dataItem && null == name) if (null != dataItem.name) nameList[idx] = name = dataItem.name; else if (null != nameDimIdx) {
                            var nameDim = dimensions[nameDimIdx], nameDimChunk = storage[nameDim][chunkIndex];
                            if (nameDimChunk) {
                                name = nameDimChunk[chunkOffset];
                                var ordinalMeta = dimensionInfoMap[nameDim].ordinalMeta;
                                ordinalMeta && ordinalMeta.categories.length && (name = ordinalMeta.categories[name]);
                            }
                        }
                        var id = null == dataItem ? null : dataItem.id;
                        null == id && null != name && (nameRepeatCount[name] = nameRepeatCount[name] || 0, 
                        id = name, nameRepeatCount[name] > 0 && (id += "__ec__" + nameRepeatCount[name]), 
                        nameRepeatCount[name]++), null != id && (idList[idx] = id);
                    }
                }
                !rawData.persistent && rawData.clean && rawData.clean(), this._rawCount = this._count = end, 
                this._extent = {}, prepareInvertedIndex(this);
            }
        }, listProto.count = function() {
            return this._count;
        }, listProto.getIndices = function() {
            var indices = this._indices;
            if (indices) {
                var Ctor = indices.constructor, thisCount = this._count;
                if (Ctor === Array) {
                    newIndices = new Ctor(thisCount);
                    for (var i = 0; i < thisCount; i++) newIndices[i] = indices[i];
                } else newIndices = new Ctor(indices.buffer, 0, thisCount);
            } else {
                var newIndices = new (Ctor = getIndicesCtor(this))(this.count());
                for (i = 0; i < newIndices.length; i++) newIndices[i] = i;
            }
            return newIndices;
        }, listProto.get = function(dim, idx) {
            if (!(idx >= 0 && idx < this._count)) return NaN;
            var storage = this._storage;
            if (!storage[dim]) return NaN;
            idx = this.getRawIndex(idx);
            var chunkIndex = Math.floor(idx / this._chunkSize), chunkOffset = idx % this._chunkSize;
            return storage[dim][chunkIndex][chunkOffset];
        }, listProto.getByRawIndex = function(dim, rawIdx) {
            if (!(rawIdx >= 0 && rawIdx < this._rawCount)) return NaN;
            var dimStore = this._storage[dim];
            if (!dimStore) return NaN;
            var chunkIndex = Math.floor(rawIdx / this._chunkSize), chunkOffset = rawIdx % this._chunkSize;
            return dimStore[chunkIndex][chunkOffset];
        }, listProto._getFast = function(dim, rawIdx) {
            var chunkIndex = Math.floor(rawIdx / this._chunkSize), chunkOffset = rawIdx % this._chunkSize;
            return this._storage[dim][chunkIndex][chunkOffset];
        }, listProto.getValues = function(dimensions, idx) {
            var values = [];
            zrUtil.isArray(dimensions) || (idx = dimensions, dimensions = this.dimensions);
            for (var i = 0, len = dimensions.length; i < len; i++) values.push(this.get(dimensions[i], idx));
            return values;
        }, listProto.hasValue = function(idx) {
            for (var dataDimsOnCoord = this._dimensionsSummary.dataDimsOnCoord, i = 0, len = dataDimsOnCoord.length; i < len; i++) if (isNaN(this.get(dataDimsOnCoord[i], idx))) return !1;
            return !0;
        }, listProto.getDataExtent = function(dim) {
            dim = this.getDimension(dim);
            var dimData = this._storage[dim], initialExtent = getInitialExtent();
            if (!dimData) return initialExtent;
            var dimExtent, currEnd = this.count();
            if (!this._indices) return this._rawExtent[dim].slice();
            if (dimExtent = this._extent[dim]) return dimExtent.slice();
            for (var min = (dimExtent = initialExtent)[0], max = dimExtent[1], i = 0; i < currEnd; i++) {
                var value = this._getFast(dim, this.getRawIndex(i));
                value < min && (min = value), value > max && (max = value);
            }
            return dimExtent = [ min, max ], this._extent[dim] = dimExtent, dimExtent;
        }, listProto.getApproximateExtent = function(dim) {
            return dim = this.getDimension(dim), this._approximateExtent[dim] || this.getDataExtent(dim);
        }, listProto.setApproximateExtent = function(extent, dim) {
            dim = this.getDimension(dim), this._approximateExtent[dim] = extent.slice();
        }, listProto.getCalculationInfo = function(key) {
            return this._calculationInfo[key];
        }, listProto.setCalculationInfo = function(key, value) {
            isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;
        }, listProto.getSum = function(dim) {
            var sum = 0;
            if (this._storage[dim]) for (var i = 0, len = this.count(); i < len; i++) {
                var value = this.get(dim, i);
                isNaN(value) || (sum += value);
            }
            return sum;
        }, listProto.getMedian = function(dim) {
            var dimDataArray = [];
            this.each(dim, function(val, idx) {
                isNaN(val) || dimDataArray.push(val);
            });
            var sortedDimDataArray = [].concat(dimDataArray).sort(function(a, b) {
                return a - b;
            }), len = this.count();
            return 0 === len ? 0 : len % 2 == 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;
        }, listProto.rawIndexOf = function(dim, value) {
            var rawIndex = (dim && this._invertedIndicesMap[dim])[value];
            return null == rawIndex || isNaN(rawIndex) ? INDEX_NOT_FOUND : rawIndex;
        }, listProto.indexOfName = function(name) {
            for (var i = 0, len = this.count(); i < len; i++) if (this.getName(i) === name) return i;
            return -1;
        }, listProto.indexOfRawIndex = function(rawIndex) {
            if (!this._indices) return rawIndex;
            if (rawIndex >= this._rawCount || rawIndex < 0) return -1;
            var indices = this._indices, rawDataIndex = indices[rawIndex];
            if (null != rawDataIndex && rawDataIndex < this._count && rawDataIndex === rawIndex) return rawIndex;
            for (var left = 0, right = this._count - 1; left <= right; ) {
                var mid = (left + right) / 2 | 0;
                if (indices[mid] < rawIndex) left = mid + 1; else {
                    if (!(indices[mid] > rawIndex)) return mid;
                    right = mid - 1;
                }
            }
            return -1;
        }, listProto.indicesOfNearest = function(dim, value, maxDistance) {
            var nearestIndices = [];
            if (!this._storage[dim]) return nearestIndices;
            null == maxDistance && (maxDistance = 1 / 0);
            for (var minDist = Number.MAX_VALUE, minDiff = -1, i = 0, len = this.count(); i < len; i++) {
                var diff = value - this.get(dim, i), dist = Math.abs(diff);
                diff <= maxDistance && dist <= minDist && ((dist < minDist || diff >= 0 && minDiff < 0) && (minDist = dist, 
                minDiff = diff, nearestIndices.length = 0), nearestIndices.push(i));
            }
            return nearestIndices;
        }, listProto.getRawIndex = getRawIndexWithoutIndices, listProto.getRawDataItem = function(idx) {
            if (this._rawData.persistent) return this._rawData.getItem(this.getRawIndex(idx));
            for (var val = [], i = 0; i < this.dimensions.length; i++) {
                var dim = this.dimensions[i];
                val.push(this.get(dim, idx));
            }
            return val;
        }, listProto.getName = function(idx) {
            var rawIndex = this.getRawIndex(idx);
            return this._nameList[rawIndex] || getRawValueFromStore(this, this._nameDimIdx, rawIndex) || "";
        }, listProto.getId = function(idx) {
            return getId(this, this.getRawIndex(idx));
        }, listProto.each = function(dims, cb, context, contextCompat) {
            "use strict";
            if (this._count) {
                "function" == typeof dims && (contextCompat = context, context = cb, cb = dims, 
                dims = []), context = context || contextCompat || this;
                for (var dimSize = (dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this)).length, i = 0; i < this.count(); i++) switch (dimSize) {
                  case 0:
                    cb.call(context, i);
                    break;

                  case 1:
                    cb.call(context, this.get(dims[0], i), i);
                    break;

                  case 2:
                    cb.call(context, this.get(dims[0], i), this.get(dims[1], i), i);
                    break;

                  default:
                    for (var k = 0, value = []; k < dimSize; k++) value[k] = this.get(dims[k], i);
                    value[k] = i, cb.apply(context, value);
                }
            }
        }, listProto.filterSelf = function(dimensions, cb, context, contextCompat) {
            "use strict";
            if (this._count) {
                "function" == typeof dimensions && (contextCompat = context, context = cb, cb = dimensions, 
                dimensions = []), context = context || contextCompat || this, dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);
                for (var count = this.count(), newIndices = new (getIndicesCtor(this))(count), value = [], dimSize = dimensions.length, offset = 0, dim0 = dimensions[0], i = 0; i < count; i++) {
                    var keep, rawIdx = this.getRawIndex(i);
                    if (0 === dimSize) keep = cb.call(context, i); else if (1 === dimSize) {
                        var val = this._getFast(dim0, rawIdx);
                        keep = cb.call(context, val, i);
                    } else {
                        for (var k = 0; k < dimSize; k++) value[k] = this._getFast(dim0, rawIdx);
                        value[k] = i, keep = cb.apply(context, value);
                    }
                    keep && (newIndices[offset++] = rawIdx);
                }
                return offset < count && (this._indices = newIndices), this._count = offset, this._extent = {}, 
                this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices, 
                this;
            }
        }, listProto.selectRange = function(range) {
            "use strict";
            if (this._count) {
                var dimensions = [];
                for (var dim in range) range.hasOwnProperty(dim) && dimensions.push(dim);
                var dimSize = dimensions.length;
                if (dimSize) {
                    var originalCount = this.count(), newIndices = new (getIndicesCtor(this))(originalCount), offset = 0, dim0 = dimensions[0], min = range[dim0][0], max = range[dim0][1], quickFinished = !1;
                    if (!this._indices) {
                        var idx = 0;
                        if (1 === dimSize) {
                            for (var dimStorage = this._storage[dimensions[0]], k = 0; k < this._chunkCount; k++) for (var chunkStorage = dimStorage[k], len = Math.min(this._count - k * this._chunkSize, this._chunkSize), i = 0; i < len; i++) {
                                ((val = chunkStorage[i]) >= min && val <= max || isNaN(val)) && (newIndices[offset++] = idx), 
                                idx++;
                            }
                            quickFinished = !0;
                        } else if (2 === dimSize) {
                            dimStorage = this._storage[dim0];
                            var dimStorage2 = this._storage[dimensions[1]], min2 = range[dimensions[1]][0], max2 = range[dimensions[1]][1];
                            for (k = 0; k < this._chunkCount; k++) {
                                chunkStorage = dimStorage[k];
                                var chunkStorage2 = dimStorage2[k];
                                for (len = Math.min(this._count - k * this._chunkSize, this._chunkSize), i = 0; i < len; i++) {
                                    var val = chunkStorage[i], val2 = chunkStorage2[i];
                                    (val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2)) && (newIndices[offset++] = idx), 
                                    idx++;
                                }
                            }
                            quickFinished = !0;
                        }
                    }
                    if (!quickFinished) if (1 === dimSize) for (i = 0; i < originalCount; i++) {
                        var rawIndex = this.getRawIndex(i);
                        ((val = this._getFast(dim0, rawIndex)) >= min && val <= max || isNaN(val)) && (newIndices[offset++] = rawIndex);
                    } else for (i = 0; i < originalCount; i++) {
                        var keep = !0;
                        for (rawIndex = this.getRawIndex(i), k = 0; k < dimSize; k++) {
                            var dimk = dimensions[k];
                            ((val = this._getFast(dim, rawIndex)) < range[dimk][0] || val > range[dimk][1]) && (keep = !1);
                        }
                        keep && (newIndices[offset++] = this.getRawIndex(i));
                    }
                    return offset < originalCount && (this._indices = newIndices), this._count = offset, 
                    this._extent = {}, this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices, 
                    this;
                }
            }
        }, listProto.mapArray = function(dimensions, cb, context, contextCompat) {
            "use strict";
            "function" == typeof dimensions && (contextCompat = context, context = cb, cb = dimensions, 
            dimensions = []), context = context || contextCompat || this;
            var result = [];
            return this.each(dimensions, function() {
                result.push(cb && cb.apply(this, arguments));
            }, context), result;
        }, listProto.map = function(dimensions, cb, context, contextCompat) {
            "use strict";
            context = context || contextCompat || this;
            var list = cloneListForMapAndSample(this, dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this));
            list._indices = this._indices, list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
            for (var storage = list._storage, tmpRetValue = [], chunkSize = this._chunkSize, dimSize = dimensions.length, dataCount = this.count(), values = [], rawExtent = list._rawExtent, dataIndex = 0; dataIndex < dataCount; dataIndex++) {
                for (var dimIndex = 0; dimIndex < dimSize; dimIndex++) values[dimIndex] = this.get(dimensions[dimIndex], dataIndex);
                values[dimSize] = dataIndex;
                var retValue = cb && cb.apply(context, values);
                if (null != retValue) {
                    "object" != typeof retValue && (tmpRetValue[0] = retValue, retValue = tmpRetValue);
                    for (var rawIndex = this.getRawIndex(dataIndex), chunkIndex = Math.floor(rawIndex / chunkSize), chunkOffset = rawIndex % chunkSize, i = 0; i < retValue.length; i++) {
                        var dim = dimensions[i], val = retValue[i], rawExtentOnDim = rawExtent[dim], dimStore = storage[dim];
                        dimStore && (dimStore[chunkIndex][chunkOffset] = val), val < rawExtentOnDim[0] && (rawExtentOnDim[0] = val), 
                        val > rawExtentOnDim[1] && (rawExtentOnDim[1] = val);
                    }
                }
            }
            return list;
        }, listProto.downSample = function(dimension, rate, sampleValue, sampleIndex) {
            for (var list = cloneListForMapAndSample(this, [ dimension ]), targetStorage = list._storage, frameValues = [], frameSize = Math.floor(1 / rate), dimStore = targetStorage[dimension], len = this.count(), chunkSize = this._chunkSize, rawExtentOnDim = list._rawExtent[dimension], newIndices = new (getIndicesCtor(this))(len), offset = 0, i = 0; i < len; i += frameSize) {
                frameSize > len - i && (frameSize = len - i, frameValues.length = frameSize);
                for (var k = 0; k < frameSize; k++) {
                    var dataIdx = this.getRawIndex(i + k), originalChunkIndex = Math.floor(dataIdx / chunkSize), originalChunkOffset = dataIdx % chunkSize;
                    frameValues[k] = dimStore[originalChunkIndex][originalChunkOffset];
                }
                var value = sampleValue(frameValues), sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1)), sampleChunkOffset = sampleFrameIdx % chunkSize;
                dimStore[Math.floor(sampleFrameIdx / chunkSize)][sampleChunkOffset] = value, value < rawExtentOnDim[0] && (rawExtentOnDim[0] = value), 
                value > rawExtentOnDim[1] && (rawExtentOnDim[1] = value), newIndices[offset++] = sampleFrameIdx;
            }
            return list._count = offset, list._indices = newIndices, list.getRawIndex = getRawIndexWithIndices, 
            list;
        }, listProto.getItemModel = function(idx) {
            var hostModel = this.hostModel;
            return new Model(this.getRawDataItem(idx), hostModel, hostModel && hostModel.ecModel);
        }, listProto.diff = function(otherList) {
            var thisList = this;
            return new DataDiffer(otherList ? otherList.getIndices() : [], this.getIndices(), function(idx) {
                return getId(otherList, idx);
            }, function(idx) {
                return getId(thisList, idx);
            });
        }, listProto.getVisual = function(key) {
            var visual = this._visual;
            return visual && visual[key];
        }, listProto.setVisual = function(key, val) {
            if (isObject(key)) for (var name in key) key.hasOwnProperty(name) && this.setVisual(name, key[name]); else this._visual = this._visual || {}, 
            this._visual[key] = val;
        }, listProto.setLayout = function(key, val) {
            if (isObject(key)) for (var name in key) key.hasOwnProperty(name) && this.setLayout(name, key[name]); else this._layout[key] = val;
        }, listProto.getLayout = function(key) {
            return this._layout[key];
        }, listProto.getItemLayout = function(idx) {
            return this._itemLayouts[idx];
        }, listProto.setItemLayout = function(idx, layout, merge) {
            this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;
        }, listProto.clearItemLayouts = function() {
            this._itemLayouts.length = 0;
        }, listProto.getItemVisual = function(idx, key, ignoreParent) {
            var itemVisual = this._itemVisuals[idx], val = itemVisual && itemVisual[key];
            return null != val || ignoreParent ? val : this.getVisual(key);
        }, listProto.setItemVisual = function(idx, key, value) {
            var itemVisual = this._itemVisuals[idx] || {}, hasItemVisual = this.hasItemVisual;
            if (this._itemVisuals[idx] = itemVisual, isObject(key)) for (var name in key) key.hasOwnProperty(name) && (itemVisual[name] = key[name], 
            hasItemVisual[name] = !0); else itemVisual[key] = value, hasItemVisual[key] = !0;
        }, listProto.clearAllVisual = function() {
            this._visual = {}, this._itemVisuals = [], this.hasItemVisual = {};
        };
        var setItemDataAndSeriesIndex = function(child) {
            child.seriesIndex = this.seriesIndex, child.dataIndex = this.dataIndex, child.dataType = this.dataType;
        };
        listProto.setItemGraphicEl = function(idx, el) {
            var hostModel = this.hostModel;
            el && (el.dataIndex = idx, el.dataType = this.dataType, el.seriesIndex = hostModel && hostModel.seriesIndex, 
            "group" === el.type && el.traverse(setItemDataAndSeriesIndex, el)), this._graphicEls[idx] = el;
        }, listProto.getItemGraphicEl = function(idx) {
            return this._graphicEls[idx];
        }, listProto.eachItemGraphicEl = function(cb, context) {
            zrUtil.each(this._graphicEls, function(el, idx) {
                el && cb && cb.call(context, el, idx);
            });
        }, listProto.cloneShallow = function(list) {
            if (!list) {
                var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);
                list = new List(dimensionInfoList, this.hostModel);
            }
            if (list._storage = this._storage, transferProperties(list, this), this._indices) {
                var Ctor = this._indices.constructor;
                list._indices = new Ctor(this._indices);
            } else list._indices = null;
            return list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices, 
            list;
        }, listProto.wrapMethod = function(methodName, injectFunction) {
            var originalMethod = this[methodName];
            "function" == typeof originalMethod && (this.__wrappedMethods = this.__wrappedMethods || [], 
            this.__wrappedMethods.push(methodName), this[methodName] = function() {
                var res = originalMethod.apply(this, arguments);
                return injectFunction.apply(this, [ res ].concat(zrUtil.slice(arguments)));
            });
        }, listProto.TRANSFERABLE_METHODS = [ "cloneShallow", "downSample", "map" ], listProto.CHANGABLE_METHODS = [ "filterSelf", "selectRange" ];
        var _default = List;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(5).__DEV__;
        var zrUtil = __webpack_require__(0), OrdinalScale = __webpack_require__(236), IntervalScale = __webpack_require__(67), Scale = __webpack_require__(43), numberUtil = __webpack_require__(4), _barGrid = __webpack_require__(121), prepareLayoutBarSeries = _barGrid.prepareLayoutBarSeries, makeColumnLayout = _barGrid.makeColumnLayout, retrieveColumnLayout = _barGrid.retrieveColumnLayout, BoundingRect = __webpack_require__(12);
        function getScaleExtent(scale, model) {
            var axisDataLen, boundaryGap, span, scaleType = scale.type, min = model.getMin(), max = model.getMax(), fixMin = null != min, fixMax = null != max, originalExtent = scale.getExtent();
            "ordinal" === scaleType ? axisDataLen = model.getCategories().length : (boundaryGap = model.get("boundaryGap"), 
            zrUtil.isArray(boundaryGap) || (boundaryGap = [ boundaryGap || 0, boundaryGap || 0 ]), 
            "boolean" == typeof boundaryGap[0] && (boundaryGap = [ 0, 0 ]), boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1), 
            boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1), span = originalExtent[1] - originalExtent[0] || Math.abs(originalExtent[0])), 
            null == min && (min = "ordinal" === scaleType ? axisDataLen ? 0 : NaN : originalExtent[0] - boundaryGap[0] * span), 
            null == max && (max = "ordinal" === scaleType ? axisDataLen ? axisDataLen - 1 : NaN : originalExtent[1] + boundaryGap[1] * span), 
            "dataMin" === min ? min = originalExtent[0] : "function" == typeof min && (min = min({
                min: originalExtent[0],
                max: originalExtent[1]
            })), "dataMax" === max ? max = originalExtent[1] : "function" == typeof max && (max = max({
                min: originalExtent[0],
                max: originalExtent[1]
            })), (null == min || !isFinite(min)) && (min = NaN), (null == max || !isFinite(max)) && (max = NaN), 
            scale.setBlank(zrUtil.eqNaN(min) || zrUtil.eqNaN(max) || "ordinal" === scaleType && !scale.getOrdinalMeta().categories.length), 
            model.getNeedCrossZero() && (min > 0 && max > 0 && !fixMin && (min = 0), min < 0 && max < 0 && !fixMax && (max = 0));
            var ecModel = model.ecModel;
            if (ecModel && "time" === scaleType) {
                var isBaseAxisAndHasBarSeries, barSeriesModels = prepareLayoutBarSeries("bar", ecModel);
                if (zrUtil.each(barSeriesModels, function(seriesModel) {
                    isBaseAxisAndHasBarSeries |= seriesModel.getBaseAxis() === model.axis;
                }), isBaseAxisAndHasBarSeries) {
                    var barWidthAndOffset = makeColumnLayout(barSeriesModels), adjustedScale = function(min, max, model, barWidthAndOffset) {
                        var axisExtent = model.axis.getExtent(), axisLength = axisExtent[1] - axisExtent[0], barsOnCurrentAxis = retrieveColumnLayout(barWidthAndOffset, model.axis);
                        if (void 0 === barsOnCurrentAxis) return {
                            min: min,
                            max: max
                        };
                        var minOverflow = 1 / 0;
                        zrUtil.each(barsOnCurrentAxis, function(item) {
                            minOverflow = Math.min(item.offset, minOverflow);
                        });
                        var maxOverflow = -1 / 0;
                        zrUtil.each(barsOnCurrentAxis, function(item) {
                            maxOverflow = Math.max(item.offset + item.width, maxOverflow);
                        }), minOverflow = Math.abs(minOverflow), maxOverflow = Math.abs(maxOverflow);
                        var totalOverFlow = minOverflow + maxOverflow, oldRange = max - min, overflowBuffer = oldRange / (1 - (minOverflow + maxOverflow) / axisLength) - oldRange;
                        return {
                            min: min -= overflowBuffer * (minOverflow / totalOverFlow),
                            max: max += overflowBuffer * (maxOverflow / totalOverFlow)
                        };
                    }(min, max, model, barWidthAndOffset);
                    min = adjustedScale.min, max = adjustedScale.max;
                }
            }
            return [ min, max ];
        }
        function makeLabelFormatter(axis) {
            var labelFormatter = axis.getLabelModel().get("formatter"), categoryTickStart = "category" === axis.type ? axis.scale.getExtent()[0] : null;
            return "string" == typeof labelFormatter ? labelFormatter = function(tpl) {
                return function(val) {
                    return val = axis.scale.getLabel(val), tpl.replace("{value}", null != val ? val : "");
                };
            }(labelFormatter) : "function" == typeof labelFormatter ? function(tickValue, idx) {
                return null != categoryTickStart && (idx = tickValue - categoryTickStart), labelFormatter(getAxisRawValue(axis, tickValue), idx);
            } : function(tick) {
                return axis.scale.getLabel(tick);
            };
        }
        function getAxisRawValue(axis, value) {
            return "category" === axis.type ? axis.scale.getLabel(value) : value;
        }
        function rotateTextRect(textRect, rotate) {
            var rotateRadians = rotate * Math.PI / 180, boundingBox = textRect.plain(), beforeWidth = boundingBox.width, beforeHeight = boundingBox.height, afterWidth = beforeWidth * Math.cos(rotateRadians) + beforeHeight * Math.sin(rotateRadians), afterHeight = beforeWidth * Math.sin(rotateRadians) + beforeHeight * Math.cos(rotateRadians);
            return new BoundingRect(boundingBox.x, boundingBox.y, afterWidth, afterHeight);
        }
        function getOptionCategoryInterval(model) {
            var interval = model.get("interval");
            return null == interval ? "auto" : interval;
        }
        __webpack_require__(237), __webpack_require__(238), exports.getScaleExtent = getScaleExtent, 
        exports.niceScaleExtent = function(scale, model) {
            var extent = getScaleExtent(scale, model), fixMin = null != model.getMin(), fixMax = null != model.getMax(), splitNumber = model.get("splitNumber");
            "log" === scale.type && (scale.base = model.get("logBase"));
            var scaleType = scale.type;
            scale.setExtent(extent[0], extent[1]), scale.niceExtent({
                splitNumber: splitNumber,
                fixMin: fixMin,
                fixMax: fixMax,
                minInterval: "interval" === scaleType || "time" === scaleType ? model.get("minInterval") : null,
                maxInterval: "interval" === scaleType || "time" === scaleType ? model.get("maxInterval") : null
            });
            var interval = model.get("interval");
            null != interval && scale.setInterval && scale.setInterval(interval);
        }, exports.createScaleByModel = function(model, axisType) {
            if (axisType = axisType || model.get("type")) switch (axisType) {
              case "category":
                return new OrdinalScale(model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(), [ 1 / 0, -1 / 0 ]);

              case "value":
                return new IntervalScale();

              default:
                return (Scale.getClass(axisType) || IntervalScale).create(model);
            }
        }, exports.ifAxisCrossZero = function(axis) {
            var dataExtent = axis.scale.getExtent(), min = dataExtent[0], max = dataExtent[1];
            return !(min > 0 && max > 0 || min < 0 && max < 0);
        }, exports.makeLabelFormatter = makeLabelFormatter, exports.getAxisRawValue = getAxisRawValue, 
        exports.estimateLabelUnionRect = function(axis) {
            var axisModel = axis.model, scale = axis.scale;
            if (axisModel.get("axisLabel.show") && !scale.isBlank()) {
                var realNumberScaleTicks, tickCount, isCategory = "category" === axis.type, categoryScaleExtent = scale.getExtent();
                tickCount = isCategory ? scale.count() : (realNumberScaleTicks = scale.getTicks()).length;
                var rect, axisLabelModel = axis.getLabelModel(), labelFormatter = makeLabelFormatter(axis), step = 1;
                tickCount > 40 && (step = Math.ceil(tickCount / 40));
                for (var i = 0; i < tickCount; i += step) {
                    var label = labelFormatter(realNumberScaleTicks ? realNumberScaleTicks[i] : categoryScaleExtent[0] + i), singleRect = rotateTextRect(axisLabelModel.getTextRect(label), axisLabelModel.get("rotate") || 0);
                    rect ? rect.union(singleRect) : rect = singleRect;
                }
                return rect;
            }
        }, exports.getOptionCategoryInterval = getOptionCategoryInterval, exports.shouldShowAllLabels = function(axis) {
            return "category" === axis.type && 0 === getOptionCategoryInterval(axis.getLabelModel());
        };
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), Element = __webpack_require__(88), BoundingRect = __webpack_require__(12), Group = function(opts) {
            for (var key in opts = opts || {}, Element.call(this, opts), opts) opts.hasOwnProperty(key) && (this[key] = opts[key]);
            this._children = [], this.__storage = null, this.__dirty = !0;
        };
        Group.prototype = {
            constructor: Group,
            isGroup: !0,
            type: "group",
            silent: !1,
            children: function() {
                return this._children.slice();
            },
            childAt: function(idx) {
                return this._children[idx];
            },
            childOfName: function(name) {
                for (var children = this._children, i = 0; i < children.length; i++) if (children[i].name === name) return children[i];
            },
            childCount: function() {
                return this._children.length;
            },
            add: function(child) {
                return child && child !== this && child.parent !== this && (this._children.push(child), 
                this._doAdd(child)), this;
            },
            addBefore: function(child, nextSibling) {
                if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {
                    var children = this._children, idx = children.indexOf(nextSibling);
                    idx >= 0 && (children.splice(idx, 0, child), this._doAdd(child));
                }
                return this;
            },
            _doAdd: function(child) {
                child.parent && child.parent.remove(child), child.parent = this;
                var storage = this.__storage, zr = this.__zr;
                storage && storage !== child.__storage && (storage.addToStorage(child), child instanceof Group && child.addChildrenToStorage(storage)), 
                zr && zr.refresh();
            },
            remove: function(child) {
                var zr = this.__zr, storage = this.__storage, children = this._children, idx = zrUtil.indexOf(children, child);
                return idx < 0 ? this : (children.splice(idx, 1), child.parent = null, storage && (storage.delFromStorage(child), 
                child instanceof Group && child.delChildrenFromStorage(storage)), zr && zr.refresh(), 
                this);
            },
            removeAll: function() {
                var child, i, children = this._children, storage = this.__storage;
                for (i = 0; i < children.length; i++) child = children[i], storage && (storage.delFromStorage(child), 
                child instanceof Group && child.delChildrenFromStorage(storage)), child.parent = null;
                return children.length = 0, this;
            },
            eachChild: function(cb, context) {
                for (var children = this._children, i = 0; i < children.length; i++) {
                    var child = children[i];
                    cb.call(context, child, i);
                }
                return this;
            },
            traverse: function(cb, context) {
                for (var i = 0; i < this._children.length; i++) {
                    var child = this._children[i];
                    cb.call(context, child), "group" === child.type && child.traverse(cb, context);
                }
                return this;
            },
            addChildrenToStorage: function(storage) {
                for (var i = 0; i < this._children.length; i++) {
                    var child = this._children[i];
                    storage.addToStorage(child), child instanceof Group && child.addChildrenToStorage(storage);
                }
            },
            delChildrenFromStorage: function(storage) {
                for (var i = 0; i < this._children.length; i++) {
                    var child = this._children[i];
                    storage.delFromStorage(child), child instanceof Group && child.delChildrenFromStorage(storage);
                }
            },
            dirty: function() {
                return this.__dirty = !0, this.__zr && this.__zr.refresh(), this;
            },
            getBoundingRect: function(includeChildren) {
                for (var rect = null, tmpRect = new BoundingRect(0, 0, 0, 0), children = includeChildren || this._children, tmpMat = [], i = 0; i < children.length; i++) {
                    var child = children[i];
                    if (!child.ignore && !child.invisible) {
                        var childRect = child.getBoundingRect(), transform = child.getLocalTransform(tmpMat);
                        transform ? (tmpRect.copy(childRect), tmpRect.applyTransform(transform), (rect = rect || tmpRect.clone()).union(tmpRect)) : (rect = rect || childRect.clone()).union(childRect);
                    }
                }
                return rect || tmpRect;
            }
        }, zrUtil.inherits(Group, Element);
        var _default = Group;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var _util = __webpack_require__(0), createHashMap = _util.createHashMap, isTypedArray = _util.isTypedArray, enableClassCheck = __webpack_require__(18).enableClassCheck, _sourceType = __webpack_require__(29), SOURCE_FORMAT_ORIGINAL = _sourceType.SOURCE_FORMAT_ORIGINAL, SERIES_LAYOUT_BY_COLUMN = _sourceType.SERIES_LAYOUT_BY_COLUMN, SOURCE_FORMAT_UNKNOWN = _sourceType.SOURCE_FORMAT_UNKNOWN, SOURCE_FORMAT_TYPED_ARRAY = _sourceType.SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_KEYED_COLUMNS = _sourceType.SOURCE_FORMAT_KEYED_COLUMNS;
        function Source(fields) {
            this.fromDataset = fields.fromDataset, this.data = fields.data || (fields.sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS ? {} : []), 
            this.sourceFormat = fields.sourceFormat || SOURCE_FORMAT_UNKNOWN, this.seriesLayoutBy = fields.seriesLayoutBy || SERIES_LAYOUT_BY_COLUMN, 
            this.dimensionsDefine = fields.dimensionsDefine, this.encodeDefine = fields.encodeDefine && createHashMap(fields.encodeDefine), 
            this.startIndex = fields.startIndex || 0, this.dimensionsDetectCount = fields.dimensionsDetectCount;
        }
        Source.seriesDataToSource = function(data) {
            return new Source({
                data: data,
                sourceFormat: isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL,
                fromDataset: !1
            });
        }, enableClassCheck(Source);
        var _default = Source;
        module.exports = _default;
    }, function(module, exports) {
        exports.SOURCE_FORMAT_ORIGINAL = "original", exports.SOURCE_FORMAT_ARRAY_ROWS = "arrayRows", 
        exports.SOURCE_FORMAT_OBJECT_ROWS = "objectRows", exports.SOURCE_FORMAT_KEYED_COLUMNS = "keyedColumns", 
        exports.SOURCE_FORMAT_UNKNOWN = "unknown", exports.SOURCE_FORMAT_TYPED_ARRAY = "typedArray", 
        exports.SERIES_LAYOUT_BY_COLUMN = "column", exports.SERIES_LAYOUT_BY_ROW = "row";
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(5).__DEV__;
        var _util = __webpack_require__(0), extend = (_util.isTypedArray, _util.extend), each = (_util.assert, 
        _util.each), isObject = _util.isObject, _model = __webpack_require__(3), getDataItemValue = _model.getDataItemValue, isDataItemOption = _model.isDataItemOption, parseDate = __webpack_require__(4).parseDate, Source = __webpack_require__(28), _sourceType = __webpack_require__(29), SOURCE_FORMAT_TYPED_ARRAY = _sourceType.SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ARRAY_ROWS = _sourceType.SOURCE_FORMAT_ARRAY_ROWS, SOURCE_FORMAT_ORIGINAL = _sourceType.SOURCE_FORMAT_ORIGINAL, SOURCE_FORMAT_OBJECT_ROWS = _sourceType.SOURCE_FORMAT_OBJECT_ROWS;
        function DefaultDataProvider(source, dimSize) {
            Source.isInstance(source) || (source = Source.seriesDataToSource(source)), this._source = source;
            var data = this._data = source.data, sourceFormat = source.sourceFormat;
            sourceFormat === SOURCE_FORMAT_TYPED_ARRAY && (this._offset = 0, this._dimSize = dimSize, 
            this._data = data);
            var methods = providerMethods[sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + "_" + source.seriesLayoutBy : sourceFormat];
            extend(this, methods);
        }
        var providerProto = DefaultDataProvider.prototype;
        providerProto.pure = !1, providerProto.persistent = !0, providerProto.getSource = function() {
            return this._source;
        };
        var providerMethods = {
            arrayRows_column: {
                pure: !0,
                count: function() {
                    return Math.max(0, this._data.length - this._source.startIndex);
                },
                getItem: function(idx) {
                    return this._data[idx + this._source.startIndex];
                },
                appendData: appendDataSimply
            },
            arrayRows_row: {
                pure: !0,
                count: function() {
                    var row = this._data[0];
                    return row ? Math.max(0, row.length - this._source.startIndex) : 0;
                },
                getItem: function(idx) {
                    idx += this._source.startIndex;
                    for (var item = [], data = this._data, i = 0; i < data.length; i++) {
                        var row = data[i];
                        item.push(row ? row[idx] : null);
                    }
                    return item;
                },
                appendData: function() {
                    throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
                }
            },
            objectRows: {
                pure: !0,
                count: countSimply,
                getItem: getItemSimply,
                appendData: appendDataSimply
            },
            keyedColumns: {
                pure: !0,
                count: function() {
                    var dimName = this._source.dimensionsDefine[0].name, col = this._data[dimName];
                    return col ? col.length : 0;
                },
                getItem: function(idx) {
                    for (var item = [], dims = this._source.dimensionsDefine, i = 0; i < dims.length; i++) {
                        var col = this._data[dims[i].name];
                        item.push(col ? col[idx] : null);
                    }
                    return item;
                },
                appendData: function(newData) {
                    var data = this._data;
                    each(newData, function(newCol, key) {
                        for (var oldCol = data[key] || (data[key] = []), i = 0; i < (newCol || []).length; i++) oldCol.push(newCol[i]);
                    });
                }
            },
            original: {
                count: countSimply,
                getItem: getItemSimply,
                appendData: appendDataSimply
            },
            typedArray: {
                persistent: !1,
                pure: !0,
                count: function() {
                    return this._data ? this._data.length / this._dimSize : 0;
                },
                getItem: function(idx, out) {
                    idx -= this._offset, out = out || [];
                    for (var offset = this._dimSize * idx, i = 0; i < this._dimSize; i++) out[i] = this._data[offset + i];
                    return out;
                },
                appendData: function(newData) {
                    this._data = newData;
                },
                clean: function() {
                    this._offset += this.count(), this._data = null;
                }
            }
        };
        function countSimply() {
            return this._data.length;
        }
        function getItemSimply(idx) {
            return this._data[idx];
        }
        function appendDataSimply(newData) {
            for (var i = 0; i < newData.length; i++) this._data.push(newData[i]);
        }
        var rawValueGetters = {
            arrayRows: getRawValueSimply,
            objectRows: function(dataItem, dataIndex, dimIndex, dimName) {
                return null != dimIndex ? dataItem[dimName] : dataItem;
            },
            keyedColumns: getRawValueSimply,
            original: function(dataItem, dataIndex, dimIndex, dimName) {
                var value = getDataItemValue(dataItem);
                return null != dimIndex && value instanceof Array ? value[dimIndex] : value;
            },
            typedArray: getRawValueSimply
        };
        function getRawValueSimply(dataItem, dataIndex, dimIndex, dimName) {
            return null != dimIndex ? dataItem[dimIndex] : dataItem;
        }
        var defaultDimValueGetters = {
            arrayRows: getDimValueSimply,
            objectRows: function(dataItem, dimName, dataIndex, dimIndex) {
                return converDataValue(dataItem[dimName], this._dimensionInfos[dimName]);
            },
            keyedColumns: getDimValueSimply,
            original: function(dataItem, dimName, dataIndex, dimIndex) {
                var value = dataItem && (null == dataItem.value ? dataItem : dataItem.value);
                return !this._rawData.pure && isDataItemOption(dataItem) && (this.hasItemOption = !0), 
                converDataValue(value instanceof Array ? value[dimIndex] : value, this._dimensionInfos[dimName]);
            },
            typedArray: function(dataItem, dimName, dataIndex, dimIndex) {
                return dataItem[dimIndex];
            }
        };
        function getDimValueSimply(dataItem, dimName, dataIndex, dimIndex) {
            return converDataValue(dataItem[dimIndex], this._dimensionInfos[dimName]);
        }
        function converDataValue(value, dimInfo) {
            var dimType = dimInfo && dimInfo.type;
            if ("ordinal" === dimType) {
                var ordinalMeta = dimInfo && dimInfo.ordinalMeta;
                return ordinalMeta ? ordinalMeta.parseAndCollect(value) : value;
            }
            return "time" === dimType && "number" != typeof value && null != value && "-" !== value && (value = +parseDate(value)), 
            null == value || "" === value ? NaN : +value;
        }
        exports.DefaultDataProvider = DefaultDataProvider, exports.defaultDimValueGetters = defaultDimValueGetters, 
        exports.retrieveRawValue = function(data, dataIndex, dim) {
            if (data) {
                var dataItem = data.getRawDataItem(dataIndex);
                if (null != dataItem) {
                    var dimName, dimIndex, sourceFormat = data.getProvider().getSource().sourceFormat, dimInfo = data.getDimensionInfo(dim);
                    return dimInfo && (dimName = dimInfo.name, dimIndex = dimInfo.index), rawValueGetters[sourceFormat](dataItem, dataIndex, dimIndex, dimName);
                }
            }
        }, exports.retrieveRawAttr = function(data, dataIndex, attr) {
            if (data) {
                var sourceFormat = data.getProvider().getSource().sourceFormat;
                if (sourceFormat === SOURCE_FORMAT_ORIGINAL || sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
                    var dataItem = data.getRawDataItem(dataIndex);
                    return sourceFormat !== SOURCE_FORMAT_ORIGINAL || isObject(dataItem) || (dataItem = null), 
                    dataItem ? dataItem[attr] : void 0;
                }
            }
        };
    }, function(module, exports) {
        var ORIGIN_METHOD = "\0__throttleOriginMethod", RATE = "\0__throttleRate", THROTTLE_TYPE = "\0__throttleType";
        function throttle(fn, delay, debounce) {
            var currCall, diff, scope, args, debounceNextCall, lastCall = 0, lastExec = 0, timer = null;
            function exec() {
                lastExec = new Date().getTime(), timer = null, fn.apply(scope, args || []);
            }
            delay = delay || 0;
            var cb = function() {
                currCall = new Date().getTime(), scope = this, args = arguments;
                var thisDelay = debounceNextCall || delay, thisDebounce = debounceNextCall || debounce;
                debounceNextCall = null, diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay, 
                clearTimeout(timer), thisDebounce ? timer = setTimeout(exec, thisDelay) : diff >= 0 ? exec() : timer = setTimeout(exec, -diff), 
                lastCall = currCall;
            };
            return cb.clear = function() {
                timer && (clearTimeout(timer), timer = null);
            }, cb.debounceNextCall = function(debounceDelay) {
                debounceNextCall = debounceDelay;
            }, cb;
        }
        exports.throttle = throttle, exports.createOrUpdate = function(obj, fnAttr, rate, throttleType) {
            var fn = obj[fnAttr];
            if (fn) {
                var originFn = fn[ORIGIN_METHOD] || fn, lastThrottleType = fn[THROTTLE_TYPE];
                if (fn[RATE] !== rate || lastThrottleType !== throttleType) {
                    if (null == rate || !throttleType) return obj[fnAttr] = originFn;
                    (fn = obj[fnAttr] = throttle(originFn, rate, "debounce" === throttleType))[ORIGIN_METHOD] = originFn, 
                    fn[THROTTLE_TYPE] = throttleType, fn[RATE] = rate;
                }
                return fn;
            }
        }, exports.clear = function(obj, fnAttr) {
            var fn = obj[fnAttr];
            fn && fn[ORIGIN_METHOD] && (obj[fnAttr] = fn[ORIGIN_METHOD]);
        };
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), List = __webpack_require__(25), createDimensions = __webpack_require__(117), SOURCE_FORMAT_ORIGINAL = __webpack_require__(29).SOURCE_FORMAT_ORIGINAL, getDimensionTypeByAxis = __webpack_require__(66).getDimensionTypeByAxis, getDataItemValue = __webpack_require__(3).getDataItemValue, CoordinateSystem = __webpack_require__(41), getCoordSysDefineBySeries = __webpack_require__(113).getCoordSysDefineBySeries, Source = __webpack_require__(28), enableDataStack = __webpack_require__(19).enableDataStack;
        var _default = function(source, seriesModel, opt) {
            opt = opt || {}, Source.isInstance(source) || (source = Source.seriesDataToSource(source));
            var coordSysDimDefs, coordSysName = seriesModel.get("coordinateSystem"), registeredCoordSys = CoordinateSystem.get(coordSysName), coordSysDefine = getCoordSysDefineBySeries(seriesModel);
            coordSysDefine && (coordSysDimDefs = zrUtil.map(coordSysDefine.coordSysDims, function(dim) {
                var dimInfo = {
                    name: dim
                }, axisModel = coordSysDefine.axisMap.get(dim);
                if (axisModel) {
                    var axisType = axisModel.get("type");
                    dimInfo.type = getDimensionTypeByAxis(axisType);
                }
                return dimInfo;
            })), coordSysDimDefs || (coordSysDimDefs = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || [ "x", "y" ]);
            var firstCategoryDimIndex, hasNameEncode, dimInfoList = createDimensions(source, {
                coordDimensions: coordSysDimDefs,
                generateCoord: opt.generateCoord
            });
            coordSysDefine && zrUtil.each(dimInfoList, function(dimInfo, dimIndex) {
                var coordDim = dimInfo.coordDim, categoryAxisModel = coordSysDefine.categoryAxisMap.get(coordDim);
                categoryAxisModel && (null == firstCategoryDimIndex && (firstCategoryDimIndex = dimIndex), 
                dimInfo.ordinalMeta = categoryAxisModel.getOrdinalMeta()), null != dimInfo.otherDims.itemName && (hasNameEncode = !0);
            }), hasNameEncode || null == firstCategoryDimIndex || (dimInfoList[firstCategoryDimIndex].otherDims.itemName = 0);
            var stackCalculationInfo = enableDataStack(seriesModel, dimInfoList), list = new List(dimInfoList, seriesModel);
            list.setCalculationInfo(stackCalculationInfo);
            var dimValueGetter = null != firstCategoryDimIndex && function(source) {
                if (source.sourceFormat === SOURCE_FORMAT_ORIGINAL) {
                    var sampleItem = function(data) {
                        for (var i = 0; i < data.length && null == data[i]; ) i++;
                        return data[i];
                    }(source.data || []);
                    return null != sampleItem && !zrUtil.isArray(getDataItemValue(sampleItem));
                }
            }(source) ? function(itemOpt, dimName, dataIndex, dimIndex) {
                return dimIndex === firstCategoryDimIndex ? dataIndex : this.defaultDimValueGetter(itemOpt, dimName, dataIndex, dimIndex);
            } : null;
            return list.hasItemOption = !1, list.initData(source, null, dimValueGetter), list;
        };
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var map = __webpack_require__(0).map, createRenderPlanner = __webpack_require__(42), isDimensionStacked = __webpack_require__(19).isDimensionStacked;
        module.exports = function(seriesType) {
            return {
                seriesType: seriesType,
                plan: createRenderPlanner(),
                reset: function(seriesModel) {
                    var data = seriesModel.getData(), coordSys = seriesModel.coordinateSystem, isLargeRender = seriesModel.pipelineContext.large;
                    if (coordSys) {
                        var dims = map(coordSys.dimensions, function(dim) {
                            return data.mapDimension(dim);
                        }).slice(0, 2), dimLen = dims.length, stackResultDim = data.getCalculationInfo("stackResultDimension");
                        return isDimensionStacked(data, dims[0]) && (dims[0] = stackResultDim), isDimensionStacked(data, dims[1]) && (dims[1] = stackResultDim), 
                        dimLen && {
                            progress: function(params, data) {
                                for (var segCount = params.end - params.start, points = isLargeRender && new Float32Array(segCount * dimLen), i = params.start, offset = 0, tmpIn = [], tmpOut = []; i < params.end; i++) {
                                    var point;
                                    if (1 === dimLen) {
                                        var x = data.get(dims[0], i);
                                        point = !isNaN(x) && coordSys.dataToPoint(x, null, tmpOut);
                                    } else {
                                        x = tmpIn[0] = data.get(dims[0], i);
                                        var y = tmpIn[1] = data.get(dims[1], i);
                                        point = !isNaN(x) && !isNaN(y) && coordSys.dataToPoint(tmpIn, null, tmpOut);
                                    }
                                    isLargeRender ? (points[offset++] = point ? point[0] : NaN, points[offset++] = point ? point[1] : NaN) : data.setItemLayout(i, point && point.slice() || [ NaN, NaN ]);
                                }
                                isLargeRender && data.setLayout("symbolPoints", points);
                            }
                        };
                    }
                }
            };
        };
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), zrColor = __webpack_require__(20), linearMap = __webpack_require__(4).linearMap, each = zrUtil.each, isObject = zrUtil.isObject, CATEGORY_DEFAULT_VISUAL_INDEX = -1, VisualMapping = function(option) {
            var mappingMethod = option.mappingMethod, visualType = option.type, thisOption = this.option = zrUtil.clone(option);
            this.type = visualType, this.mappingMethod = mappingMethod, this._normalizeData = normalizers[mappingMethod];
            var visualHandler = visualHandlers[visualType];
            this.applyVisual = visualHandler.applyVisual, this.getColorMapper = visualHandler.getColorMapper, 
            this._doMap = visualHandler._doMap[mappingMethod], "piecewise" === mappingMethod ? (normalizeVisualRange(thisOption), 
            function(thisOption) {
                var pieceList = thisOption.pieceList;
                thisOption.hasSpecialVisual = !1, zrUtil.each(pieceList, function(piece, index) {
                    piece.originIndex = index, null != piece.visual && (thisOption.hasSpecialVisual = !0);
                });
            }(thisOption)) : "category" === mappingMethod ? thisOption.categories ? function(thisOption) {
                var categories = thisOption.categories, visual = thisOption.visual, categoryMap = thisOption.categoryMap = {};
                if (each(categories, function(cate, index) {
                    categoryMap[cate] = index;
                }), !zrUtil.isArray(visual)) {
                    var visualArr = [];
                    zrUtil.isObject(visual) ? each(visual, function(v, cate) {
                        var index = categoryMap[cate];
                        visualArr[null != index ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;
                    }) : visualArr[CATEGORY_DEFAULT_VISUAL_INDEX] = visual, visual = setVisualToOption(thisOption, visualArr);
                }
                for (var i = categories.length - 1; i >= 0; i--) null == visual[i] && (delete categoryMap[categories[i]], 
                categories.pop());
            }(thisOption) : normalizeVisualRange(thisOption, !0) : (zrUtil.assert("linear" !== mappingMethod || thisOption.dataExtent), 
            normalizeVisualRange(thisOption));
        };
        VisualMapping.prototype = {
            constructor: VisualMapping,
            mapValueToVisual: function(value) {
                var normalized = this._normalizeData(value);
                return this._doMap(normalized, value);
            },
            getNormalizer: function() {
                return zrUtil.bind(this._normalizeData, this);
            }
        };
        var visualHandlers = VisualMapping.visualHandlers = {
            color: {
                applyVisual: makeApplyVisual("color"),
                getColorMapper: function() {
                    var thisOption = this.option;
                    return zrUtil.bind("category" === thisOption.mappingMethod ? function(value, isNormalized) {
                        return !isNormalized && (value = this._normalizeData(value)), doMapCategory.call(this, value);
                    } : function(value, isNormalized, out) {
                        var returnRGBArray = !!out;
                        return !isNormalized && (value = this._normalizeData(value)), out = zrColor.fastLerp(value, thisOption.parsedVisual, out), 
                        returnRGBArray ? out : zrColor.stringify(out, "rgba");
                    }, this);
                },
                _doMap: {
                    linear: function(normalized) {
                        return zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), "rgba");
                    },
                    category: doMapCategory,
                    piecewise: function(normalized, value) {
                        var result = getSpecifiedVisual.call(this, value);
                        return null == result && (result = zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), "rgba")), 
                        result;
                    },
                    fixed: doMapFixed
                }
            },
            colorHue: makePartialColorVisualHandler(function(color, value) {
                return zrColor.modifyHSL(color, value);
            }),
            colorSaturation: makePartialColorVisualHandler(function(color, value) {
                return zrColor.modifyHSL(color, null, value);
            }),
            colorLightness: makePartialColorVisualHandler(function(color, value) {
                return zrColor.modifyHSL(color, null, null, value);
            }),
            colorAlpha: makePartialColorVisualHandler(function(color, value) {
                return zrColor.modifyAlpha(color, value);
            }),
            opacity: {
                applyVisual: makeApplyVisual("opacity"),
                _doMap: makeDoMap([ 0, 1 ])
            },
            liftZ: {
                applyVisual: makeApplyVisual("liftZ"),
                _doMap: {
                    linear: doMapFixed,
                    category: doMapFixed,
                    piecewise: doMapFixed,
                    fixed: doMapFixed
                }
            },
            symbol: {
                applyVisual: function(value, getter, setter) {
                    var symbolCfg = this.mapValueToVisual(value);
                    if (zrUtil.isString(symbolCfg)) setter("symbol", symbolCfg); else if (isObject(symbolCfg)) for (var name in symbolCfg) symbolCfg.hasOwnProperty(name) && setter(name, symbolCfg[name]);
                },
                _doMap: {
                    linear: doMapToArray,
                    category: doMapCategory,
                    piecewise: function(normalized, value) {
                        var result = getSpecifiedVisual.call(this, value);
                        return null == result && (result = doMapToArray.call(this, normalized)), result;
                    },
                    fixed: doMapFixed
                }
            },
            symbolSize: {
                applyVisual: makeApplyVisual("symbolSize"),
                _doMap: makeDoMap([ 0, 1 ])
            }
        };
        function normalizeVisualRange(thisOption, isCategory) {
            var visual = thisOption.visual, visualArr = [];
            zrUtil.isObject(visual) ? each(visual, function(v) {
                visualArr.push(v);
            }) : null != visual && visualArr.push(visual);
            isCategory || 1 !== visualArr.length || {
                color: 1,
                symbol: 1
            }.hasOwnProperty(thisOption.type) || (visualArr[1] = visualArr[0]), setVisualToOption(thisOption, visualArr);
        }
        function makePartialColorVisualHandler(applyValue) {
            return {
                applyVisual: function(value, getter, setter) {
                    value = this.mapValueToVisual(value), setter("color", applyValue(getter("color"), value));
                },
                _doMap: makeDoMap([ 0, 1 ])
            };
        }
        function doMapToArray(normalized) {
            var visual = this.option.visual;
            return visual[Math.round(linearMap(normalized, [ 0, 1 ], [ 0, visual.length - 1 ], !0))] || {};
        }
        function makeApplyVisual(visualType) {
            return function(value, getter, setter) {
                setter(visualType, this.mapValueToVisual(value));
            };
        }
        function doMapCategory(normalized) {
            var visual = this.option.visual;
            return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];
        }
        function doMapFixed() {
            return this.option.visual[0];
        }
        function makeDoMap(sourceExtent) {
            return {
                linear: function(normalized) {
                    return linearMap(normalized, sourceExtent, this.option.visual, !0);
                },
                category: doMapCategory,
                piecewise: function(normalized, value) {
                    var result = getSpecifiedVisual.call(this, value);
                    return null == result && (result = linearMap(normalized, sourceExtent, this.option.visual, !0)), 
                    result;
                },
                fixed: doMapFixed
            };
        }
        function getSpecifiedVisual(value) {
            var thisOption = this.option, pieceList = thisOption.pieceList;
            if (thisOption.hasSpecialVisual) {
                var piece = pieceList[VisualMapping.findPieceIndex(value, pieceList)];
                if (piece && piece.visual) return piece.visual[this.type];
            }
        }
        function setVisualToOption(thisOption, visualArr) {
            return thisOption.visual = visualArr, "color" === thisOption.type && (thisOption.parsedVisual = zrUtil.map(visualArr, function(item) {
                return zrColor.parse(item);
            })), visualArr;
        }
        var normalizers = {
            linear: function(value) {
                return linearMap(value, this.option.dataExtent, [ 0, 1 ], !0);
            },
            piecewise: function(value) {
                var pieceList = this.option.pieceList, pieceIndex = VisualMapping.findPieceIndex(value, pieceList, !0);
                if (null != pieceIndex) return linearMap(pieceIndex, [ 0, pieceList.length - 1 ], [ 0, 1 ], !0);
            },
            category: function(value) {
                var index = this.option.categories ? this.option.categoryMap[value] : value;
                return null == index ? CATEGORY_DEFAULT_VISUAL_INDEX : index;
            },
            fixed: zrUtil.noop
        };
        function littleThan(close, a, b) {
            return close ? a <= b : a < b;
        }
        VisualMapping.listVisualTypes = function() {
            var visualTypes = [];
            return zrUtil.each(visualHandlers, function(handler, key) {
                visualTypes.push(key);
            }), visualTypes;
        }, VisualMapping.addVisualHandler = function(name, handler) {
            visualHandlers[name] = handler;
        }, VisualMapping.isValidType = function(visualType) {
            return visualHandlers.hasOwnProperty(visualType);
        }, VisualMapping.eachVisual = function(visual, callback, context) {
            zrUtil.isObject(visual) ? zrUtil.each(visual, callback, context) : callback.call(context, visual);
        }, VisualMapping.mapVisual = function(visual, callback, context) {
            var isPrimary, newVisual = zrUtil.isArray(visual) ? [] : zrUtil.isObject(visual) ? {} : (isPrimary = !0, 
            null);
            return VisualMapping.eachVisual(visual, function(v, key) {
                var newVal = callback.call(context, v, key);
                isPrimary ? newVisual = newVal : newVisual[key] = newVal;
            }), newVisual;
        }, VisualMapping.retrieveVisuals = function(obj) {
            var hasVisual, ret = {};
            return obj && each(visualHandlers, function(h, visualType) {
                obj.hasOwnProperty(visualType) && (ret[visualType] = obj[visualType], hasVisual = !0);
            }), hasVisual ? ret : null;
        }, VisualMapping.prepareVisualTypes = function(visualTypes) {
            if (isObject(visualTypes)) {
                var types = [];
                each(visualTypes, function(item, type) {
                    types.push(type);
                }), visualTypes = types;
            } else {
                if (!zrUtil.isArray(visualTypes)) return [];
                visualTypes = visualTypes.slice();
            }
            return visualTypes.sort(function(type1, type2) {
                return "color" === type2 && "color" !== type1 && 0 === type1.indexOf("color") ? 1 : -1;
            }), visualTypes;
        }, VisualMapping.dependsOn = function(visualType1, visualType2) {
            return "color" === visualType2 ? !(!visualType1 || 0 !== visualType1.indexOf(visualType2)) : visualType1 === visualType2;
        }, VisualMapping.findPieceIndex = function(value, pieceList, findClosestWhenOutside) {
            for (var possibleI, abs = 1 / 0, i = 0, len = pieceList.length; i < len; i++) {
                var pieceValue = pieceList[i].value;
                if (null != pieceValue) {
                    if (pieceValue === value || "string" == typeof pieceValue && pieceValue === value + "") return i;
                    findClosestWhenOutside && updatePossible(pieceValue, i);
                }
            }
            for (i = 0, len = pieceList.length; i < len; i++) {
                var piece = pieceList[i], interval = piece.interval, close = piece.close;
                if (interval) {
                    if (interval[0] === -1 / 0) {
                        if (littleThan(close[1], value, interval[1])) return i;
                    } else if (interval[1] === 1 / 0) {
                        if (littleThan(close[0], interval[0], value)) return i;
                    } else if (littleThan(close[0], interval[0], value) && littleThan(close[1], value, interval[1])) return i;
                    findClosestWhenOutside && updatePossible(interval[0], i), findClosestWhenOutside && updatePossible(interval[1], i);
                }
            }
            if (findClosestWhenOutside) return value === 1 / 0 ? pieceList.length - 1 : value === -1 / 0 ? 0 : possibleI;
            function updatePossible(val, index) {
                var newAbs = Math.abs(val - value);
                newAbs < abs && (abs = newAbs, possibleI = index);
            }
        };
        var _default = VisualMapping;
        module.exports = _default;
    }, function(module, exports) {
        var dpr = 1;
        "undefined" != typeof window && (dpr = Math.max(window.devicePixelRatio || 1, 1));
        var devicePixelRatio = dpr;
        exports.debugMode = 0, exports.devicePixelRatio = devicePixelRatio;
    }, function(module, exports) {
        exports.ContextCachedBy = {
            NONE: 0,
            STYLE_BIND: 1,
            PLAIN_TEXT: 2
        }, exports.WILL_BE_RESTORED = 9;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), Style = __webpack_require__(54), Element = __webpack_require__(88), RectText = __webpack_require__(198);
        function Displayable(opts) {
            for (var name in opts = opts || {}, Element.call(this, opts), opts) opts.hasOwnProperty(name) && "style" !== name && (this[name] = opts[name]);
            this.style = new Style(opts.style, this), this._rect = null, this.__clipPaths = null;
        }
        Displayable.prototype = {
            constructor: Displayable,
            type: "displayable",
            __dirty: !0,
            invisible: !1,
            z: 0,
            z2: 0,
            zlevel: 0,
            draggable: !1,
            dragging: !1,
            silent: !1,
            culling: !1,
            cursor: "pointer",
            rectHover: !1,
            progressive: !1,
            incremental: !1,
            globalScaleRatio: 1,
            beforeBrush: function(ctx) {},
            afterBrush: function(ctx) {},
            brush: function(ctx, prevEl) {},
            getBoundingRect: function() {},
            contain: function(x, y) {
                return this.rectContain(x, y);
            },
            traverse: function(cb, context) {
                cb.call(context, this);
            },
            rectContain: function(x, y) {
                var coord = this.transformCoordToLocal(x, y);
                return this.getBoundingRect().contain(coord[0], coord[1]);
            },
            dirty: function() {
                this.__dirty = this.__dirtyText = !0, this._rect = null, this.__zr && this.__zr.refresh();
            },
            animateStyle: function(loop) {
                return this.animate("style", loop);
            },
            attrKV: function(key, value) {
                "style" !== key ? Element.prototype.attrKV.call(this, key, value) : this.style.set(value);
            },
            setStyle: function(key, value) {
                return this.style.set(key, value), this.dirty(!1), this;
            },
            useStyle: function(obj) {
                return this.style = new Style(obj, this), this.dirty(!1), this;
            },
            calculateTextPosition: null
        }, zrUtil.inherits(Displayable, Element), zrUtil.mixin(Displayable, RectText);
        var _default = Displayable;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var curve = __webpack_require__(22), vec2 = __webpack_require__(6), bbox = __webpack_require__(100), BoundingRect = __webpack_require__(12), dpr = __webpack_require__(35).devicePixelRatio, CMD = {
            M: 1,
            L: 2,
            C: 3,
            Q: 4,
            A: 5,
            Z: 6,
            R: 7
        }, min = [], max = [], min2 = [], max2 = [], mathMin = Math.min, mathMax = Math.max, mathCos = Math.cos, mathSin = Math.sin, mathSqrt = Math.sqrt, mathAbs = Math.abs, hasTypedArray = "undefined" != typeof Float32Array, PathProxy = function(notSaveData) {
            this._saveData = !notSaveData, this._saveData && (this.data = []), this._ctx = null;
        };
        PathProxy.prototype = {
            constructor: PathProxy,
            _xi: 0,
            _yi: 0,
            _x0: 0,
            _y0: 0,
            _ux: 0,
            _uy: 0,
            _len: 0,
            _lineDash: null,
            _dashOffset: 0,
            _dashIdx: 0,
            _dashSum: 0,
            setScale: function(sx, sy, segmentIgnoreThreshold) {
                segmentIgnoreThreshold = segmentIgnoreThreshold || 0, this._ux = mathAbs(segmentIgnoreThreshold / dpr / sx) || 0, 
                this._uy = mathAbs(segmentIgnoreThreshold / dpr / sy) || 0;
            },
            getContext: function() {
                return this._ctx;
            },
            beginPath: function(ctx) {
                return this._ctx = ctx, ctx && ctx.beginPath(), ctx && (this.dpr = ctx.dpr), this._saveData && (this._len = 0), 
                this._lineDash && (this._lineDash = null, this._dashOffset = 0), this;
            },
            moveTo: function(x, y) {
                return this.addData(CMD.M, x, y), this._ctx && this._ctx.moveTo(x, y), this._x0 = x, 
                this._y0 = y, this._xi = x, this._yi = y, this;
            },
            lineTo: function(x, y) {
                var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy || this._len < 5;
                return this.addData(CMD.L, x, y), this._ctx && exceedUnit && (this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y)), 
                exceedUnit && (this._xi = x, this._yi = y), this;
            },
            bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
                return this.addData(CMD.C, x1, y1, x2, y2, x3, y3), this._ctx && (this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3)), 
                this._xi = x3, this._yi = y3, this;
            },
            quadraticCurveTo: function(x1, y1, x2, y2) {
                return this.addData(CMD.Q, x1, y1, x2, y2), this._ctx && (this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2)), 
                this._xi = x2, this._yi = y2, this;
            },
            arc: function(cx, cy, r, startAngle, endAngle, anticlockwise) {
                return this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1), 
                this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise), this._xi = mathCos(endAngle) * r + cx, 
                this._yi = mathSin(endAngle) * r + cy, this;
            },
            arcTo: function(x1, y1, x2, y2, radius) {
                return this._ctx && this._ctx.arcTo(x1, y1, x2, y2, radius), this;
            },
            rect: function(x, y, w, h) {
                return this._ctx && this._ctx.rect(x, y, w, h), this.addData(CMD.R, x, y, w, h), 
                this;
            },
            closePath: function() {
                this.addData(CMD.Z);
                var ctx = this._ctx, x0 = this._x0, y0 = this._y0;
                return ctx && (this._needsDash() && this._dashedLineTo(x0, y0), ctx.closePath()), 
                this._xi = x0, this._yi = y0, this;
            },
            fill: function(ctx) {
                ctx && ctx.fill(), this.toStatic();
            },
            stroke: function(ctx) {
                ctx && ctx.stroke(), this.toStatic();
            },
            setLineDash: function(lineDash) {
                if (lineDash instanceof Array) {
                    this._lineDash = lineDash, this._dashIdx = 0;
                    for (var lineDashSum = 0, i = 0; i < lineDash.length; i++) lineDashSum += lineDash[i];
                    this._dashSum = lineDashSum;
                }
                return this;
            },
            setLineDashOffset: function(offset) {
                return this._dashOffset = offset, this;
            },
            len: function() {
                return this._len;
            },
            setData: function(data) {
                var len = data.length;
                this.data && this.data.length === len || !hasTypedArray || (this.data = new Float32Array(len));
                for (var i = 0; i < len; i++) this.data[i] = data[i];
                this._len = len;
            },
            appendPath: function(path) {
                path instanceof Array || (path = [ path ]);
                for (var len = path.length, appendSize = 0, offset = this._len, i = 0; i < len; i++) appendSize += path[i].len();
                hasTypedArray && this.data instanceof Float32Array && (this.data = new Float32Array(offset + appendSize));
                for (i = 0; i < len; i++) for (var appendPathData = path[i].data, k = 0; k < appendPathData.length; k++) this.data[offset++] = appendPathData[k];
                this._len = offset;
            },
            addData: function(cmd) {
                if (this._saveData) {
                    var data = this.data;
                    this._len + arguments.length > data.length && (this._expandData(), data = this.data);
                    for (var i = 0; i < arguments.length; i++) data[this._len++] = arguments[i];
                    this._prevCmd = cmd;
                }
            },
            _expandData: function() {
                if (!(this.data instanceof Array)) {
                    for (var newData = [], i = 0; i < this._len; i++) newData[i] = this.data[i];
                    this.data = newData;
                }
            },
            _needsDash: function() {
                return this._lineDash;
            },
            _dashedLineTo: function(x1, y1) {
                var dash, idx, dashSum = this._dashSum, offset = this._dashOffset, lineDash = this._lineDash, ctx = this._ctx, x0 = this._xi, y0 = this._yi, dx = x1 - x0, dy = y1 - y0, dist = mathSqrt(dx * dx + dy * dy), x = x0, y = y0, nDash = lineDash.length;
                for (dx /= dist, dy /= dist, offset < 0 && (offset = dashSum + offset), x -= (offset %= dashSum) * dx, 
                y -= offset * dy; dx > 0 && x <= x1 || dx < 0 && x >= x1 || 0 === dx && (dy > 0 && y <= y1 || dy < 0 && y >= y1); ) x += dx * (dash = lineDash[idx = this._dashIdx]), 
                y += dy * dash, this._dashIdx = (idx + 1) % nDash, dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0 || ctx[idx % 2 ? "moveTo" : "lineTo"](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));
                dx = x - x1, dy = y - y1, this._dashOffset = -mathSqrt(dx * dx + dy * dy);
            },
            _dashedBezierTo: function(x1, y1, x2, y2, x3, y3) {
                var t, dx, dy, x, y, dashSum = this._dashSum, offset = this._dashOffset, lineDash = this._lineDash, ctx = this._ctx, x0 = this._xi, y0 = this._yi, cubicAt = curve.cubicAt, bezierLen = 0, idx = this._dashIdx, nDash = lineDash.length, tmpLen = 0;
                for (offset < 0 && (offset = dashSum + offset), offset %= dashSum, t = 0; t < 1; t += .1) dx = cubicAt(x0, x1, x2, x3, t + .1) - cubicAt(x0, x1, x2, x3, t), 
                dy = cubicAt(y0, y1, y2, y3, t + .1) - cubicAt(y0, y1, y2, y3, t), bezierLen += mathSqrt(dx * dx + dy * dy);
                for (;idx < nDash && !((tmpLen += lineDash[idx]) > offset); idx++) ;
                for (t = (tmpLen - offset) / bezierLen; t <= 1; ) x = cubicAt(x0, x1, x2, x3, t), 
                y = cubicAt(y0, y1, y2, y3, t), idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y), t += lineDash[idx] / bezierLen, 
                idx = (idx + 1) % nDash;
                idx % 2 != 0 && ctx.lineTo(x3, y3), dx = x3 - x, dy = y3 - y, this._dashOffset = -mathSqrt(dx * dx + dy * dy);
            },
            _dashedQuadraticTo: function(x1, y1, x2, y2) {
                var x3 = x2, y3 = y2;
                x2 = (x2 + 2 * x1) / 3, y2 = (y2 + 2 * y1) / 3, x1 = (this._xi + 2 * x1) / 3, y1 = (this._yi + 2 * y1) / 3, 
                this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
            },
            toStatic: function() {
                var data = this.data;
                data instanceof Array && (data.length = this._len, hasTypedArray && (this.data = new Float32Array(data)));
            },
            getBoundingRect: function() {
                min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE, max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
                for (var data = this.data, xi = 0, yi = 0, x0 = 0, y0 = 0, i = 0; i < data.length; ) {
                    var cmd = data[i++];
                    switch (1 === i && (x0 = xi = data[i], y0 = yi = data[i + 1]), cmd) {
                      case CMD.M:
                        xi = x0 = data[i++], yi = y0 = data[i++], min2[0] = x0, min2[1] = y0, max2[0] = x0, 
                        max2[1] = y0;
                        break;

                      case CMD.L:
                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2), xi = data[i++], yi = data[i++];
                        break;

                      case CMD.C:
                        bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2), 
                        xi = data[i++], yi = data[i++];
                        break;

                      case CMD.Q:
                        bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2), 
                        xi = data[i++], yi = data[i++];
                        break;

                      case CMD.A:
                        var cx = data[i++], cy = data[i++], rx = data[i++], ry = data[i++], startAngle = data[i++], endAngle = data[i++] + startAngle;
                        i += 1;
                        var anticlockwise = 1 - data[i++];
                        1 === i && (x0 = mathCos(startAngle) * rx + cx, y0 = mathSin(startAngle) * ry + cy), 
                        bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2), xi = mathCos(endAngle) * rx + cx, 
                        yi = mathSin(endAngle) * ry + cy;
                        break;

                      case CMD.R:
                        x0 = xi = data[i++], y0 = yi = data[i++];
                        var width = data[i++], height = data[i++];
                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
                        break;

                      case CMD.Z:
                        xi = x0, yi = y0;
                    }
                    vec2.min(min, min, min2), vec2.max(max, max, max2);
                }
                return 0 === i && (min[0] = min[1] = max[0] = max[1] = 0), new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);
            },
            rebuildPath: function(ctx) {
                for (var x0, y0, xi, yi, x, y, d = this.data, ux = this._ux, uy = this._uy, len = this._len, i = 0; i < len; ) {
                    var cmd = d[i++];
                    switch (1 === i && (x0 = xi = d[i], y0 = yi = d[i + 1]), cmd) {
                      case CMD.M:
                        x0 = xi = d[i++], y0 = yi = d[i++], ctx.moveTo(xi, yi);
                        break;

                      case CMD.L:
                        x = d[i++], y = d[i++], (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) && (ctx.lineTo(x, y), 
                        xi = x, yi = y);
                        break;

                      case CMD.C:
                        ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]), xi = d[i - 2], 
                        yi = d[i - 1];
                        break;

                      case CMD.Q:
                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]), xi = d[i - 2], yi = d[i - 1];
                        break;

                      case CMD.A:
                        var cx = d[i++], cy = d[i++], rx = d[i++], ry = d[i++], theta = d[i++], dTheta = d[i++], psi = d[i++], fs = d[i++], r = rx > ry ? rx : ry, scaleX = rx > ry ? 1 : rx / ry, scaleY = rx > ry ? ry / rx : 1, endAngle = theta + dTheta;
                        Math.abs(rx - ry) > .001 ? (ctx.translate(cx, cy), ctx.rotate(psi), ctx.scale(scaleX, scaleY), 
                        ctx.arc(0, 0, r, theta, endAngle, 1 - fs), ctx.scale(1 / scaleX, 1 / scaleY), ctx.rotate(-psi), 
                        ctx.translate(-cx, -cy)) : ctx.arc(cx, cy, r, theta, endAngle, 1 - fs), 1 === i && (x0 = mathCos(theta) * rx + cx, 
                        y0 = mathSin(theta) * ry + cy), xi = mathCos(endAngle) * rx + cx, yi = mathSin(endAngle) * ry + cy;
                        break;

                      case CMD.R:
                        x0 = xi = d[i], y0 = yi = d[i + 1], ctx.rect(d[i++], d[i++], d[i++], d[i++]);
                        break;

                      case CMD.Z:
                        ctx.closePath(), xi = x0, yi = y0;
                    }
                }
            }
        }, PathProxy.CMD = CMD;
        var _default = PathProxy;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), parseClassType = __webpack_require__(18).parseClassType, base = 0;
        exports.getUID = function(type) {
            return [ type || "", base++, Math.random().toFixed(5) ].join("_");
        }, exports.enableSubTypeDefaulter = function(entity) {
            var subTypeDefaulters = {};
            return entity.registerSubTypeDefaulter = function(componentType, defaulter) {
                componentType = parseClassType(componentType), subTypeDefaulters[componentType.main] = defaulter;
            }, entity.determineSubType = function(componentType, option) {
                var type = option.type;
                if (!type) {
                    var componentTypeMain = parseClassType(componentType).main;
                    entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain] && (type = subTypeDefaulters[componentTypeMain](option));
                }
                return type;
            }, entity;
        }, exports.enableTopologicalTravel = function(entity, dependencyGetter) {
            function createDependencyGraphItem(graph, name) {
                return graph[name] || (graph[name] = {
                    predecessor: [],
                    successor: []
                }), graph[name];
            }
            entity.topologicalTravel = function(targetNameList, fullNameList, callback, context) {
                if (targetNameList.length) {
                    var result = function(fullNameList) {
                        var graph = {}, noEntryList = [];
                        return zrUtil.each(fullNameList, function(name) {
                            var thisItem = createDependencyGraphItem(graph, name), availableDeps = function(originalDeps, fullNameList) {
                                var availableDeps = [];
                                return zrUtil.each(originalDeps, function(dep) {
                                    zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);
                                }), availableDeps;
                            }(thisItem.originalDeps = dependencyGetter(name), fullNameList);
                            thisItem.entryCount = availableDeps.length, 0 === thisItem.entryCount && noEntryList.push(name), 
                            zrUtil.each(availableDeps, function(dependentName) {
                                zrUtil.indexOf(thisItem.predecessor, dependentName) < 0 && thisItem.predecessor.push(dependentName);
                                var thatItem = createDependencyGraphItem(graph, dependentName);
                                zrUtil.indexOf(thatItem.successor, dependentName) < 0 && thatItem.successor.push(name);
                            });
                        }), {
                            graph: graph,
                            noEntryList: noEntryList
                        };
                    }(fullNameList), graph = result.graph, stack = result.noEntryList, targetNameSet = {};
                    for (zrUtil.each(targetNameList, function(name) {
                        targetNameSet[name] = !0;
                    }); stack.length; ) {
                        var currComponentType = stack.pop(), currVertex = graph[currComponentType], isInTargetNameSet = !!targetNameSet[currComponentType];
                        isInTargetNameSet && (callback.call(context, currComponentType, currVertex.originalDeps.slice()), 
                        delete targetNameSet[currComponentType]), zrUtil.each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);
                    }
                    zrUtil.each(targetNameSet, function() {
                        throw new Error("Circle dependency may exists");
                    });
                }
                function removeEdge(succComponentType) {
                    graph[succComponentType].entryCount--, 0 === graph[succComponentType].entryCount && stack.push(succComponentType);
                }
                function removeEdgeAndAdd(succComponentType) {
                    targetNameSet[succComponentType] = !0, removeEdge(succComponentType);
                }
            };
        };
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(5).__DEV__;
        var _model = __webpack_require__(3), makeInner = _model.makeInner, getDataItemValue = _model.getDataItemValue, getCoordSysDefineBySeries = __webpack_require__(113).getCoordSysDefineBySeries, _util = __webpack_require__(0), createHashMap = _util.createHashMap, each = _util.each, map = _util.map, isArray = _util.isArray, isString = _util.isString, isObject = _util.isObject, isTypedArray = _util.isTypedArray, isArrayLike = _util.isArrayLike, extend = _util.extend, Source = (_util.assert, 
        __webpack_require__(28)), _sourceType = __webpack_require__(29), SOURCE_FORMAT_ORIGINAL = _sourceType.SOURCE_FORMAT_ORIGINAL, SOURCE_FORMAT_ARRAY_ROWS = _sourceType.SOURCE_FORMAT_ARRAY_ROWS, SOURCE_FORMAT_OBJECT_ROWS = _sourceType.SOURCE_FORMAT_OBJECT_ROWS, SOURCE_FORMAT_KEYED_COLUMNS = _sourceType.SOURCE_FORMAT_KEYED_COLUMNS, SOURCE_FORMAT_UNKNOWN = _sourceType.SOURCE_FORMAT_UNKNOWN, SOURCE_FORMAT_TYPED_ARRAY = _sourceType.SOURCE_FORMAT_TYPED_ARRAY, SERIES_LAYOUT_BY_ROW = _sourceType.SERIES_LAYOUT_BY_ROW, inner = makeInner();
        function normalizeDimensionsDefine(dimensionsDefine) {
            if (dimensionsDefine) {
                var nameMap = createHashMap();
                return map(dimensionsDefine, function(item, index) {
                    if (null == (item = extend({}, isObject(item) ? item : {
                        name: item
                    })).name) return item;
                    item.name += "", null == item.displayName && (item.displayName = item.name);
                    var exist = nameMap.get(item.name);
                    return exist ? item.name += "-" + exist.count++ : nameMap.set(item.name, {
                        count: 1
                    }), item;
                });
            }
        }
        function arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {
            if (null == maxLoop && (maxLoop = 1 / 0), seriesLayoutBy === SERIES_LAYOUT_BY_ROW) for (var i = 0; i < data.length && i < maxLoop; i++) cb(data[i] ? data[i][0] : null, i); else {
                var value0 = data[0] || [];
                for (i = 0; i < value0.length && i < maxLoop; i++) cb(value0[i], i);
            }
        }
        function doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {
            var result, dimName;
            if (isTypedArray(data)) return !1;
            if (dimensionsDefine && (dimName = dimensionsDefine[dimIndex], dimName = isObject(dimName) ? dimName.name : dimName), 
            sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
                for (var sample = data[dimIndex], i = 0; i < (sample || []).length && i < 5; i++) if (null != (result = detectValue(sample[startIndex + i]))) return result;
            } else for (i = 0; i < data.length && i < 5; i++) {
                var row = data[startIndex + i];
                if (row && null != (result = detectValue(row[dimIndex]))) return result;
            } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
                if (!dimName) return;
                for (i = 0; i < data.length && i < 5; i++) {
                    if ((item = data[i]) && null != (result = detectValue(item[dimName]))) return result;
                }
            } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
                if (!dimName) return;
                if (!(sample = data[dimName]) || isTypedArray(sample)) return !1;
                for (i = 0; i < sample.length && i < 5; i++) if (null != (result = detectValue(sample[i]))) return result;
            } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) for (i = 0; i < data.length && i < 5; i++) {
                var item = data[i], val = getDataItemValue(item);
                if (!isArray(val)) return !1;
                if (null != (result = detectValue(val[dimIndex]))) return result;
            }
            function detectValue(val) {
                return (null == val || !isFinite(val) || "" === val) && (!(!isString(val) || "-" === val) || void 0);
            }
            return !1;
        }
        exports.detectSourceFormat = function(datasetModel) {
            var data = datasetModel.option.source, sourceFormat = SOURCE_FORMAT_UNKNOWN;
            if (isTypedArray(data)) sourceFormat = SOURCE_FORMAT_TYPED_ARRAY; else if (isArray(data)) {
                0 === data.length && (sourceFormat = SOURCE_FORMAT_ARRAY_ROWS);
                for (var i = 0, len = data.length; i < len; i++) {
                    var item = data[i];
                    if (null != item) {
                        if (isArray(item)) {
                            sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
                            break;
                        }
                        if (isObject(item)) {
                            sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;
                            break;
                        }
                    }
                }
            } else if (isObject(data)) {
                for (var key in data) if (data.hasOwnProperty(key) && isArrayLike(data[key])) {
                    sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;
                    break;
                }
            } else if (null != data) throw new Error("Invalid data");
            inner(datasetModel).sourceFormat = sourceFormat;
        }, exports.getSource = function(seriesModel) {
            return inner(seriesModel).source;
        }, exports.resetSourceDefaulter = function(ecModel) {
            inner(ecModel).datasetMap = createHashMap();
        }, exports.prepareSource = function(seriesModel) {
            var seriesOption = seriesModel.option, data = seriesOption.data, sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL, fromDataset = !1, seriesLayoutBy = seriesOption.seriesLayoutBy, sourceHeader = seriesOption.sourceHeader, dimensionsDefine = seriesOption.dimensions, datasetModel = function(seriesModel) {
                var option = seriesModel.option;
                if (!option.data) return seriesModel.ecModel.getComponent("dataset", option.datasetIndex || 0);
            }(seriesModel);
            if (datasetModel) {
                var datasetOption = datasetModel.option;
                data = datasetOption.source, sourceFormat = inner(datasetModel).sourceFormat, fromDataset = !0, 
                seriesLayoutBy = seriesLayoutBy || datasetOption.seriesLayoutBy, null == sourceHeader && (sourceHeader = datasetOption.sourceHeader), 
                dimensionsDefine = dimensionsDefine || datasetOption.dimensions;
            }
            var completeResult = function(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {
                if (!data) return {
                    dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine)
                };
                var dimensionsDetectCount, startIndex, findPotentialName, potentialNameDimIndex;
                if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) "auto" === sourceHeader || null == sourceHeader ? arrayRowsTravelFirst(function(val) {
                    null != val && "-" !== val && (isString(val) ? null == startIndex && (startIndex = 1) : startIndex = 0);
                }, seriesLayoutBy, data, 10) : startIndex = sourceHeader ? 1 : 0, dimensionsDefine || 1 !== startIndex || (dimensionsDefine = [], 
                arrayRowsTravelFirst(function(val, index) {
                    dimensionsDefine[index] = null != val ? val : "";
                }, seriesLayoutBy, data)), dimensionsDetectCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? data.length : data[0] ? data[0].length : null; else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) dimensionsDefine || (dimensionsDefine = function(data) {
                    for (var obj, firstIndex = 0; firstIndex < data.length && !(obj = data[firstIndex++]); ) ;
                    if (obj) {
                        var dimensions = [];
                        return each(obj, function(value, key) {
                            dimensions.push(key);
                        }), dimensions;
                    }
                }(data), findPotentialName = !0); else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) dimensionsDefine || (dimensionsDefine = [], 
                findPotentialName = !0, each(data, function(colArr, key) {
                    dimensionsDefine.push(key);
                })); else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
                    var value0 = getDataItemValue(data[0]);
                    dimensionsDetectCount = isArray(value0) && value0.length || 1;
                }
                return findPotentialName && each(dimensionsDefine, function(dim, idx) {
                    "name" === (isObject(dim) ? dim.name : dim) && (potentialNameDimIndex = idx);
                }), {
                    startIndex: startIndex,
                    dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine),
                    dimensionsDetectCount: dimensionsDetectCount,
                    potentialNameDimIndex: potentialNameDimIndex
                };
            }(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine), encodeDefine = seriesOption.encode;
            !encodeDefine && datasetModel && (encodeDefine = function(seriesModel, datasetModel, data, sourceFormat, seriesLayoutBy, completeResult) {
                var coordSysDefine = getCoordSysDefineBySeries(seriesModel), encode = {}, encodeItemName = [], encodeSeriesName = [], seriesType = seriesModel.subType, nSeriesMap = createHashMap([ "pie", "map", "funnel" ]), cSeriesMap = createHashMap([ "line", "bar", "pictorialBar", "scatter", "effectScatter", "candlestick", "boxplot" ]);
                if (coordSysDefine && null != cSeriesMap.get(seriesType)) {
                    var ecModel = seriesModel.ecModel, datasetMap = inner(ecModel).datasetMap, key = datasetModel.uid + "_" + seriesLayoutBy, datasetRecord = datasetMap.get(key) || datasetMap.set(key, {
                        categoryWayDim: 1,
                        valueWayDim: 0
                    });
                    each(coordSysDefine.coordSysDims, function(coordDim) {
                        if (null == coordSysDefine.firstCategoryDimIndex) {
                            var dataDim = datasetRecord.valueWayDim++;
                            encode[coordDim] = dataDim, encodeSeriesName.push(dataDim);
                        } else if (coordSysDefine.categoryAxisMap.get(coordDim)) encode[coordDim] = 0, encodeItemName.push(0); else {
                            var dataDim = datasetRecord.categoryWayDim++;
                            encode[coordDim] = dataDim, encodeSeriesName.push(dataDim);
                        }
                    });
                } else if (null != nSeriesMap.get(seriesType)) {
                    for (var firstNotOrdinal, i = 0; i < 5 && null == firstNotOrdinal; i++) doGuessOrdinal(data, sourceFormat, seriesLayoutBy, completeResult.dimensionsDefine, completeResult.startIndex, i) || (firstNotOrdinal = i);
                    if (null != firstNotOrdinal) {
                        encode.value = firstNotOrdinal;
                        var nameDimIndex = completeResult.potentialNameDimIndex || Math.max(firstNotOrdinal - 1, 0);
                        encodeSeriesName.push(nameDimIndex), encodeItemName.push(nameDimIndex);
                    }
                }
                return encodeItemName.length && (encode.itemName = encodeItemName), encodeSeriesName.length && (encode.seriesName = encodeSeriesName), 
                encode;
            }(seriesModel, datasetModel, data, sourceFormat, seriesLayoutBy, completeResult)), 
            inner(seriesModel).source = new Source({
                data: data,
                fromDataset: fromDataset,
                seriesLayoutBy: seriesLayoutBy,
                sourceFormat: sourceFormat,
                dimensionsDefine: completeResult.dimensionsDefine,
                startIndex: completeResult.startIndex,
                dimensionsDetectCount: completeResult.dimensionsDetectCount,
                encodeDefine: encodeDefine
            });
        }, exports.guessOrdinal = function(source, dimIndex) {
            return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);
        };
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), coordinateSystemCreators = {};
        function CoordinateSystemManager() {
            this._coordinateSystems = [];
        }
        CoordinateSystemManager.prototype = {
            constructor: CoordinateSystemManager,
            create: function(ecModel, api) {
                var coordinateSystems = [];
                zrUtil.each(coordinateSystemCreators, function(creater, type) {
                    var list = creater.create(ecModel, api);
                    coordinateSystems = coordinateSystems.concat(list || []);
                }), this._coordinateSystems = coordinateSystems;
            },
            update: function(ecModel, api) {
                zrUtil.each(this._coordinateSystems, function(coordSys) {
                    coordSys.update && coordSys.update(ecModel, api);
                });
            },
            getCoordinateSystems: function() {
                return this._coordinateSystems.slice();
            }
        }, CoordinateSystemManager.register = function(type, coordinateSystemCreator) {
            coordinateSystemCreators[type] = coordinateSystemCreator;
        }, CoordinateSystemManager.get = function(type) {
            return coordinateSystemCreators[type];
        };
        var _default = CoordinateSystemManager;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var makeInner = __webpack_require__(3).makeInner;
        module.exports = function() {
            var inner = makeInner();
            return function(seriesModel) {
                var fields = inner(seriesModel), pipelineContext = seriesModel.pipelineContext, originalLarge = fields.large, originalProgressive = fields.progressiveRender, large = fields.large = pipelineContext.large, progressive = fields.progressiveRender = pipelineContext.progressiveRender;
                return !!(originalLarge ^ large || originalProgressive ^ progressive) && "reset";
            };
        };
    }, function(module, exports, __webpack_require__) {
        var clazzUtil = __webpack_require__(18);
        function Scale(setting) {
            this._setting = setting || {}, this._extent = [ 1 / 0, -1 / 0 ], this._interval = 0, 
            this.init && this.init.apply(this, arguments);
        }
        Scale.prototype.parse = function(val) {
            return val;
        }, Scale.prototype.getSetting = function(name) {
            return this._setting[name];
        }, Scale.prototype.contain = function(val) {
            var extent = this._extent;
            return val >= extent[0] && val <= extent[1];
        }, Scale.prototype.normalize = function(val) {
            var extent = this._extent;
            return extent[1] === extent[0] ? .5 : (val - extent[0]) / (extent[1] - extent[0]);
        }, Scale.prototype.scale = function(val) {
            var extent = this._extent;
            return val * (extent[1] - extent[0]) + extent[0];
        }, Scale.prototype.unionExtent = function(other) {
            var extent = this._extent;
            other[0] < extent[0] && (extent[0] = other[0]), other[1] > extent[1] && (extent[1] = other[1]);
        }, Scale.prototype.unionExtentFromData = function(data, dim) {
            this.unionExtent(data.getApproximateExtent(dim));
        }, Scale.prototype.getExtent = function() {
            return this._extent.slice();
        }, Scale.prototype.setExtent = function(start, end) {
            var thisExtent = this._extent;
            isNaN(start) || (thisExtent[0] = start), isNaN(end) || (thisExtent[1] = end);
        }, Scale.prototype.isBlank = function() {
            return this._isBlank;
        }, Scale.prototype.setBlank = function(isBlank) {
            this._isBlank = isBlank;
        }, Scale.prototype.getLabel = null, clazzUtil.enableClassExtend(Scale), clazzUtil.enableClassManagement(Scale, {
            registerWhenExtend: !0
        });
        var _default = Scale;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var graphic = __webpack_require__(2), SymbolClz = __webpack_require__(68), isObject = __webpack_require__(0).isObject;
        function SymbolDraw(symbolCtor) {
            this.group = new graphic.Group(), this._symbolCtor = symbolCtor || SymbolClz;
        }
        var symbolDrawProto = SymbolDraw.prototype;
        function symbolNeedsDraw(data, point, idx, opt) {
            return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && "none" !== data.getItemVisual(idx, "symbol");
        }
        function normalizeUpdateOpt(opt) {
            return null == opt || isObject(opt) || (opt = {
                isIgnore: opt
            }), opt || {};
        }
        function makeSeriesScope(data) {
            var seriesModel = data.hostModel;
            return {
                itemStyle: seriesModel.getModel("itemStyle").getItemStyle([ "color" ]),
                hoverItemStyle: seriesModel.getModel("emphasis.itemStyle").getItemStyle(),
                symbolRotate: seriesModel.get("symbolRotate"),
                symbolOffset: seriesModel.get("symbolOffset"),
                hoverAnimation: seriesModel.get("hoverAnimation"),
                labelModel: seriesModel.getModel("label"),
                hoverLabelModel: seriesModel.getModel("emphasis.label"),
                cursorStyle: seriesModel.get("cursor")
            };
        }
        symbolDrawProto.updateData = function(data, opt) {
            opt = normalizeUpdateOpt(opt);
            var group = this.group, seriesModel = data.hostModel, oldData = this._data, SymbolCtor = this._symbolCtor, seriesScope = makeSeriesScope(data);
            oldData || group.removeAll(), data.diff(oldData).add(function(newIdx) {
                var point = data.getItemLayout(newIdx);
                if (symbolNeedsDraw(data, point, newIdx, opt)) {
                    var symbolEl = new SymbolCtor(data, newIdx, seriesScope);
                    symbolEl.attr("position", point), data.setItemGraphicEl(newIdx, symbolEl), group.add(symbolEl);
                }
            }).update(function(newIdx, oldIdx) {
                var symbolEl = oldData.getItemGraphicEl(oldIdx), point = data.getItemLayout(newIdx);
                symbolNeedsDraw(data, point, newIdx, opt) ? (symbolEl ? (symbolEl.updateData(data, newIdx, seriesScope), 
                graphic.updateProps(symbolEl, {
                    position: point
                }, seriesModel)) : (symbolEl = new SymbolCtor(data, newIdx)).attr("position", point), 
                group.add(symbolEl), data.setItemGraphicEl(newIdx, symbolEl)) : group.remove(symbolEl);
            }).remove(function(oldIdx) {
                var el = oldData.getItemGraphicEl(oldIdx);
                el && el.fadeOut(function() {
                    group.remove(el);
                });
            }).execute(), this._data = data;
        }, symbolDrawProto.isPersistent = function() {
            return !0;
        }, symbolDrawProto.updateLayout = function() {
            var data = this._data;
            data && data.eachItemGraphicEl(function(el, idx) {
                var point = data.getItemLayout(idx);
                el.attr("position", point);
            });
        }, symbolDrawProto.incrementalPrepareUpdate = function(data) {
            this._seriesScope = makeSeriesScope(data), this._data = null, this.group.removeAll();
        }, symbolDrawProto.incrementalUpdate = function(taskParams, data, opt) {
            function updateIncrementalAndHover(el) {
                el.isGroup || (el.incremental = el.useHoverLayer = !0);
            }
            opt = normalizeUpdateOpt(opt);
            for (var idx = taskParams.start; idx < taskParams.end; idx++) {
                var point = data.getItemLayout(idx);
                if (symbolNeedsDraw(data, point, idx, opt)) {
                    var el = new this._symbolCtor(data, idx, this._seriesScope);
                    el.traverse(updateIncrementalAndHover), el.attr("position", point), this.group.add(el), 
                    data.setItemGraphicEl(idx, el);
                }
            }
        }, symbolDrawProto.remove = function(enableAnimation) {
            var group = this.group, data = this._data;
            data && enableAnimation ? data.eachItemGraphicEl(function(el) {
                el.fadeOut(function() {
                    group.remove(el);
                });
            }) : group.removeAll();
        };
        var _default = SymbolDraw;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), Model = __webpack_require__(14), each = zrUtil.each, curry = zrUtil.curry;
        function checkPropInLink(linkPropValue, axisPropValue) {
            return "all" === linkPropValue || zrUtil.isArray(linkPropValue) && zrUtil.indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;
        }
        function getAxisInfo(axisModel) {
            var coordSysAxesInfo = (axisModel.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
            return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];
        }
        function isHandleTrigger(axisPointerModel) {
            return !!axisPointerModel.get("handle.show");
        }
        function makeKey(model) {
            return model.type + "||" + model.id;
        }
        exports.collect = function(ecModel, api) {
            var result = {
                axesInfo: {},
                seriesInvolved: !1,
                coordSysAxesInfo: {},
                coordSysMap: {}
            };
            return function(result, ecModel, api) {
                var globalTooltipModel = ecModel.getComponent("tooltip"), globalAxisPointerModel = ecModel.getComponent("axisPointer"), linksOption = globalAxisPointerModel.get("link", !0) || [], linkGroups = [];
                each(api.getCoordinateSystems(), function(coordSys) {
                    if (coordSys.axisPointerEnabled) {
                        var coordSysKey = makeKey(coordSys.model), axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};
                        result.coordSysMap[coordSysKey] = coordSys;
                        var coordSysModel = coordSys.model, baseTooltipModel = coordSysModel.getModel("tooltip", globalTooltipModel);
                        if (each(coordSys.getAxes(), curry(saveTooltipAxisInfo, !1, null)), coordSys.getTooltipAxes && globalTooltipModel && baseTooltipModel.get("show")) {
                            var triggerAxis = "axis" === baseTooltipModel.get("trigger"), cross = "cross" === baseTooltipModel.get("axisPointer.type"), tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get("axisPointer.axis"));
                            (triggerAxis || cross) && each(tooltipAxes.baseAxes, curry(saveTooltipAxisInfo, !cross || "cross", triggerAxis)), 
                            cross && each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, "cross", !1));
                        }
                    }
                    function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {
                        var axisPointerModel = axis.model.getModel("axisPointer", globalAxisPointerModel), axisPointerShow = axisPointerModel.get("show");
                        if (axisPointerShow && ("auto" !== axisPointerShow || fromTooltip || isHandleTrigger(axisPointerModel))) {
                            null == triggerTooltip && (triggerTooltip = axisPointerModel.get("triggerTooltip"));
                            var snap = (axisPointerModel = fromTooltip ? function(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {
                                var tooltipAxisPointerModel = baseTooltipModel.getModel("axisPointer"), volatileOption = {};
                                each([ "type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z" ], function(field) {
                                    volatileOption[field] = zrUtil.clone(tooltipAxisPointerModel.get(field));
                                }), volatileOption.snap = "category" !== axis.type && !!triggerTooltip, "cross" === tooltipAxisPointerModel.get("type") && (volatileOption.type = "line");
                                var labelOption = volatileOption.label || (volatileOption.label = {});
                                if (null == labelOption.show && (labelOption.show = !1), "cross" === fromTooltip) {
                                    var tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get("label.show");
                                    if (labelOption.show = null == tooltipAxisPointerLabelShow || tooltipAxisPointerLabelShow, 
                                    !triggerTooltip) {
                                        var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get("crossStyle");
                                        crossStyle && zrUtil.defaults(labelOption, crossStyle.textStyle);
                                    }
                                }
                                return axis.model.getModel("axisPointer", new Model(volatileOption, globalAxisPointerModel, ecModel));
                            }(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel).get("snap"), key = makeKey(axis.model), involveSeries = triggerTooltip || snap || "category" === axis.type, axisInfo = result.axesInfo[key] = {
                                key: key,
                                axis: axis,
                                coordSys: coordSys,
                                axisPointerModel: axisPointerModel,
                                triggerTooltip: triggerTooltip,
                                involveSeries: involveSeries,
                                snap: snap,
                                useHandle: isHandleTrigger(axisPointerModel),
                                seriesModels: []
                            };
                            axesInfoInCoordSys[key] = axisInfo, result.seriesInvolved |= involveSeries;
                            var groupIndex = function(linksOption, axis) {
                                for (var axisModel = axis.model, dim = axis.dim, i = 0; i < linksOption.length; i++) {
                                    var linkOption = linksOption[i] || {};
                                    if (checkPropInLink(linkOption[dim + "AxisId"], axisModel.id) || checkPropInLink(linkOption[dim + "AxisIndex"], axisModel.componentIndex) || checkPropInLink(linkOption[dim + "AxisName"], axisModel.name)) return i;
                                }
                            }(linksOption, axis);
                            if (null != groupIndex) {
                                var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {
                                    axesInfo: {}
                                });
                                linkGroup.axesInfo[key] = axisInfo, linkGroup.mapper = linksOption[groupIndex].mapper, 
                                axisInfo.linkGroup = linkGroup;
                            }
                        }
                    }
                });
            }(result, ecModel, api), result.seriesInvolved && function(result, ecModel) {
                ecModel.eachSeries(function(seriesModel) {
                    var coordSys = seriesModel.coordinateSystem, seriesTooltipTrigger = seriesModel.get("tooltip.trigger", !0), seriesTooltipShow = seriesModel.get("tooltip.show", !0);
                    coordSys && "none" !== seriesTooltipTrigger && !1 !== seriesTooltipTrigger && "item" !== seriesTooltipTrigger && !1 !== seriesTooltipShow && !1 !== seriesModel.get("axisPointer.show", !0) && each(result.coordSysAxesInfo[makeKey(coordSys.model)], function(axisInfo) {
                        var axis = axisInfo.axis;
                        coordSys.getAxis(axis.dim) === axis && (axisInfo.seriesModels.push(seriesModel), 
                        null == axisInfo.seriesDataCount && (axisInfo.seriesDataCount = 0), axisInfo.seriesDataCount += seriesModel.getData().count());
                    });
                }, this);
            }(result, ecModel), result;
        }, exports.fixValue = function(axisModel) {
            var axisInfo = getAxisInfo(axisModel);
            if (axisInfo) {
                var axisPointerModel = axisInfo.axisPointerModel, scale = axisInfo.axis.scale, option = axisPointerModel.option, status = axisPointerModel.get("status"), value = axisPointerModel.get("value");
                null != value && (value = scale.parse(value));
                var useHandle = isHandleTrigger(axisPointerModel);
                null == status && (option.status = useHandle ? "show" : "hide");
                var extent = scale.getExtent().slice();
                extent[0] > extent[1] && extent.reverse(), (null == value || value > extent[1]) && (value = extent[1]), 
                value < extent[0] && (value = extent[0]), option.value = value, useHandle && (option.status = axisInfo.axis.scale.isBlank() ? "hide" : "show");
            }
        }, exports.getAxisInfo = getAxisInfo, exports.getAxisPointerModel = function(axisModel) {
            var axisInfo = getAxisInfo(axisModel);
            return axisInfo && axisInfo.axisPointerModel;
        }, exports.makeKey = makeKey;
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(5).__DEV__;
        var echarts = __webpack_require__(1), zrUtil = __webpack_require__(0), env = __webpack_require__(7), modelUtil = __webpack_require__(3), helper = __webpack_require__(72), AxisProxy = __webpack_require__(298), each = zrUtil.each, eachAxisDim = helper.eachAxisDim;
        function retrieveRaw(option) {
            var ret = {};
            return each([ "start", "end", "startValue", "endValue", "throttle" ], function(name) {
                option.hasOwnProperty(name) && (ret[name] = option[name]);
            }), ret;
        }
        function updateRangeUse(dataZoomModel, rawOption) {
            var rangePropMode = dataZoomModel._rangePropMode, rangeModeInOption = dataZoomModel.get("rangeMode");
            each([ [ "start", "startValue" ], [ "end", "endValue" ] ], function(names, index) {
                var percentSpecified = null != rawOption[names[0]], valueSpecified = null != rawOption[names[1]];
                percentSpecified && !valueSpecified ? rangePropMode[index] = "percent" : !percentSpecified && valueSpecified ? rangePropMode[index] = "value" : rangeModeInOption ? rangePropMode[index] = rangeModeInOption[index] : percentSpecified && (rangePropMode[index] = "percent");
            });
        }
        var _default = echarts.extendComponentModel({
            type: "dataZoom",
            dependencies: [ "xAxis", "yAxis", "zAxis", "radiusAxis", "angleAxis", "singleAxis", "series" ],
            defaultOption: {
                zlevel: 0,
                z: 4,
                orient: null,
                xAxisIndex: null,
                yAxisIndex: null,
                filterMode: "filter",
                throttle: null,
                start: 0,
                end: 100,
                startValue: null,
                endValue: null,
                minSpan: null,
                maxSpan: null,
                minValueSpan: null,
                maxValueSpan: null,
                rangeMode: null
            },
            init: function(option, parentModel, ecModel) {
                this._dataIntervalByAxis = {}, this._dataInfo = {}, this._axisProxies = {}, this.textStyleModel, 
                this._autoThrottle = !0, this._rangePropMode = [ "percent", "percent" ];
                var rawOption = retrieveRaw(option);
                this.mergeDefaultAndTheme(option, ecModel), this.doInit(rawOption);
            },
            mergeOption: function(newOption) {
                var rawOption = retrieveRaw(newOption);
                zrUtil.merge(this.option, newOption, !0), this.doInit(rawOption);
            },
            doInit: function(rawOption) {
                var thisOption = this.option;
                env.canvasSupported || (thisOption.realtime = !1), this._setDefaultThrottle(rawOption), 
                updateRangeUse(this, rawOption), each([ [ "start", "startValue" ], [ "end", "endValue" ] ], function(names, index) {
                    "value" === this._rangePropMode[index] && (thisOption[names[0]] = null);
                }, this), this.textStyleModel = this.getModel("textStyle"), this._resetTarget(), 
                this._giveAxisProxies();
            },
            _giveAxisProxies: function() {
                var axisProxies = this._axisProxies;
                this.eachTargetAxis(function(dimNames, axisIndex, dataZoomModel, ecModel) {
                    var axisModel = this.dependentModels[dimNames.axis][axisIndex], axisProxy = axisModel.__dzAxisProxy || (axisModel.__dzAxisProxy = new AxisProxy(dimNames.name, axisIndex, this, ecModel));
                    axisProxies[dimNames.name + "_" + axisIndex] = axisProxy;
                }, this);
            },
            _resetTarget: function() {
                var thisOption = this.option, autoMode = this._judgeAutoMode();
                eachAxisDim(function(dimNames) {
                    var axisIndexName = dimNames.axisIndex;
                    thisOption[axisIndexName] = modelUtil.normalizeToArray(thisOption[axisIndexName]);
                }, this), "axisIndex" === autoMode ? this._autoSetAxisIndex() : "orient" === autoMode && this._autoSetOrient();
            },
            _judgeAutoMode: function() {
                var thisOption = this.option, hasIndexSpecified = !1;
                eachAxisDim(function(dimNames) {
                    null != thisOption[dimNames.axisIndex] && (hasIndexSpecified = !0);
                }, this);
                var orient = thisOption.orient;
                return null == orient && hasIndexSpecified ? "orient" : hasIndexSpecified ? void 0 : (null == orient && (thisOption.orient = "horizontal"), 
                "axisIndex");
            },
            _autoSetAxisIndex: function() {
                var autoAxisIndex = !0, orient = this.get("orient", !0), thisOption = this.option, dependentModels = this.dependentModels;
                if (autoAxisIndex) {
                    var dimName = "vertical" === orient ? "y" : "x";
                    dependentModels[dimName + "Axis"].length ? (thisOption[dimName + "AxisIndex"] = [ 0 ], 
                    autoAxisIndex = !1) : each(dependentModels.singleAxis, function(singleAxisModel) {
                        autoAxisIndex && singleAxisModel.get("orient", !0) === orient && (thisOption.singleAxisIndex = [ singleAxisModel.componentIndex ], 
                        autoAxisIndex = !1);
                    });
                }
                autoAxisIndex && eachAxisDim(function(dimNames) {
                    if (autoAxisIndex) {
                        var axisIndices = [], axisModels = this.dependentModels[dimNames.axis];
                        if (axisModels.length && !axisIndices.length) for (var i = 0, len = axisModels.length; i < len; i++) "category" === axisModels[i].get("type") && axisIndices.push(i);
                        thisOption[dimNames.axisIndex] = axisIndices, axisIndices.length && (autoAxisIndex = !1);
                    }
                }, this), autoAxisIndex && this.ecModel.eachSeries(function(seriesModel) {
                    this._isSeriesHasAllAxesTypeOf(seriesModel, "value") && eachAxisDim(function(dimNames) {
                        var axisIndices = thisOption[dimNames.axisIndex], axisIndex = seriesModel.get(dimNames.axisIndex), axisId = seriesModel.get(dimNames.axisId);
                        axisIndex = seriesModel.ecModel.queryComponents({
                            mainType: dimNames.axis,
                            index: axisIndex,
                            id: axisId
                        })[0].componentIndex, zrUtil.indexOf(axisIndices, axisIndex) < 0 && axisIndices.push(axisIndex);
                    });
                }, this);
            },
            _autoSetOrient: function() {
                var dim;
                this.eachTargetAxis(function(dimNames) {
                    !dim && (dim = dimNames.name);
                }, this), this.option.orient = "y" === dim ? "vertical" : "horizontal";
            },
            _isSeriesHasAllAxesTypeOf: function(seriesModel, axisType) {
                var is = !0;
                return eachAxisDim(function(dimNames) {
                    var seriesAxisIndex = seriesModel.get(dimNames.axisIndex), axisModel = this.dependentModels[dimNames.axis][seriesAxisIndex];
                    axisModel && axisModel.get("type") === axisType || (is = !1);
                }, this), is;
            },
            _setDefaultThrottle: function(rawOption) {
                if (rawOption.hasOwnProperty("throttle") && (this._autoThrottle = !1), this._autoThrottle) {
                    var globalOption = this.ecModel.option;
                    this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;
                }
            },
            getFirstTargetAxisModel: function() {
                var firstAxisModel;
                return eachAxisDim(function(dimNames) {
                    if (null == firstAxisModel) {
                        var indices = this.get(dimNames.axisIndex);
                        indices.length && (firstAxisModel = this.dependentModels[dimNames.axis][indices[0]]);
                    }
                }, this), firstAxisModel;
            },
            eachTargetAxis: function(callback, context) {
                var ecModel = this.ecModel;
                eachAxisDim(function(dimNames) {
                    each(this.get(dimNames.axisIndex), function(axisIndex) {
                        callback.call(context, dimNames, axisIndex, this, ecModel);
                    }, this);
                }, this);
            },
            getAxisProxy: function(dimName, axisIndex) {
                return this._axisProxies[dimName + "_" + axisIndex];
            },
            getAxisModel: function(dimName, axisIndex) {
                var axisProxy = this.getAxisProxy(dimName, axisIndex);
                return axisProxy && axisProxy.getAxisModel();
            },
            setRawRange: function(opt, ignoreUpdateRangeUsg) {
                var option = this.option;
                each([ [ "start", "startValue" ], [ "end", "endValue" ] ], function(names) {
                    null == opt[names[0]] && null == opt[names[1]] || (option[names[0]] = opt[names[0]], 
                    option[names[1]] = opt[names[1]]);
                }, this), !ignoreUpdateRangeUsg && updateRangeUse(this, opt);
            },
            getPercentRange: function() {
                var axisProxy = this.findRepresentativeAxisProxy();
                if (axisProxy) return axisProxy.getDataPercentWindow();
            },
            getValueRange: function(axisDimName, axisIndex) {
                if (null != axisDimName || null != axisIndex) return this.getAxisProxy(axisDimName, axisIndex).getDataValueWindow();
                var axisProxy = this.findRepresentativeAxisProxy();
                return axisProxy ? axisProxy.getDataValueWindow() : void 0;
            },
            findRepresentativeAxisProxy: function(axisModel) {
                if (axisModel) return axisModel.__dzAxisProxy;
                var axisProxies = this._axisProxies;
                for (var key in axisProxies) if (axisProxies.hasOwnProperty(key) && axisProxies[key].hostedBy(this)) return axisProxies[key];
                for (var key in axisProxies) if (axisProxies.hasOwnProperty(key) && !axisProxies[key].hostedBy(this)) return axisProxies[key];
            },
            getRangePropMode: function() {
                return this._rangePropMode.slice();
            }
        });
        module.exports = _default;
    }, function(module, exports) {
        function getSpanSign(handleEnds, handleIndex) {
            var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex];
            return {
                span: Math.abs(dist),
                sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1
            };
        }
        function restrict(value, extend) {
            return Math.min(null != extend[1] ? extend[1] : 1 / 0, Math.max(null != extend[0] ? extend[0] : -1 / 0, value));
        }
        module.exports = function(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {
            delta = delta || 0;
            var extentSpan = extent[1] - extent[0];
            if (null != minSpan && (minSpan = restrict(minSpan, [ 0, extentSpan ])), null != maxSpan && (maxSpan = Math.max(maxSpan, null != minSpan ? minSpan : 0)), 
            "all" === handleIndex) {
                var handleSpan = Math.abs(handleEnds[1] - handleEnds[0]);
                minSpan = maxSpan = restrict(handleSpan = restrict(handleSpan, [ 0, extentSpan ]), [ minSpan, maxSpan ]), 
                handleIndex = 0;
            }
            handleEnds[0] = restrict(handleEnds[0], extent), handleEnds[1] = restrict(handleEnds[1], extent);
            var originalDistSign = getSpanSign(handleEnds, handleIndex);
            handleEnds[handleIndex] += delta;
            var extentMinSpan = minSpan || 0, realExtent = extent.slice();
            originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan, 
            handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent);
            var currDistSign = getSpanSign(handleEnds, handleIndex);
            return null != minSpan && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan) && (handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan), 
            currDistSign = getSpanSign(handleEnds, handleIndex), null != maxSpan && currDistSign.span > maxSpan && (handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan), 
            handleEnds;
        };
    }, function(module, exports, __webpack_require__) {
        var _default = __webpack_require__(64).extend({
            type: "dataZoom",
            render: function(dataZoomModel, ecModel, api, payload) {
                this.dataZoomModel = dataZoomModel, this.ecModel = ecModel, this.api = api;
            },
            getTargetCoordInfo: function() {
                var dataZoomModel = this.dataZoomModel, ecModel = this.ecModel, coordSysLists = {};
                return dataZoomModel.eachTargetAxis(function(dimNames, axisIndex) {
                    var axisModel = ecModel.getComponent(dimNames.axis, axisIndex);
                    if (axisModel) {
                        var coordModel = axisModel.getCoordSysModel();
                        coordModel && function(coordModel, axisModel, store, coordIndex) {
                            for (var item, i = 0; i < store.length; i++) if (store[i].model === coordModel) {
                                item = store[i];
                                break;
                            }
                            item || store.push(item = {
                                model: coordModel,
                                axisModels: [],
                                coordIndex: coordIndex
                            });
                            item.axisModels.push(axisModel);
                        }(coordModel, axisModel, coordSysLists[coordModel.mainType] || (coordSysLists[coordModel.mainType] = []), coordModel.componentIndex);
                    }
                }, this), coordSysLists;
            }
        });
        module.exports = _default;
    }, function(module, exports) {
        module.exports = __WEBPACK_EXTERNAL_MODULE__49__;
    }, function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.getScatterplotData = exports.fetchScatterplotVars = exports.fetchReducedPair = exports.mergeDatasets = void 0;
        var _axios2 = function(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }(__webpack_require__(154)), _papaparse = __webpack_require__(173);
        var mergeDatasets = exports.mergeDatasets = function() {
            for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) sets[_key] = arguments[_key];
            return Object.keys(sets[0]).filter(function(id) {
                return sets.reduce(function(acc, curr) {
                    return !!acc && (curr.hasOwnProperty(id) && parseFloat(curr[id]) > -9999 && parseFloat(curr[id]) > -9999 && "" !== id && "id" !== id);
                }, !0);
            }).reduce(function(acc, curr) {
                return acc[curr] = [].concat(function(arr) {
                    if (Array.isArray(arr)) {
                        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
                        return arr2;
                    }
                    return Array.from(arr);
                }(sets.map(function(s) {
                    return parseFloat(s[curr]);
                })), [ curr ]), acc;
            }, {});
        }, parseCsvData = function(data, isMeta) {
            var parsed = (0, _papaparse.parse)(data, {
                transform: function(value, column) {
                    return !(isMeta && column > 1 || !isMeta && column > 0) || !value && 0 !== value || isNaN(parseFloat(value)) ? value : parseFloat(value);
                }
            });
            if (parsed.errors.length) {
                var errorMessage = parsed.errors[0].type + ":" + parsed.errors[0].code + " on row " + parsed.errors[0].row;
                throw new Error(errorMessage);
            }
            return {
                header: parsed.data[0],
                data: parsed.data.reduce(function(acc, curr) {
                    return "id" !== curr[0] && (acc[curr[0]] = 2 === curr.length ? curr[1] : curr), 
                    acc;
                }, {})
            };
        };
        exports.fetchReducedPair = function(endpoint, var1, var2) {
            var filename = [ var1, var2 ].sort().join("-");
            return _axios2.default.get(endpoint + "schools/reduced/" + filename + ".csv").then(function(res) {
                return parseCsvData(res.data, !0);
            }).then(function(_ref) {
                return function(varNames, data) {
                    return varNames.reduce(function(obj, v, i) {
                        return "id" !== v && (obj[v] = Object.keys(data).reduce(function(a, c) {
                            return data[c][i] && (a[c] = data[c][i]), a;
                        }, {})), obj;
                    }, {});
                }(_ref.header, _ref.data);
            }).catch(function(err) {
                return console.error(err), {};
            });
        }, exports.fetchScatterplotVars = function() {
            var vars = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], prefix = arguments[1], endpoint = arguments[2], metaVars = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [], state = arguments[4], fetchVars = vars.map(function(v) {
                return metaVars.indexOf(v) > -1 ? "meta" : v;
            }).filter(function(value, index, self) {
                return self.indexOf(value) === index;
            }), fetchUrls = fetchVars.map(function(v) {
                return function(endpoint, prefix, varName, state) {
                    return "schools" !== prefix ? "meta" === varName ? endpoint + "meta/" + prefix + ".csv" : endpoint + (prefix ? prefix + "/" : "") + varName + ".csv" : state ? "meta" === varName ? endpoint + "meta/schools/" + state + ".csv" : endpoint + "schools/" + state + "/" + varName + ".csv" : void 0;
                }(endpoint, prefix, v, state);
            }), fetchMap = fetchVars.reduce(function(acc, curr, i) {
                return fetchUrls[i] && (acc[curr] = fetchUrls[i]), acc;
            }, {});
            return Promise.all(Object.keys(fetchMap).map(function(v) {
                return _axios2.default.get(fetchMap[v]).then(function(res) {
                    return parseCsvData(res.data, "meta" === v).data;
                }, function(err) {
                    throw console.error(err), new Error("Could not get " + fetchMap[v]);
                });
            })).then(function(data) {
                return function(varNames, data, metaVars) {
                    return data && 0 !== data.length ? varNames.reduce(function(acc, curr, i) {
                        return "meta" === curr ? metaVars.forEach(function(v, j) {
                            j > 0 && (acc[v] = Object.keys(data[i]).reduce(function(a, c) {
                                return data[i][c][j] && (a[c] = data[i][c][j]), a;
                            }, {}));
                        }) : acc[curr] = data[i], acc;
                    }, {}) : {};
                }(fetchVars, data, metaVars);
            });
        }, exports.getScatterplotData = function() {
            if (arguments.length < 1) throw new Error("Cannot create scatterplot data with less than two variables");
            var merged = mergeDatasets.apply(void 0, arguments);
            return Object.keys(merged).map(function(k) {
                return merged[k];
            });
        };
    }, function(module, exports, __webpack_require__) {
        "use strict";
        (function(process) {
            var utils = __webpack_require__(11), normalizeHeaderName = __webpack_require__(159), DEFAULT_CONTENT_TYPE = {
                "Content-Type": "application/x-www-form-urlencoded"
            };
            function setContentTypeIfUnset(headers, value) {
                !utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"]) && (headers["Content-Type"] = value);
            }
            var defaults = {
                adapter: function() {
                    var adapter;
                    return "undefined" != typeof XMLHttpRequest ? adapter = __webpack_require__(78) : void 0 !== process && (adapter = __webpack_require__(78)), 
                    adapter;
                }(),
                transformRequest: [ function(data, headers) {
                    return normalizeHeaderName(headers, "Content-Type"), utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data) ? data : utils.isArrayBufferView(data) ? data.buffer : utils.isURLSearchParams(data) ? (setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8"), 
                    data.toString()) : utils.isObject(data) ? (setContentTypeIfUnset(headers, "application/json;charset=utf-8"), 
                    JSON.stringify(data)) : data;
                } ],
                transformResponse: [ function(data) {
                    if ("string" == typeof data) try {
                        data = JSON.parse(data);
                    } catch (e) {}
                    return data;
                } ],
                timeout: 0,
                xsrfCookieName: "XSRF-TOKEN",
                xsrfHeaderName: "X-XSRF-TOKEN",
                maxContentLength: -1,
                validateStatus: function(status) {
                    return status >= 200 && status < 300;
                },
                headers: {
                    common: {
                        Accept: "application/json, text/plain, */*"
                    }
                }
            };
            utils.forEach([ "delete", "get", "head" ], function(method) {
                defaults.headers[method] = {};
            }), utils.forEach([ "post", "put", "patch" ], function(method) {
                defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
            }), module.exports = defaults;
        }).call(this, __webpack_require__(158));
    }, function(module, exports) {
        var g;
        g = function() {
            return this;
        }();
        try {
            g = g || Function("return this")() || (0, eval)("this");
        } catch (e) {
            "object" == typeof window && (g = window);
        }
        module.exports = g;
    }, function(module, exports) {
        var DEFAULT_MIN_MERGE = 32, DEFAULT_MIN_GALLOPING = 7;
        function makeAscendingRun(array, lo, hi, compare) {
            var runHi = lo + 1;
            if (runHi === hi) return 1;
            if (compare(array[runHi++], array[lo]) < 0) {
                for (;runHi < hi && compare(array[runHi], array[runHi - 1]) < 0; ) runHi++;
                !function(array, lo, hi) {
                    hi--;
                    for (;lo < hi; ) {
                        var t = array[lo];
                        array[lo++] = array[hi], array[hi--] = t;
                    }
                }(array, lo, runHi);
            } else for (;runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0; ) runHi++;
            return runHi - lo;
        }
        function binaryInsertionSort(array, lo, hi, start, compare) {
            for (start === lo && start++; start < hi; start++) {
                for (var mid, pivot = array[start], left = lo, right = start; left < right; ) compare(pivot, array[mid = left + right >>> 1]) < 0 ? right = mid : left = mid + 1;
                var n = start - left;
                switch (n) {
                  case 3:
                    array[left + 3] = array[left + 2];

                  case 2:
                    array[left + 2] = array[left + 1];

                  case 1:
                    array[left + 1] = array[left];
                    break;

                  default:
                    for (;n > 0; ) array[left + n] = array[left + n - 1], n--;
                }
                array[left] = pivot;
            }
        }
        function gallopLeft(value, array, start, length, hint, compare) {
            var lastOffset = 0, maxOffset = 0, offset = 1;
            if (compare(value, array[start + hint]) > 0) {
                for (maxOffset = length - hint; offset < maxOffset && compare(value, array[start + hint + offset]) > 0; ) lastOffset = offset, 
                (offset = 1 + (offset << 1)) <= 0 && (offset = maxOffset);
                offset > maxOffset && (offset = maxOffset), lastOffset += hint, offset += hint;
            } else {
                for (maxOffset = hint + 1; offset < maxOffset && compare(value, array[start + hint - offset]) <= 0; ) lastOffset = offset, 
                (offset = 1 + (offset << 1)) <= 0 && (offset = maxOffset);
                offset > maxOffset && (offset = maxOffset);
                var tmp = lastOffset;
                lastOffset = hint - offset, offset = hint - tmp;
            }
            for (lastOffset++; lastOffset < offset; ) {
                var m = lastOffset + (offset - lastOffset >>> 1);
                compare(value, array[start + m]) > 0 ? lastOffset = m + 1 : offset = m;
            }
            return offset;
        }
        function gallopRight(value, array, start, length, hint, compare) {
            var lastOffset = 0, maxOffset = 0, offset = 1;
            if (compare(value, array[start + hint]) < 0) {
                for (maxOffset = hint + 1; offset < maxOffset && compare(value, array[start + hint - offset]) < 0; ) lastOffset = offset, 
                (offset = 1 + (offset << 1)) <= 0 && (offset = maxOffset);
                offset > maxOffset && (offset = maxOffset);
                var tmp = lastOffset;
                lastOffset = hint - offset, offset = hint - tmp;
            } else {
                for (maxOffset = length - hint; offset < maxOffset && compare(value, array[start + hint + offset]) >= 0; ) lastOffset = offset, 
                (offset = 1 + (offset << 1)) <= 0 && (offset = maxOffset);
                offset > maxOffset && (offset = maxOffset), lastOffset += hint, offset += hint;
            }
            for (lastOffset++; lastOffset < offset; ) {
                var m = lastOffset + (offset - lastOffset >>> 1);
                compare(value, array[start + m]) < 0 ? offset = m : lastOffset = m + 1;
            }
            return offset;
        }
        function TimSort(array, compare) {
            var length, runStart, runLength, minGallop = DEFAULT_MIN_GALLOPING, stackSize = 0;
            length = array.length;
            var tmp = [];
            function mergeAt(i) {
                var start1 = runStart[i], length1 = runLength[i], start2 = runStart[i + 1], length2 = runLength[i + 1];
                runLength[i] = length1 + length2, i === stackSize - 3 && (runStart[i + 1] = runStart[i + 2], 
                runLength[i + 1] = runLength[i + 2]), stackSize--;
                var k = gallopRight(array[start2], array, start1, length1, 0, compare);
                start1 += k, 0 !== (length1 -= k) && 0 !== (length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare)) && (length1 <= length2 ? function(start1, length1, start2, length2) {
                    var i = 0;
                    for (i = 0; i < length1; i++) tmp[i] = array[start1 + i];
                    var cursor1 = 0, cursor2 = start2, dest = start1;
                    if (array[dest++] = array[cursor2++], 0 == --length2) {
                        for (i = 0; i < length1; i++) array[dest + i] = tmp[cursor1 + i];
                        return;
                    }
                    if (1 === length1) {
                        for (i = 0; i < length2; i++) array[dest + i] = array[cursor2 + i];
                        return void (array[dest + length2] = tmp[cursor1]);
                    }
                    var count1, count2, exit, _minGallop = minGallop;
                    for (;;) {
                        count1 = 0, count2 = 0, exit = !1;
                        do {
                            if (compare(array[cursor2], tmp[cursor1]) < 0) {
                                if (array[dest++] = array[cursor2++], count2++, count1 = 0, 0 == --length2) {
                                    exit = !0;
                                    break;
                                }
                            } else if (array[dest++] = tmp[cursor1++], count1++, count2 = 0, 1 == --length1) {
                                exit = !0;
                                break;
                            }
                        } while ((count1 | count2) < _minGallop);
                        if (exit) break;
                        do {
                            if (0 !== (count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare))) {
                                for (i = 0; i < count1; i++) array[dest + i] = tmp[cursor1 + i];
                                if (dest += count1, cursor1 += count1, (length1 -= count1) <= 1) {
                                    exit = !0;
                                    break;
                                }
                            }
                            if (array[dest++] = array[cursor2++], 0 == --length2) {
                                exit = !0;
                                break;
                            }
                            if (0 !== (count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare))) {
                                for (i = 0; i < count2; i++) array[dest + i] = array[cursor2 + i];
                                if (dest += count2, cursor2 += count2, 0 === (length2 -= count2)) {
                                    exit = !0;
                                    break;
                                }
                            }
                            if (array[dest++] = tmp[cursor1++], 1 == --length1) {
                                exit = !0;
                                break;
                            }
                            _minGallop--;
                        } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
                        if (exit) break;
                        _minGallop < 0 && (_minGallop = 0), _minGallop += 2;
                    }
                    if ((minGallop = _minGallop) < 1 && (minGallop = 1), 1 === length1) {
                        for (i = 0; i < length2; i++) array[dest + i] = array[cursor2 + i];
                        array[dest + length2] = tmp[cursor1];
                    } else {
                        if (0 === length1) throw new Error();
                        for (i = 0; i < length1; i++) array[dest + i] = tmp[cursor1 + i];
                    }
                }(start1, length1, start2, length2) : function(start1, length1, start2, length2) {
                    var i = 0;
                    for (i = 0; i < length2; i++) tmp[i] = array[start2 + i];
                    var cursor1 = start1 + length1 - 1, cursor2 = length2 - 1, dest = start2 + length2 - 1, customCursor = 0, customDest = 0;
                    if (array[dest--] = array[cursor1--], 0 == --length1) {
                        for (customCursor = dest - (length2 - 1), i = 0; i < length2; i++) array[customCursor + i] = tmp[i];
                        return;
                    }
                    if (1 === length2) {
                        for (customDest = (dest -= length1) + 1, customCursor = (cursor1 -= length1) + 1, 
                        i = length1 - 1; i >= 0; i--) array[customDest + i] = array[customCursor + i];
                        return void (array[dest] = tmp[cursor2]);
                    }
                    var _minGallop = minGallop;
                    for (;;) {
                        var count1 = 0, count2 = 0, exit = !1;
                        do {
                            if (compare(tmp[cursor2], array[cursor1]) < 0) {
                                if (array[dest--] = array[cursor1--], count1++, count2 = 0, 0 == --length1) {
                                    exit = !0;
                                    break;
                                }
                            } else if (array[dest--] = tmp[cursor2--], count2++, count1 = 0, 1 == --length2) {
                                exit = !0;
                                break;
                            }
                        } while ((count1 | count2) < _minGallop);
                        if (exit) break;
                        do {
                            if (0 !== (count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare))) {
                                for (length1 -= count1, customDest = (dest -= count1) + 1, customCursor = (cursor1 -= count1) + 1, 
                                i = count1 - 1; i >= 0; i--) array[customDest + i] = array[customCursor + i];
                                if (0 === length1) {
                                    exit = !0;
                                    break;
                                }
                            }
                            if (array[dest--] = tmp[cursor2--], 1 == --length2) {
                                exit = !0;
                                break;
                            }
                            if (0 !== (count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare))) {
                                for (length2 -= count2, customDest = (dest -= count2) + 1, customCursor = (cursor2 -= count2) + 1, 
                                i = 0; i < count2; i++) array[customDest + i] = tmp[customCursor + i];
                                if (length2 <= 1) {
                                    exit = !0;
                                    break;
                                }
                            }
                            if (array[dest--] = array[cursor1--], 0 == --length1) {
                                exit = !0;
                                break;
                            }
                            _minGallop--;
                        } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
                        if (exit) break;
                        _minGallop < 0 && (_minGallop = 0), _minGallop += 2;
                    }
                    (minGallop = _minGallop) < 1 && (minGallop = 1);
                    if (1 === length2) {
                        for (customDest = (dest -= length1) + 1, customCursor = (cursor1 -= length1) + 1, 
                        i = length1 - 1; i >= 0; i--) array[customDest + i] = array[customCursor + i];
                        array[dest] = tmp[cursor2];
                    } else {
                        if (0 === length2) throw new Error();
                        for (customCursor = dest - (length2 - 1), i = 0; i < length2; i++) array[customCursor + i] = tmp[i];
                    }
                }(start1, length1, start2, length2));
            }
            runStart = [], runLength = [], this.mergeRuns = function() {
                for (;stackSize > 1; ) {
                    var n = stackSize - 2;
                    if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) runLength[n - 1] < runLength[n + 1] && n--; else if (runLength[n] > runLength[n + 1]) break;
                    mergeAt(n);
                }
            }, this.forceMergeRuns = function() {
                for (;stackSize > 1; ) {
                    var n = stackSize - 2;
                    n > 0 && runLength[n - 1] < runLength[n + 1] && n--, mergeAt(n);
                }
            }, this.pushRun = function(_runStart, _runLength) {
                runStart[stackSize] = _runStart, runLength[stackSize] = _runLength, stackSize += 1;
            };
        }
        module.exports = function(array, compare, lo, hi) {
            lo || (lo = 0), hi || (hi = array.length);
            var remaining = hi - lo;
            if (!(remaining < 2)) {
                var runLength = 0;
                if (remaining < DEFAULT_MIN_MERGE) binaryInsertionSort(array, lo, hi, lo + (runLength = makeAscendingRun(array, lo, hi, compare)), compare); else {
                    var ts = new TimSort(array, compare), minRun = function(n) {
                        for (var r = 0; n >= DEFAULT_MIN_MERGE; ) r |= 1 & n, n >>= 1;
                        return n + r;
                    }(remaining);
                    do {
                        if ((runLength = makeAscendingRun(array, lo, hi, compare)) < minRun) {
                            var force = remaining;
                            force > minRun && (force = minRun), binaryInsertionSort(array, lo, lo + force, lo + runLength, compare), 
                            runLength = force;
                        }
                        ts.pushRun(lo, runLength), ts.mergeRuns(), remaining -= runLength, lo += runLength;
                    } while (0 !== remaining);
                    ts.forceMergeRuns();
                }
            }
        };
    }, function(module, exports, __webpack_require__) {
        var fixShadow = __webpack_require__(93), ContextCachedBy = __webpack_require__(36).ContextCachedBy, STYLE_COMMON_PROPS = [ [ "shadowBlur", 0 ], [ "shadowOffsetX", 0 ], [ "shadowOffsetY", 0 ], [ "shadowColor", "#000" ], [ "lineCap", "butt" ], [ "lineJoin", "miter" ], [ "miterLimit", 10 ] ], Style = function(opts) {
            this.extendFrom(opts, !1);
        };
        function createLinearGradient(ctx, obj, rect) {
            var x = null == obj.x ? 0 : obj.x, x2 = null == obj.x2 ? 1 : obj.x2, y = null == obj.y ? 0 : obj.y, y2 = null == obj.y2 ? 0 : obj.y2;
            return obj.global || (x = x * rect.width + rect.x, x2 = x2 * rect.width + rect.x, 
            y = y * rect.height + rect.y, y2 = y2 * rect.height + rect.y), x = isNaN(x) ? 0 : x, 
            x2 = isNaN(x2) ? 1 : x2, y = isNaN(y) ? 0 : y, y2 = isNaN(y2) ? 0 : y2, ctx.createLinearGradient(x, y, x2, y2);
        }
        function createRadialGradient(ctx, obj, rect) {
            var width = rect.width, height = rect.height, min = Math.min(width, height), x = null == obj.x ? .5 : obj.x, y = null == obj.y ? .5 : obj.y, r = null == obj.r ? .5 : obj.r;
            return obj.global || (x = x * width + rect.x, y = y * height + rect.y, r *= min), 
            ctx.createRadialGradient(x, y, 0, x, y, r);
        }
        for (var styleProto = Style.prototype = {
            constructor: Style,
            fill: "#000",
            stroke: null,
            opacity: 1,
            fillOpacity: null,
            strokeOpacity: null,
            lineDash: null,
            lineDashOffset: 0,
            shadowBlur: 0,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            lineWidth: 1,
            strokeNoScale: !1,
            text: null,
            font: null,
            textFont: null,
            fontStyle: null,
            fontWeight: null,
            fontSize: null,
            fontFamily: null,
            textTag: null,
            textFill: "#000",
            textStroke: null,
            textWidth: null,
            textHeight: null,
            textStrokeWidth: 0,
            textLineHeight: null,
            textPosition: "inside",
            textRect: null,
            textOffset: null,
            textAlign: null,
            textVerticalAlign: null,
            textDistance: 5,
            textShadowColor: "transparent",
            textShadowBlur: 0,
            textShadowOffsetX: 0,
            textShadowOffsetY: 0,
            textBoxShadowColor: "transparent",
            textBoxShadowBlur: 0,
            textBoxShadowOffsetX: 0,
            textBoxShadowOffsetY: 0,
            transformText: !1,
            textRotation: 0,
            textOrigin: null,
            textBackgroundColor: null,
            textBorderColor: null,
            textBorderWidth: 0,
            textBorderRadius: 0,
            textPadding: null,
            rich: null,
            truncate: null,
            blend: null,
            bind: function(ctx, el, prevEl) {
                var prevStyle = prevEl && prevEl.style, notCheckCache = !prevStyle || ctx.__attrCachedBy !== ContextCachedBy.STYLE_BIND;
                ctx.__attrCachedBy = ContextCachedBy.STYLE_BIND;
                for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
                    var prop = STYLE_COMMON_PROPS[i], styleName = prop[0];
                    (notCheckCache || this[styleName] !== prevStyle[styleName]) && (ctx[styleName] = fixShadow(ctx, styleName, this[styleName] || prop[1]));
                }
                if ((notCheckCache || this.fill !== prevStyle.fill) && (ctx.fillStyle = this.fill), 
                (notCheckCache || this.stroke !== prevStyle.stroke) && (ctx.strokeStyle = this.stroke), 
                (notCheckCache || this.opacity !== prevStyle.opacity) && (ctx.globalAlpha = null == this.opacity ? 1 : this.opacity), 
                (notCheckCache || this.blend !== prevStyle.blend) && (ctx.globalCompositeOperation = this.blend || "source-over"), 
                this.hasStroke()) {
                    var lineWidth = this.lineWidth;
                    ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);
                }
            },
            hasFill: function() {
                var fill = this.fill;
                return null != fill && "none" !== fill;
            },
            hasStroke: function() {
                var stroke = this.stroke;
                return null != stroke && "none" !== stroke && this.lineWidth > 0;
            },
            extendFrom: function(otherStyle, overwrite) {
                if (otherStyle) for (var name in otherStyle) !otherStyle.hasOwnProperty(name) || !0 !== overwrite && (!1 === overwrite ? this.hasOwnProperty(name) : null == otherStyle[name]) || (this[name] = otherStyle[name]);
            },
            set: function(obj, value) {
                "string" == typeof obj ? this[obj] = value : this.extendFrom(obj, !0);
            },
            clone: function() {
                var newStyle = new this.constructor();
                return newStyle.extendFrom(this, !0), newStyle;
            },
            getGradient: function(ctx, obj, rect) {
                for (var canvasGradient = ("radial" === obj.type ? createRadialGradient : createLinearGradient)(ctx, obj, rect), colorStops = obj.colorStops, i = 0; i < colorStops.length; i++) canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);
                return canvasGradient;
            }
        }, i = 0; i < STYLE_COMMON_PROPS.length; i++) {
            var prop = STYLE_COMMON_PROPS[i];
            prop[0] in styleProto || (styleProto[prop[0]] = prop[1]);
        }
        Style.getGradient = styleProto.getGradient;
        var _default = Style;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var Displayable = __webpack_require__(37), BoundingRect = __webpack_require__(12), zrUtil = __webpack_require__(0), imageHelper = __webpack_require__(56);
        function ZImage(opts) {
            Displayable.call(this, opts);
        }
        ZImage.prototype = {
            constructor: ZImage,
            type: "image",
            brush: function(ctx, prevEl) {
                var style = this.style, src = style.image;
                style.bind(ctx, this, prevEl);
                var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this, this.onload);
                if (image && imageHelper.isImageReady(image)) {
                    var x = style.x || 0, y = style.y || 0, width = style.width, height = style.height, aspect = image.width / image.height;
                    if (null == width && null != height ? width = height * aspect : null == height && null != width ? height = width / aspect : null == width && null == height && (width = image.width, 
                    height = image.height), this.setTransform(ctx), style.sWidth && style.sHeight) {
                        var sx = style.sx || 0, sy = style.sy || 0;
                        ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
                    } else if (style.sx && style.sy) {
                        var sWidth = width - (sx = style.sx), sHeight = height - (sy = style.sy);
                        ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);
                    } else ctx.drawImage(image, x, y, width, height);
                    null != style.text && (this.restoreTransform(ctx), this.drawRectText(ctx, this.getBoundingRect()));
                }
            },
            getBoundingRect: function() {
                var style = this.style;
                return this._rect || (this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0)), 
                this._rect;
            }
        }, zrUtil.inherits(ZImage, Displayable);
        var _default = ZImage;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var globalImageCache = new (__webpack_require__(91))(50);
        function imageOnLoad() {
            var cachedImgObj = this.__cachedImgObj;
            this.onload = this.onerror = this.__cachedImgObj = null;
            for (var i = 0; i < cachedImgObj.pending.length; i++) {
                var pendingWrap = cachedImgObj.pending[i], cb = pendingWrap.cb;
                cb && cb(this, pendingWrap.cbPayload), pendingWrap.hostEl.dirty();
            }
            cachedImgObj.pending.length = 0;
        }
        function isImageReady(image) {
            return image && image.width && image.height;
        }
        exports.findExistImage = function(newImageOrSrc) {
            if ("string" == typeof newImageOrSrc) {
                var cachedImgObj = globalImageCache.get(newImageOrSrc);
                return cachedImgObj && cachedImgObj.image;
            }
            return newImageOrSrc;
        }, exports.createOrUpdateImage = function(newImageOrSrc, image, hostEl, cb, cbPayload) {
            if (newImageOrSrc) {
                if ("string" == typeof newImageOrSrc) {
                    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) return image;
                    var cachedImgObj = globalImageCache.get(newImageOrSrc), pendingWrap = {
                        hostEl: hostEl,
                        cb: cb,
                        cbPayload: cbPayload
                    };
                    return cachedImgObj ? !isImageReady(image = cachedImgObj.image) && cachedImgObj.pending.push(pendingWrap) : ((image = new Image()).onload = image.onerror = imageOnLoad, 
                    globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {
                        image: image,
                        pending: [ pendingWrap ]
                    }), image.src = image.__zrImageSrc = newImageOrSrc), image;
                }
                return newImageOrSrc;
            }
            return image;
        }, exports.isImageReady = isImageReady;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0);
        module.exports = function(properties) {
            for (var i = 0; i < properties.length; i++) properties[i][1] || (properties[i][1] = properties[i][0]);
            return function(model, excludes, includes) {
                for (var style = {}, i = 0; i < properties.length; i++) {
                    var propName = properties[i][1];
                    if (!(excludes && zrUtil.indexOf(excludes, propName) >= 0 || includes && zrUtil.indexOf(includes, propName) < 0)) {
                        var val = model.getShallow(propName);
                        null != val && (style[properties[i][0]] = val);
                    }
                }
                return style;
            };
        };
    }, function(module, exports, __webpack_require__) {
        var Displayable = __webpack_require__(37), zrUtil = __webpack_require__(0), textContain = __webpack_require__(21), textHelper = __webpack_require__(96), ContextCachedBy = __webpack_require__(36).ContextCachedBy, Text = function(opts) {
            Displayable.call(this, opts);
        };
        Text.prototype = {
            constructor: Text,
            type: "text",
            brush: function(ctx, prevEl) {
                var style = this.style;
                this.__dirty && textHelper.normalizeTextStyle(style, !0), style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;
                var text = style.text;
                null != text && (text += ""), textHelper.needDrawText(text, style) ? (this.setTransform(ctx), 
                textHelper.renderText(this, ctx, text, style, null, prevEl), this.restoreTransform(ctx)) : ctx.__attrCachedBy = ContextCachedBy.NONE;
            },
            getBoundingRect: function() {
                var style = this.style;
                if (this.__dirty && textHelper.normalizeTextStyle(style, !0), !this._rect) {
                    var text = style.text;
                    null != text ? text += "" : text = "";
                    var rect = textContain.getBoundingRect(style.text + "", style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.textLineHeight, style.rich);
                    if (rect.x += style.x || 0, rect.y += style.y || 0, textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {
                        var w = style.textStrokeWidth;
                        rect.x -= w / 2, rect.y -= w / 2, rect.width += w, rect.height += w;
                    }
                    this._rect = rect;
                }
                return this._rect;
            }
        }, zrUtil.inherits(Text, Displayable);
        var _default = Text;
        module.exports = _default;
    }, function(module, exports) {
        var round = Math.round;
        function subPixelOptimize(position, lineWidth, positiveOrNegative) {
            var doubledPosition = round(2 * position);
            return (doubledPosition + round(lineWidth)) % 2 == 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
        }
        exports.subPixelOptimizeLine = function(outputShape, inputShape, style) {
            var lineWidth = style && style.lineWidth;
            if (inputShape && lineWidth) {
                var x1 = inputShape.x1, x2 = inputShape.x2, y1 = inputShape.y1, y2 = inputShape.y2;
                round(2 * x1) === round(2 * x2) ? outputShape.x1 = outputShape.x2 = subPixelOptimize(x1, lineWidth, !0) : (outputShape.x1 = x1, 
                outputShape.x2 = x2), round(2 * y1) === round(2 * y2) ? outputShape.y1 = outputShape.y2 = subPixelOptimize(y1, lineWidth, !0) : (outputShape.y1 = y1, 
                outputShape.y2 = y2);
            }
        }, exports.subPixelOptimizeRect = function(outputShape, inputShape, style) {
            var lineWidth = style && style.lineWidth;
            if (inputShape && lineWidth) {
                var originX = inputShape.x, originY = inputShape.y, originWidth = inputShape.width, originHeight = inputShape.height;
                outputShape.x = subPixelOptimize(originX, lineWidth, !0), outputShape.y = subPixelOptimize(originY, lineWidth, !0), 
                outputShape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, !1) - outputShape.x, 0 === originWidth ? 0 : 1), 
                outputShape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, !1) - outputShape.y, 0 === originHeight ? 0 : 1);
            }
        }, exports.subPixelOptimize = subPixelOptimize;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), Gradient = __webpack_require__(61), LinearGradient = function(x, y, x2, y2, colorStops, globalCoord) {
            this.x = null == x ? 0 : x, this.y = null == y ? 0 : y, this.x2 = null == x2 ? 1 : x2, 
            this.y2 = null == y2 ? 0 : y2, this.type = "linear", this.global = globalCoord || !1, 
            Gradient.call(this, colorStops);
        };
        LinearGradient.prototype = {
            constructor: LinearGradient
        }, zrUtil.inherits(LinearGradient, Gradient);
        var _default = LinearGradient;
        module.exports = _default;
    }, function(module, exports) {
        var Gradient = function(colorStops) {
            this.colorStops = colorStops || [];
        };
        Gradient.prototype = {
            constructor: Gradient,
            addColorStop: function(offset, color) {
                this.colorStops.push({
                    offset: offset,
                    color: color
                });
            }
        };
        var _default = Gradient;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var inherits = __webpack_require__(0).inherits, Displayble = __webpack_require__(37), BoundingRect = __webpack_require__(12);
        function IncrementalDisplayble(opts) {
            Displayble.call(this, opts), this._displayables = [], this._temporaryDisplayables = [], 
            this._cursor = 0, this.notClear = !0;
        }
        IncrementalDisplayble.prototype.incremental = !0, IncrementalDisplayble.prototype.clearDisplaybles = function() {
            this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.dirty(), 
            this.notClear = !1;
        }, IncrementalDisplayble.prototype.addDisplayable = function(displayable, notPersistent) {
            notPersistent ? this._temporaryDisplayables.push(displayable) : this._displayables.push(displayable), 
            this.dirty();
        }, IncrementalDisplayble.prototype.addDisplayables = function(displayables, notPersistent) {
            notPersistent = notPersistent || !1;
            for (var i = 0; i < displayables.length; i++) this.addDisplayable(displayables[i], notPersistent);
        }, IncrementalDisplayble.prototype.eachPendingDisplayable = function(cb) {
            for (var i = this._cursor; i < this._displayables.length; i++) cb && cb(this._displayables[i]);
            for (i = 0; i < this._temporaryDisplayables.length; i++) cb && cb(this._temporaryDisplayables[i]);
        }, IncrementalDisplayble.prototype.update = function() {
            this.updateTransform();
            for (var i = this._cursor; i < this._displayables.length; i++) {
                (displayable = this._displayables[i]).parent = this, displayable.update(), displayable.parent = null;
            }
            for (i = 0; i < this._temporaryDisplayables.length; i++) {
                var displayable;
                (displayable = this._temporaryDisplayables[i]).parent = this, displayable.update(), 
                displayable.parent = null;
            }
        }, IncrementalDisplayble.prototype.brush = function(ctx, prevEl) {
            for (var i = this._cursor; i < this._displayables.length; i++) {
                (displayable = this._displayables[i]).beforeBrush && displayable.beforeBrush(ctx), 
                displayable.brush(ctx, i === this._cursor ? null : this._displayables[i - 1]), displayable.afterBrush && displayable.afterBrush(ctx);
            }
            this._cursor = i;
            for (i = 0; i < this._temporaryDisplayables.length; i++) {
                var displayable;
                (displayable = this._temporaryDisplayables[i]).beforeBrush && displayable.beforeBrush(ctx), 
                displayable.brush(ctx, 0 === i ? null : this._temporaryDisplayables[i - 1]), displayable.afterBrush && displayable.afterBrush(ctx);
            }
            this._temporaryDisplayables = [], this.notClear = !0;
        };
        var m = [];
        IncrementalDisplayble.prototype.getBoundingRect = function() {
            if (!this._rect) {
                for (var rect = new BoundingRect(1 / 0, 1 / 0, -1 / 0, -1 / 0), i = 0; i < this._displayables.length; i++) {
                    var displayable = this._displayables[i], childRect = displayable.getBoundingRect().clone();
                    displayable.needLocalTransform() && childRect.applyTransform(displayable.getLocalTransform(m)), 
                    rect.union(childRect);
                }
                this._rect = rect;
            }
            return this._rect;
        }, IncrementalDisplayble.prototype.contain = function(x, y) {
            var localPos = this.transformCoordToLocal(x, y);
            if (this.getBoundingRect().contain(localPos[0], localPos[1])) for (var i = 0; i < this._displayables.length; i++) {
                if (this._displayables[i].contain(x, y)) return !0;
            }
            return !1;
        }, inherits(IncrementalDisplayble, Displayble);
        var _default = IncrementalDisplayble;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var _util = __webpack_require__(0), isArray = (_util.assert, _util.isArray);
        __webpack_require__(5).__DEV__;
        function Task(define) {
            define = define || {}, this._reset = define.reset, this._plan = define.plan, this._count = define.count, 
            this._onDirty = define.onDirty, this._dirty = !0, this.context;
        }
        var taskProto = Task.prototype;
        taskProto.perform = function(performArgs) {
            var planResult, upTask = this._upstream, skip = performArgs && performArgs.skip;
            if (this._dirty && upTask) {
                var context = this.context;
                context.data = context.outputData = upTask.context.outputData;
            }
            this.__pipeline && (this.__pipeline.currentTask = this), this._plan && !skip && (planResult = this._plan(this.context));
            var forceFirstProgress, lastModBy = normalizeModBy(this._modBy), lastModDataCount = this._modDataCount || 0, modBy = normalizeModBy(performArgs && performArgs.modBy), modDataCount = performArgs && performArgs.modDataCount || 0;
            function normalizeModBy(val) {
                return !(val >= 1) && (val = 1), val;
            }
            lastModBy === modBy && lastModDataCount === modDataCount || (planResult = "reset"), 
            (this._dirty || "reset" === planResult) && (this._dirty = !1, forceFirstProgress = function(taskIns, skip) {
                var progress, forceFirstProgress;
                taskIns._dueIndex = taskIns._outputDueEnd = taskIns._dueEnd = 0, taskIns._settedOutputEnd = null, 
                !skip && taskIns._reset && ((progress = taskIns._reset(taskIns.context)) && progress.progress && (forceFirstProgress = progress.forceFirstProgress, 
                progress = progress.progress), isArray(progress) && !progress.length && (progress = null));
                taskIns._progress = progress, taskIns._modBy = taskIns._modDataCount = null;
                var downstream = taskIns._downstream;
                return downstream && downstream.dirty(), forceFirstProgress;
            }(this, skip)), this._modBy = modBy, this._modDataCount = modDataCount;
            var step = performArgs && performArgs.step;
            if (this._dueEnd = upTask ? upTask._outputDueEnd : this._count ? this._count(this.context) : 1 / 0, 
            this._progress) {
                var start = this._dueIndex, end = Math.min(null != step ? this._dueIndex + step : 1 / 0, this._dueEnd);
                if (!skip && (forceFirstProgress || start < end)) {
                    var progress = this._progress;
                    if (isArray(progress)) for (var i = 0; i < progress.length; i++) doProgress(this, progress[i], start, end, modBy, modDataCount); else doProgress(this, progress, start, end, modBy, modDataCount);
                }
                this._dueIndex = end;
                var outputDueEnd = null != this._settedOutputEnd ? this._settedOutputEnd : end;
                this._outputDueEnd = outputDueEnd;
            } else this._dueIndex = this._outputDueEnd = null != this._settedOutputEnd ? this._settedOutputEnd : this._dueEnd;
            return this.unfinished();
        };
        var iterator = function() {
            var end, current, modBy, modDataCount, winCount, it = {
                reset: function(s, e, sStep, sCount) {
                    current = s, end = e, modBy = sStep, modDataCount = sCount, winCount = Math.ceil(modDataCount / modBy), 
                    it.next = modBy > 1 && modDataCount > 0 ? modNext : sequentialNext;
                }
            };
            return it;
            function sequentialNext() {
                return current < end ? current++ : null;
            }
            function modNext() {
                var dataIndex = current % winCount * modBy + Math.ceil(current / winCount), result = current >= end ? null : dataIndex < modDataCount ? dataIndex : current;
                return current++, result;
            }
        }();
        function doProgress(taskIns, progress, start, end, modBy, modDataCount) {
            iterator.reset(start, end, modBy, modDataCount), taskIns._callingProgress = progress, 
            taskIns._callingProgress({
                start: start,
                end: end,
                count: end - start,
                next: iterator.next
            }, taskIns.context);
        }
        taskProto.dirty = function() {
            this._dirty = !0, this._onDirty && this._onDirty(this.context);
        }, taskProto.unfinished = function() {
            return this._progress && this._dueIndex < this._dueEnd;
        }, taskProto.pipe = function(downTask) {
            (this._downstream !== downTask || this._dirty) && (this._downstream = downTask, 
            downTask._upstream = this, downTask.dirty());
        }, taskProto.dispose = function() {
            this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), 
            this._dirty = !1, this._disposed = !0);
        }, taskProto.getUpstream = function() {
            return this._upstream;
        }, taskProto.getDownstream = function() {
            return this._downstream;
        }, taskProto.setOutputEnd = function(end) {
            this._outputDueEnd = this._settedOutputEnd = end;
        }, exports.createTask = function(define) {
            return new Task(define);
        };
    }, function(module, exports, __webpack_require__) {
        var Group = __webpack_require__(27), componentUtil = __webpack_require__(39), clazzUtil = __webpack_require__(18), Component = function() {
            this.group = new Group(), this.uid = componentUtil.getUID("viewComponent");
        }, componentProto = Component.prototype = {
            constructor: Component,
            init: function(ecModel, api) {},
            render: function(componentModel, ecModel, api, payload) {},
            dispose: function() {},
            filterForExposedEvent: null
        };
        componentProto.updateView = componentProto.updateLayout = componentProto.updateVisual = function(seriesModel, ecModel, api, payload) {}, 
        clazzUtil.enableClassExtend(Component), clazzUtil.enableClassManagement(Component, {
            registerWhenExtend: !0
        });
        var _default = Component;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var each = __webpack_require__(0).each, Group = __webpack_require__(27), componentUtil = __webpack_require__(39), clazzUtil = __webpack_require__(18), modelUtil = __webpack_require__(3), graphicUtil = __webpack_require__(2), createTask = __webpack_require__(63).createTask, createRenderPlanner = __webpack_require__(42), inner = modelUtil.makeInner(), renderPlanner = createRenderPlanner();
        function Chart() {
            this.group = new Group(), this.uid = componentUtil.getUID("viewChart"), this.renderTask = createTask({
                plan: renderTaskPlan,
                reset: renderTaskReset
            }), this.renderTask.context = {
                view: this
            };
        }
        Chart.prototype = {
            type: "chart",
            init: function(ecModel, api) {},
            render: function(seriesModel, ecModel, api, payload) {},
            highlight: function(seriesModel, ecModel, api, payload) {
                toggleHighlight(seriesModel.getData(), payload, "emphasis");
            },
            downplay: function(seriesModel, ecModel, api, payload) {
                toggleHighlight(seriesModel.getData(), payload, "normal");
            },
            remove: function(ecModel, api) {
                this.group.removeAll();
            },
            dispose: function() {},
            incrementalPrepareRender: null,
            incrementalRender: null,
            updateTransform: null,
            filterForExposedEvent: null
        };
        var chartProto = Chart.prototype;
        function elSetState(el, state, highlightDigit) {
            if (el && (el.trigger(state, highlightDigit), el.isGroup && !graphicUtil.isHighDownDispatcher(el))) for (var i = 0, len = el.childCount(); i < len; i++) elSetState(el.childAt(i), state, highlightDigit);
        }
        function toggleHighlight(data, payload, state) {
            var dataIndex = modelUtil.queryDataIndex(data, payload), highlightDigit = payload && null != payload.highlightKey ? graphicUtil.getHighlightDigit(payload.highlightKey) : null;
            null != dataIndex ? each(modelUtil.normalizeToArray(dataIndex), function(dataIdx) {
                elSetState(data.getItemGraphicEl(dataIdx), state, highlightDigit);
            }) : data.eachItemGraphicEl(function(el) {
                elSetState(el, state, highlightDigit);
            });
        }
        function renderTaskPlan(context) {
            return renderPlanner(context.model);
        }
        function renderTaskReset(context) {
            var seriesModel = context.model, ecModel = context.ecModel, api = context.api, payload = context.payload, progressiveRender = seriesModel.pipelineContext.progressiveRender, view = context.view, updateMethod = payload && inner(payload).updateMethod, methodName = progressiveRender ? "incrementalPrepareRender" : updateMethod && view[updateMethod] ? updateMethod : "render";
            return "render" !== methodName && view[methodName](seriesModel, ecModel, api, payload), 
            progressMethodMap[methodName];
        }
        chartProto.updateView = chartProto.updateLayout = chartProto.updateVisual = function(seriesModel, ecModel, api, payload) {
            this.render(seriesModel, ecModel, api, payload);
        }, clazzUtil.enableClassExtend(Chart, [ "dispose" ]), clazzUtil.enableClassManagement(Chart, {
            registerWhenExtend: !0
        }), Chart.markUpdateMethod = function(payload, methodName) {
            inner(payload).updateMethod = methodName;
        };
        var progressMethodMap = {
            incrementalPrepareRender: {
                progress: function(params, context) {
                    context.view.incrementalRender(params, context.model, context.ecModel, context.api, context.payload);
                }
            },
            render: {
                forceFirstProgress: !0,
                progress: function(params, context) {
                    context.view.render(context.model, context.ecModel, context.api, context.payload);
                }
            }
        }, _default = Chart;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var _util = __webpack_require__(0), each = _util.each, createHashMap = _util.createHashMap, OTHER_DIMENSIONS = (_util.assert, 
        __webpack_require__(5).__DEV__, createHashMap([ "tooltip", "label", "itemName", "itemId", "seriesName" ]));
        function getOrCreateEncodeArr(encode, dim) {
            return encode.hasOwnProperty(dim) || (encode[dim] = []), encode[dim];
        }
        exports.OTHER_DIMENSIONS = OTHER_DIMENSIONS, exports.summarizeDimensions = function(data) {
            var summary = {}, encode = summary.encode = {}, notExtraCoordDimMap = createHashMap(), defaultedLabel = [], defaultedTooltip = [], userOutput = summary.userOutput = {
                dimensionNames: data.dimensions.slice(),
                encode: {}
            };
            each(data.dimensions, function(dimName) {
                var dimItem = data.getDimensionInfo(dimName), coordDim = dimItem.coordDim;
                if (coordDim) {
                    var coordDimIndex = dimItem.coordDimIndex;
                    getOrCreateEncodeArr(encode, coordDim)[coordDimIndex] = dimName, dimItem.isExtraCoord || (notExtraCoordDimMap.set(coordDim, 1), 
                    function(dimType) {
                        return !("ordinal" === dimType || "time" === dimType);
                    }(dimItem.type) && (defaultedLabel[0] = dimName), getOrCreateEncodeArr(userOutput.encode, coordDim)[coordDimIndex] = dimItem.index), 
                    dimItem.defaultTooltip && defaultedTooltip.push(dimName);
                }
                OTHER_DIMENSIONS.each(function(v, otherDim) {
                    var encodeArr = getOrCreateEncodeArr(encode, otherDim), dimIndex = dimItem.otherDims[otherDim];
                    null != dimIndex && !1 !== dimIndex && (encodeArr[dimIndex] = dimItem.name);
                });
            });
            var dataDimsOnCoord = [], encodeFirstDimNotExtra = {};
            notExtraCoordDimMap.each(function(v, coordDim) {
                var dimArr = encode[coordDim];
                encodeFirstDimNotExtra[coordDim] = dimArr[0], dataDimsOnCoord = dataDimsOnCoord.concat(dimArr);
            }), summary.dataDimsOnCoord = dataDimsOnCoord, summary.encodeFirstDimNotExtra = encodeFirstDimNotExtra;
            var encodeLabel = encode.label;
            encodeLabel && encodeLabel.length && (defaultedLabel = encodeLabel.slice());
            var encodeTooltip = encode.tooltip;
            return encodeTooltip && encodeTooltip.length ? defaultedTooltip = encodeTooltip.slice() : defaultedTooltip.length || (defaultedTooltip = defaultedLabel.slice()), 
            encode.defaultedLabel = defaultedLabel, encode.defaultedTooltip = defaultedTooltip, 
            summary;
        }, exports.getDimensionTypeByAxis = function(axisType) {
            return "category" === axisType ? "ordinal" : "time" === axisType ? "time" : "float";
        };
    }, function(module, exports, __webpack_require__) {
        var numberUtil = __webpack_require__(4), formatUtil = __webpack_require__(9), Scale = __webpack_require__(43), helper = __webpack_require__(120), roundNumber = numberUtil.round, IntervalScale = Scale.extend({
            type: "interval",
            _interval: 0,
            _intervalPrecision: 2,
            setExtent: function(start, end) {
                var thisExtent = this._extent;
                isNaN(start) || (thisExtent[0] = parseFloat(start)), isNaN(end) || (thisExtent[1] = parseFloat(end));
            },
            unionExtent: function(other) {
                var extent = this._extent;
                other[0] < extent[0] && (extent[0] = other[0]), other[1] > extent[1] && (extent[1] = other[1]), 
                IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);
            },
            getInterval: function() {
                return this._interval;
            },
            setInterval: function(interval) {
                this._interval = interval, this._niceExtent = this._extent.slice(), this._intervalPrecision = helper.getIntervalPrecision(interval);
            },
            getTicks: function() {
                return helper.intervalScaleGetTicks(this._interval, this._extent, this._niceExtent, this._intervalPrecision);
            },
            getLabel: function(data, opt) {
                if (null == data) return "";
                var precision = opt && opt.precision;
                return null == precision ? precision = numberUtil.getPrecisionSafe(data) || 0 : "auto" === precision && (precision = this._intervalPrecision), 
                data = roundNumber(data, precision, !0), formatUtil.addCommas(data);
            },
            niceTicks: function(splitNumber, minInterval, maxInterval) {
                splitNumber = splitNumber || 5;
                var extent = this._extent, span = extent[1] - extent[0];
                if (isFinite(span)) {
                    span < 0 && (span = -span, extent.reverse());
                    var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval);
                    this._intervalPrecision = result.intervalPrecision, this._interval = result.interval, 
                    this._niceExtent = result.niceTickExtent;
                }
            },
            niceExtent: function(opt) {
                var extent = this._extent;
                if (extent[0] === extent[1]) if (0 !== extent[0]) {
                    var expandSize = extent[0];
                    opt.fixMax ? extent[0] -= expandSize / 2 : (extent[1] += expandSize / 2, extent[0] -= expandSize / 2);
                } else extent[1] = 1;
                var span = extent[1] - extent[0];
                isFinite(span) || (extent[0] = 0, extent[1] = 1), this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
                var interval = this._interval;
                opt.fixMin || (extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval)), 
                opt.fixMax || (extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval));
            }
        });
        IntervalScale.create = function() {
            return new IntervalScale();
        };
        var _default = IntervalScale;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), createSymbol = __webpack_require__(16).createSymbol, graphic = __webpack_require__(2), parsePercent = __webpack_require__(4).parsePercent, getDefaultLabel = __webpack_require__(124).getDefaultLabel;
        function SymbolClz(data, idx, seriesScope) {
            graphic.Group.call(this), this.updateData(data, idx, seriesScope);
        }
        var symbolProto = SymbolClz.prototype, getSymbolSize = SymbolClz.getSymbolSize = function(data, idx) {
            var symbolSize = data.getItemVisual(idx, "symbolSize");
            return symbolSize instanceof Array ? symbolSize.slice() : [ +symbolSize, +symbolSize ];
        };
        function getScale(symbolSize) {
            return [ symbolSize[0] / 2, symbolSize[1] / 2 ];
        }
        function driftSymbol(dx, dy) {
            this.parent.drift(dx, dy);
        }
        symbolProto._createSymbol = function(symbolType, data, idx, symbolSize, keepAspect) {
            this.removeAll();
            var color = data.getItemVisual(idx, "color"), symbolPath = createSymbol(symbolType, -1, -1, 2, 2, color, keepAspect);
            symbolPath.attr({
                z2: 100,
                culling: !0,
                scale: getScale(symbolSize)
            }), symbolPath.drift = driftSymbol, this._symbolType = symbolType, this.add(symbolPath);
        }, symbolProto.stopSymbolAnimation = function(toLastFrame) {
            this.childAt(0).stopAnimation(toLastFrame);
        }, symbolProto.getSymbolPath = function() {
            return this.childAt(0);
        }, symbolProto.getScale = function() {
            return this.childAt(0).scale;
        }, symbolProto.highlight = function() {
            this.childAt(0).trigger("emphasis");
        }, symbolProto.downplay = function() {
            this.childAt(0).trigger("normal");
        }, symbolProto.setZ = function(zlevel, z) {
            var symbolPath = this.childAt(0);
            symbolPath.zlevel = zlevel, symbolPath.z = z;
        }, symbolProto.setDraggable = function(draggable) {
            var symbolPath = this.childAt(0);
            symbolPath.draggable = draggable, symbolPath.cursor = draggable ? "move" : symbolPath.cursor;
        }, symbolProto.updateData = function(data, idx, seriesScope) {
            this.silent = !1;
            var symbolType = data.getItemVisual(idx, "symbol") || "circle", seriesModel = data.hostModel, symbolSize = getSymbolSize(data, idx), isInit = symbolType !== this._symbolType;
            if (isInit) {
                var keepAspect = data.getItemVisual(idx, "symbolKeepAspect");
                this._createSymbol(symbolType, data, idx, symbolSize, keepAspect);
            } else {
                (symbolPath = this.childAt(0)).silent = !1, graphic.updateProps(symbolPath, {
                    scale: getScale(symbolSize)
                }, seriesModel, idx);
            }
            if (this._updateCommon(data, idx, symbolSize, seriesScope), isInit) {
                var symbolPath = this.childAt(0), fadeIn = seriesScope && seriesScope.fadeIn, target = {
                    scale: symbolPath.scale.slice()
                };
                fadeIn && (target.style = {
                    opacity: symbolPath.style.opacity
                }), symbolPath.scale = [ 0, 0 ], fadeIn && (symbolPath.style.opacity = 0), graphic.initProps(symbolPath, target, seriesModel, idx);
            }
            this._seriesModel = seriesModel;
        };
        var normalStyleAccessPath = [ "itemStyle" ], emphasisStyleAccessPath = [ "emphasis", "itemStyle" ], normalLabelAccessPath = [ "label" ], emphasisLabelAccessPath = [ "emphasis", "label" ];
        function highDownOnUpdate(fromState, toState) {
            if (!this.incremental && !this.useHoverLayer) if ("emphasis" === toState) {
                var scale = this.__symbolOriginalScale, ratio = scale[1] / scale[0], emphasisOpt = {
                    scale: [ Math.max(1.1 * scale[0], scale[0] + 3), Math.max(1.1 * scale[1], scale[1] + 3 * ratio) ]
                };
                this.animateTo(emphasisOpt, 400, "elasticOut");
            } else "normal" === toState && this.animateTo({
                scale: this.__symbolOriginalScale
            }, 400, "elasticOut");
        }
        symbolProto._updateCommon = function(data, idx, symbolSize, seriesScope) {
            var symbolPath = this.childAt(0), seriesModel = data.hostModel, color = data.getItemVisual(idx, "color");
            "image" !== symbolPath.type && symbolPath.useStyle({
                strokeNoScale: !0
            });
            var itemStyle = seriesScope && seriesScope.itemStyle, hoverItemStyle = seriesScope && seriesScope.hoverItemStyle, symbolRotate = seriesScope && seriesScope.symbolRotate, symbolOffset = seriesScope && seriesScope.symbolOffset, labelModel = seriesScope && seriesScope.labelModel, hoverLabelModel = seriesScope && seriesScope.hoverLabelModel, hoverAnimation = seriesScope && seriesScope.hoverAnimation, cursorStyle = seriesScope && seriesScope.cursorStyle;
            if (!seriesScope || data.hasItemOption) {
                var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx);
                itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle([ "color" ]), 
                hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle(), symbolRotate = itemModel.getShallow("symbolRotate"), 
                symbolOffset = itemModel.getShallow("symbolOffset"), labelModel = itemModel.getModel(normalLabelAccessPath), 
                hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath), hoverAnimation = itemModel.getShallow("hoverAnimation"), 
                cursorStyle = itemModel.getShallow("cursor");
            } else hoverItemStyle = zrUtil.extend({}, hoverItemStyle);
            var elStyle = symbolPath.style;
            symbolPath.attr("rotation", (symbolRotate || 0) * Math.PI / 180 || 0), symbolOffset && symbolPath.attr("position", [ parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1]) ]), 
            cursorStyle && symbolPath.attr("cursor", cursorStyle), symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor), 
            symbolPath.setStyle(itemStyle);
            var opacity = data.getItemVisual(idx, "opacity");
            null != opacity && (elStyle.opacity = opacity);
            var liftZ = data.getItemVisual(idx, "liftZ"), z2Origin = symbolPath.__z2Origin;
            null != liftZ ? null == z2Origin && (symbolPath.__z2Origin = symbolPath.z2, symbolPath.z2 += liftZ) : null != z2Origin && (symbolPath.z2 = z2Origin, 
            symbolPath.__z2Origin = null);
            var useNameLabel = seriesScope && seriesScope.useNameLabel;
            graphic.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {
                labelFetcher: seriesModel,
                labelDataIndex: idx,
                defaultText: function(idx, opt) {
                    return useNameLabel ? data.getName(idx) : getDefaultLabel(data, idx);
                },
                isRectText: !0,
                autoColor: color
            }), symbolPath.__symbolOriginalScale = getScale(symbolSize), symbolPath.hoverStyle = hoverItemStyle, 
            symbolPath.highDownOnUpdate = hoverAnimation && seriesModel.isAnimationEnabled() ? highDownOnUpdate : null, 
            graphic.setHoverStyle(symbolPath);
        }, symbolProto.fadeOut = function(cb, opt) {
            var symbolPath = this.childAt(0);
            this.silent = symbolPath.silent = !0, (!opt || !opt.keepLabel) && (symbolPath.style.text = null), 
            graphic.updateProps(symbolPath, {
                style: {
                    opacity: 0
                },
                scale: [ 0, 0 ]
            }, this._seriesModel, this.dataIndex, cb);
        }, zrUtil.inherits(SymbolClz, graphic.Group);
        var _default = SymbolClz;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var isFunction = __webpack_require__(0).isFunction;
        module.exports = function(seriesType, defaultSymbolType, legendSymbol) {
            return {
                seriesType: seriesType,
                performRawSeries: !0,
                reset: function(seriesModel, ecModel, api) {
                    var data = seriesModel.getData(), symbolType = seriesModel.get("symbol"), symbolSize = seriesModel.get("symbolSize"), keepAspect = seriesModel.get("symbolKeepAspect"), hasSymbolTypeCallback = isFunction(symbolType), hasSymbolSizeCallback = isFunction(symbolSize), hasCallback = hasSymbolTypeCallback || hasSymbolSizeCallback, seriesSymbol = !hasSymbolTypeCallback && symbolType ? symbolType : defaultSymbolType, seriesSymbolSize = hasSymbolSizeCallback ? null : symbolSize;
                    if (data.setVisual({
                        legendSymbol: legendSymbol || seriesSymbol,
                        symbol: seriesSymbol,
                        symbolSize: seriesSymbolSize,
                        symbolKeepAspect: keepAspect
                    }), !ecModel.isSeriesFiltered(seriesModel)) return {
                        dataEach: data.hasItemOption || hasCallback ? function(data, idx) {
                            if (hasCallback) {
                                var rawValue = seriesModel.getRawValue(idx), params = seriesModel.getDataParams(idx);
                                hasSymbolTypeCallback && data.setItemVisual(idx, "symbol", symbolType(rawValue, params)), 
                                hasSymbolSizeCallback && data.setItemVisual(idx, "symbolSize", symbolSize(rawValue, params));
                            }
                            if (data.hasItemOption) {
                                var itemModel = data.getItemModel(idx), itemSymbolType = itemModel.getShallow("symbol", !0), itemSymbolSize = itemModel.getShallow("symbolSize", !0), itemSymbolKeepAspect = itemModel.getShallow("symbolKeepAspect", !0);
                                null != itemSymbolType && data.setItemVisual(idx, "symbol", itemSymbolType), null != itemSymbolSize && data.setItemVisual(idx, "symbolSize", itemSymbolSize), 
                                null != itemSymbolKeepAspect && data.setItemVisual(idx, "symbolKeepAspect", itemSymbolKeepAspect);
                            }
                        } : null
                    };
                }
            };
        };
    }, function(module, exports, __webpack_require__) {
        var echarts = __webpack_require__(1), zrUtil = __webpack_require__(0), graphic = __webpack_require__(2);
        __webpack_require__(249), __webpack_require__(256), echarts.extendComponentView({
            type: "grid",
            render: function(gridModel, ecModel) {
                this.group.removeAll(), gridModel.get("show") && this.group.add(new graphic.Rect({
                    shape: gridModel.coordinateSystem.getRect(),
                    style: zrUtil.defaults({
                        fill: gridModel.get("backgroundColor")
                    }, gridModel.getItemStyle()),
                    silent: !0,
                    z2: -1
                }));
            }
        }), echarts.registerPreprocessor(function(option) {
            option.xAxis && option.yAxis && !option.grid && (option.grid = {});
        });
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), vector = __webpack_require__(6), symbolUtil = __webpack_require__(16), LinePath = __webpack_require__(261), graphic = __webpack_require__(2), round = __webpack_require__(4).round, SYMBOL_CATEGORIES = [ "fromSymbol", "toSymbol" ];
        function makeSymbolTypeKey(symbolCategory) {
            return "_" + symbolCategory + "Type";
        }
        function createSymbol(name, lineData, idx) {
            var color = lineData.getItemVisual(idx, "color"), symbolType = lineData.getItemVisual(idx, name), symbolSize = lineData.getItemVisual(idx, name + "Size");
            if (symbolType && "none" !== symbolType) {
                zrUtil.isArray(symbolSize) || (symbolSize = [ symbolSize, symbolSize ]);
                var symbolPath = symbolUtil.createSymbol(symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2, symbolSize[0], symbolSize[1], color);
                return symbolPath.name = name, symbolPath;
            }
        }
        function setLinePoints(targetShape, points) {
            targetShape.x1 = points[0][0], targetShape.y1 = points[0][1], targetShape.x2 = points[1][0], 
            targetShape.y2 = points[1][1], targetShape.percent = 1;
            var cp1 = points[2];
            cp1 ? (targetShape.cpx1 = cp1[0], targetShape.cpy1 = cp1[1]) : (targetShape.cpx1 = NaN, 
            targetShape.cpy1 = NaN);
        }
        function Line(lineData, idx, seriesScope) {
            graphic.Group.call(this), this._createLine(lineData, idx, seriesScope);
        }
        var lineProto = Line.prototype;
        lineProto.beforeUpdate = function() {
            var symbolFrom = this.childOfName("fromSymbol"), symbolTo = this.childOfName("toSymbol"), label = this.childOfName("label");
            if (symbolFrom || symbolTo || !label.ignore) {
                for (var invScale = 1, parentNode = this.parent; parentNode; ) parentNode.scale && (invScale /= parentNode.scale[0]), 
                parentNode = parentNode.parent;
                var line = this.childOfName("line");
                if (this.__dirty || line.__dirty) {
                    var percent = line.shape.percent, fromPos = line.pointAt(0), toPos = line.pointAt(percent), d = vector.sub([], toPos, fromPos);
                    if (vector.normalize(d, d), symbolFrom) {
                        symbolFrom.attr("position", fromPos);
                        var tangent = line.tangentAt(0);
                        symbolFrom.attr("rotation", Math.PI / 2 - Math.atan2(tangent[1], tangent[0])), symbolFrom.attr("scale", [ invScale * percent, invScale * percent ]);
                    }
                    if (symbolTo && (symbolTo.attr("position", toPos), tangent = line.tangentAt(1), 
                    symbolTo.attr("rotation", -Math.PI / 2 - Math.atan2(tangent[1], tangent[0])), symbolTo.attr("scale", [ invScale * percent, invScale * percent ])), 
                    !label.ignore) {
                        var textPosition, textAlign, textVerticalAlign;
                        label.attr("position", toPos);
                        var distance = 5 * invScale;
                        if ("end" === label.__position) textPosition = [ d[0] * distance + toPos[0], d[1] * distance + toPos[1] ], 
                        textAlign = d[0] > .8 ? "left" : d[0] < -.8 ? "right" : "center", textVerticalAlign = d[1] > .8 ? "top" : d[1] < -.8 ? "bottom" : "middle"; else if ("middle" === label.__position) {
                            var halfPercent = percent / 2, n = [ (tangent = line.tangentAt(halfPercent))[1], -tangent[0] ], cp = line.pointAt(halfPercent);
                            n[1] > 0 && (n[0] = -n[0], n[1] = -n[1]), textPosition = [ cp[0] + n[0] * distance, cp[1] + n[1] * distance ], 
                            textAlign = "center", textVerticalAlign = "bottom";
                            var rotation = -Math.atan2(tangent[1], tangent[0]);
                            toPos[0] < fromPos[0] && (rotation = Math.PI + rotation), label.attr("rotation", rotation);
                        } else textPosition = [ -d[0] * distance + fromPos[0], -d[1] * distance + fromPos[1] ], 
                        textAlign = d[0] > .8 ? "right" : d[0] < -.8 ? "left" : "center", textVerticalAlign = d[1] > .8 ? "bottom" : d[1] < -.8 ? "top" : "middle";
                        label.attr({
                            style: {
                                textVerticalAlign: label.__verticalAlign || textVerticalAlign,
                                textAlign: label.__textAlign || textAlign
                            },
                            position: textPosition,
                            scale: [ invScale, invScale ]
                        });
                    }
                }
            }
        }, lineProto._createLine = function(lineData, idx, seriesScope) {
            var seriesModel = lineData.hostModel, line = function(points) {
                var line = new LinePath({
                    name: "line",
                    subPixelOptimize: !0
                });
                return setLinePoints(line.shape, points), line;
            }(lineData.getItemLayout(idx));
            line.shape.percent = 0, graphic.initProps(line, {
                shape: {
                    percent: 1
                }
            }, seriesModel, idx), this.add(line);
            var label = new graphic.Text({
                name: "label",
                lineLabelOriginalOpacity: 1
            });
            this.add(label), zrUtil.each(SYMBOL_CATEGORIES, function(symbolCategory) {
                var symbol = createSymbol(symbolCategory, lineData, idx);
                this.add(symbol), this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory);
            }, this), this._updateCommonStl(lineData, idx, seriesScope);
        }, lineProto.updateData = function(lineData, idx, seriesScope) {
            var seriesModel = lineData.hostModel, line = this.childOfName("line"), linePoints = lineData.getItemLayout(idx), target = {
                shape: {}
            };
            setLinePoints(target.shape, linePoints), graphic.updateProps(line, target, seriesModel, idx), 
            zrUtil.each(SYMBOL_CATEGORIES, function(symbolCategory) {
                var symbolType = lineData.getItemVisual(idx, symbolCategory), key = makeSymbolTypeKey(symbolCategory);
                if (this[key] !== symbolType) {
                    this.remove(this.childOfName(symbolCategory));
                    var symbol = createSymbol(symbolCategory, lineData, idx);
                    this.add(symbol);
                }
                this[key] = symbolType;
            }, this), this._updateCommonStl(lineData, idx, seriesScope);
        }, lineProto._updateCommonStl = function(lineData, idx, seriesScope) {
            var seriesModel = lineData.hostModel, line = this.childOfName("line"), lineStyle = seriesScope && seriesScope.lineStyle, hoverLineStyle = seriesScope && seriesScope.hoverLineStyle, labelModel = seriesScope && seriesScope.labelModel, hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;
            if (!seriesScope || lineData.hasItemOption) {
                var itemModel = lineData.getItemModel(idx);
                lineStyle = itemModel.getModel("lineStyle").getLineStyle(), hoverLineStyle = itemModel.getModel("emphasis.lineStyle").getLineStyle(), 
                labelModel = itemModel.getModel("label"), hoverLabelModel = itemModel.getModel("emphasis.label");
            }
            var visualColor = lineData.getItemVisual(idx, "color"), visualOpacity = zrUtil.retrieve3(lineData.getItemVisual(idx, "opacity"), lineStyle.opacity, 1);
            line.useStyle(zrUtil.defaults({
                strokeNoScale: !0,
                fill: "none",
                stroke: visualColor,
                opacity: visualOpacity
            }, lineStyle)), line.hoverStyle = hoverLineStyle, zrUtil.each(SYMBOL_CATEGORIES, function(symbolCategory) {
                var symbol = this.childOfName(symbolCategory);
                symbol && (symbol.setColor(visualColor), symbol.setStyle({
                    opacity: visualOpacity
                }));
            }, this);
            var defaultLabelColor, baseText, showLabel = labelModel.getShallow("show"), hoverShowLabel = hoverLabelModel.getShallow("show"), label = this.childOfName("label");
            if ((showLabel || hoverShowLabel) && (defaultLabelColor = visualColor || "#000", 
            null == (baseText = seriesModel.getFormattedLabel(idx, "normal", lineData.dataType)))) {
                var rawVal = seriesModel.getRawValue(idx);
                baseText = null == rawVal ? lineData.getName(idx) : isFinite(rawVal) ? round(rawVal) : rawVal;
            }
            var normalText = showLabel ? baseText : null, emphasisText = hoverShowLabel ? zrUtil.retrieve2(seriesModel.getFormattedLabel(idx, "emphasis", lineData.dataType), baseText) : null, labelStyle = label.style;
            null == normalText && null == emphasisText || (graphic.setTextStyle(label.style, labelModel, {
                text: normalText
            }, {
                autoColor: defaultLabelColor
            }), label.__textAlign = labelStyle.textAlign, label.__verticalAlign = labelStyle.textVerticalAlign, 
            label.__position = labelModel.get("position") || "middle"), label.hoverStyle = null != emphasisText ? {
                text: emphasisText,
                textFill: hoverLabelModel.getTextColor(!0),
                fontStyle: hoverLabelModel.getShallow("fontStyle"),
                fontWeight: hoverLabelModel.getShallow("fontWeight"),
                fontSize: hoverLabelModel.getShallow("fontSize"),
                fontFamily: hoverLabelModel.getShallow("fontFamily")
            } : {
                text: null
            }, label.ignore = !showLabel && !hoverShowLabel, graphic.setHoverStyle(this);
        }, lineProto.highlight = function() {
            this.trigger("emphasis");
        }, lineProto.downplay = function() {
            this.trigger("normal");
        }, lineProto.updateLayout = function(lineData, idx) {
            this.setLinePoints(lineData.getItemLayout(idx));
        }, lineProto.setLinePoints = function(points) {
            var linePath = this.childOfName("line");
            setLinePoints(linePath.shape, points), linePath.dirty();
        }, zrUtil.inherits(Line, graphic.Group);
        var _default = Line;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), formatUtil = __webpack_require__(9), COORDS = [ "cartesian2d", "polar", "singleAxis" ];
        function createNameEach(names, attrs) {
            names = names.slice();
            var capitalNames = zrUtil.map(names, formatUtil.capitalFirst);
            attrs = (attrs || []).slice();
            var capitalAttrs = zrUtil.map(attrs, formatUtil.capitalFirst);
            return function(callback, context) {
                zrUtil.each(names, function(name, index) {
                    for (var nameObj = {
                        name: name,
                        capital: capitalNames[index]
                    }, j = 0; j < attrs.length; j++) nameObj[attrs[j]] = name + capitalAttrs[j];
                    callback.call(context, nameObj);
                });
            };
        }
        var eachAxisDim = createNameEach([ "x", "y", "z", "radius", "angle", "single" ], [ "axisIndex", "axis", "index", "id" ]);
        exports.isCoordSupported = function(coordType) {
            return zrUtil.indexOf(COORDS, coordType) >= 0;
        }, exports.createNameEach = createNameEach, exports.eachAxisDim = eachAxisDim, exports.createLinkedNodesFinder = function(forEachNode, forEachEdgeType, edgeIdGetter) {
            return function(sourceNode) {
                var existsLink, result = {
                    nodes: [],
                    records: {}
                };
                if (forEachEdgeType(function(edgeType) {
                    result.records[edgeType.name] = {};
                }), !sourceNode) return result;
                absorb(sourceNode, result);
                do {
                    existsLink = !1, forEachNode(processSingleNode);
                } while (existsLink);
                function processSingleNode(node) {
                    !function(node, result) {
                        return zrUtil.indexOf(result.nodes, node) >= 0;
                    }(node, result) && function(node, result) {
                        var hasLink = !1;
                        return forEachEdgeType(function(edgeType) {
                            zrUtil.each(edgeIdGetter(node, edgeType) || [], function(edgeId) {
                                result.records[edgeType.name][edgeId] && (hasLink = !0);
                            });
                        }), hasLink;
                    }(node, result) && (absorb(node, result), existsLink = !0);
                }
                return result;
            };
            function absorb(node, result) {
                result.nodes.push(node), forEachEdgeType(function(edgeType) {
                    zrUtil.each(edgeIdGetter(node, edgeType) || [], function(edgeId) {
                        result.records[edgeType.name][edgeId] = !0;
                    });
                });
            }
        };
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(5).__DEV__;
        var echarts = __webpack_require__(1), zrUtil = __webpack_require__(0), env = __webpack_require__(7), modelUtil = __webpack_require__(3), formatUtil = __webpack_require__(9), dataFormatMixin = __webpack_require__(115), addCommas = formatUtil.addCommas, encodeHTML = formatUtil.encodeHTML;
        function fillLabel(opt) {
            modelUtil.defaultEmphasis(opt, "label", [ "show" ]);
        }
        var MarkerModel = echarts.extendComponentModel({
            type: "marker",
            dependencies: [ "series", "grid", "polar", "geo" ],
            init: function(option, parentModel, ecModel, extraOpt) {
                this.mergeDefaultAndTheme(option, ecModel), this.mergeOption(option, ecModel, extraOpt.createdBySelf, !0);
            },
            isAnimationEnabled: function() {
                if (env.node) return !1;
                var hostSeries = this.__hostSeries;
                return this.getShallow("animation") && hostSeries && hostSeries.isAnimationEnabled();
            },
            mergeOption: function(newOpt, ecModel, createdBySelf, isInit) {
                var MarkerModel = this.constructor, modelPropName = this.mainType + "Model";
                createdBySelf || ecModel.eachSeries(function(seriesModel) {
                    var markerOpt = seriesModel.get(this.mainType, !0), markerModel = seriesModel[modelPropName];
                    markerOpt && markerOpt.data ? (markerModel ? markerModel.mergeOption(markerOpt, ecModel, !0) : (isInit && fillLabel(markerOpt), 
                    zrUtil.each(markerOpt.data, function(item) {
                        item instanceof Array ? (fillLabel(item[0]), fillLabel(item[1])) : fillLabel(item);
                    }), markerModel = new MarkerModel(markerOpt, this, ecModel), zrUtil.extend(markerModel, {
                        mainType: this.mainType,
                        seriesIndex: seriesModel.seriesIndex,
                        name: seriesModel.name,
                        createdBySelf: !0
                    }), markerModel.__hostSeries = seriesModel), seriesModel[modelPropName] = markerModel) : seriesModel[modelPropName] = null;
                }, this);
            },
            formatTooltip: function(dataIndex) {
                var data = this.getData(), value = this.getRawValue(dataIndex), formattedValue = zrUtil.isArray(value) ? zrUtil.map(value, addCommas).join(", ") : addCommas(value), name = data.getName(dataIndex), html = encodeHTML(this.name);
                return (null != value || name) && (html += "<br />"), name && (html += encodeHTML(name), 
                null != value && (html += " : ")), null != value && (html += encodeHTML(formattedValue)), 
                html;
            },
            getData: function() {
                return this._data;
            },
            setData: function(data) {
                this._data = data;
            }
        });
        zrUtil.mixin(MarkerModel, dataFormatMixin);
        var _default = MarkerModel;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), numberUtil = __webpack_require__(4), isDimensionStacked = __webpack_require__(19).isDimensionStacked, indexOf = zrUtil.indexOf;
        function markerTypeCalculatorWithExtent(mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {
            var coordArr = [], calcDataDim = isDimensionStacked(data, targetDataDim) ? data.getCalculationInfo("stackResultDimension") : targetDataDim, value = numCalculate(data, calcDataDim, mlType), dataIndex = data.indicesOfNearest(calcDataDim, value)[0];
            coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex), coordArr[targetCoordIndex] = data.get(targetDataDim, dataIndex);
            var precision = numberUtil.getPrecision(data.get(targetDataDim, dataIndex));
            return (precision = Math.min(precision, 20)) >= 0 && (coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision)), 
            coordArr;
        }
        var curry = zrUtil.curry, markerTypeCalculator = {
            min: curry(markerTypeCalculatorWithExtent, "min"),
            max: curry(markerTypeCalculatorWithExtent, "max"),
            average: curry(markerTypeCalculatorWithExtent, "average")
        };
        function getAxisInfo(item, data, coordSys, seriesModel) {
            var ret = {};
            return null != item.valueIndex || null != item.valueDim ? (ret.valueDataDim = null != item.valueIndex ? data.getDimension(item.valueIndex) : item.valueDim, 
            ret.valueAxis = coordSys.getAxis(function(seriesModel, dataDim) {
                var data = seriesModel.getData(), dimensions = data.dimensions;
                dataDim = data.getDimension(dataDim);
                for (var i = 0; i < dimensions.length; i++) {
                    var dimItem = data.getDimensionInfo(dimensions[i]);
                    if (dimItem.name === dataDim) return dimItem.coordDim;
                }
            }(seriesModel, ret.valueDataDim)), ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis), 
            ret.baseDataDim = data.mapDimension(ret.baseAxis.dim)) : (ret.baseAxis = seriesModel.getBaseAxis(), 
            ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis), ret.baseDataDim = data.mapDimension(ret.baseAxis.dim), 
            ret.valueDataDim = data.mapDimension(ret.valueAxis.dim)), ret;
        }
        function numCalculate(data, valueDataDim, type) {
            if ("average" === type) {
                var sum = 0, count = 0;
                return data.each(valueDataDim, function(val, idx) {
                    isNaN(val) || (sum += val, count++);
                }), sum / count;
            }
            return "median" === type ? data.getMedian(valueDataDim) : data.getDataExtent(valueDataDim, !0)["max" === type ? 1 : 0];
        }
        exports.dataTransform = function(seriesModel, item) {
            var data = seriesModel.getData(), coordSys = seriesModel.coordinateSystem;
            if (item && !function(item) {
                return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));
            }(item) && !zrUtil.isArray(item.coord) && coordSys) {
                var dims = coordSys.dimensions, axisInfo = getAxisInfo(item, data, coordSys, seriesModel);
                if ((item = zrUtil.clone(item)).type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {
                    var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim), targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);
                    item.coord = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex), 
                    item.value = item.coord[targetCoordIndex];
                } else {
                    for (var coord = [ null != item.xAxis ? item.xAxis : item.radiusAxis, null != item.yAxis ? item.yAxis : item.angleAxis ], i = 0; i < 2; i++) markerTypeCalculator[coord[i]] && (coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i]));
                    item.coord = coord;
                }
            }
            return item;
        }, exports.getAxisInfo = getAxisInfo, exports.dataFilter = function(coordSys, item) {
            return !(coordSys && coordSys.containData && item.coord && !function(item) {
                return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));
            }(item)) || coordSys.containData(item.coord);
        }, exports.dimValueGetter = function(item, dimName, dataIndex, dimIndex) {
            return dimIndex < 2 ? item.coord && item.coord[dimIndex] : item.value;
        }, exports.numCalculate = numCalculate;
    }, function(module, exports, __webpack_require__) {
        var echarts = __webpack_require__(1), zrUtil = __webpack_require__(0), _default = echarts.extendComponentView({
            type: "marker",
            init: function() {
                this.markerGroupMap = zrUtil.createHashMap();
            },
            render: function(markerModel, ecModel, api) {
                var markerGroupMap = this.markerGroupMap;
                markerGroupMap.each(function(item) {
                    item.__keep = !1;
                });
                var markerModelKey = this.type + "Model";
                ecModel.eachSeries(function(seriesModel) {
                    var markerModel = seriesModel[markerModelKey];
                    markerModel && this.renderSeries(seriesModel, markerModel, ecModel, api);
                }, this), markerGroupMap.each(function(item) {
                    !item.__keep && this.group.remove(item.group);
                }, this);
            },
            renderSeries: function() {}
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.Scatterplot = void 0;
        var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        }, _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _react = __webpack_require__(49), _react2 = _interopRequireDefault(_react), _utils = __webpack_require__(50), _style = __webpack_require__(174), _lodash2 = _interopRequireDefault(__webpack_require__(175)), scale = _interopRequireWildcard(__webpack_require__(323)), d3array = _interopRequireWildcard(__webpack_require__(324)), _lodash4 = _interopRequireDefault(__webpack_require__(82)), _core2 = _interopRequireDefault(__webpack_require__(176)), _echarts2 = _interopRequireDefault(__webpack_require__(1));
        function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) return obj;
            var newObj = {};
            if (null != obj) for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (newObj[key] = obj[key]);
            return newObj.default = obj, newObj;
        }
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        __webpack_require__(243), __webpack_require__(258), __webpack_require__(265), __webpack_require__(269), 
        __webpack_require__(273), __webpack_require__(279), __webpack_require__(284), __webpack_require__(290), 
        __webpack_require__(295), __webpack_require__(296), __webpack_require__(307), __webpack_require__(314), 
        __webpack_require__(317), __webpack_require__(320);
        var getDataScale = function(data, _ref) {
            var _ref$range = _ref.range, range = void 0 === _ref$range ? [ 0, 1 ] : _ref$range, _ref$exponent = _ref.exponent, exponent = void 0 === _ref$exponent ? 1 : _ref$exponent;
            return data ? scale.scalePow().exponent(exponent).domain(function(data) {
                var values = Object.keys(data).map(function(k) {
                    return parseFloat(data[k]);
                }).filter(function(v) {
                    return v > -9999;
                }).sort(function(a, b) {
                    return a - b;
                });
                return [ d3array.quantile(values, .001), d3array.quantile(values, .999) ];
            }(data)).range(range).clamp(!0) : function() {
                return 0;
            };
        }, getDataSeries = function(id) {
            var series = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
            return series && series.length ? series.find(function(s) {
                return s.id === id;
            }) : null;
        }, Scatterplot = exports.Scatterplot = function(_Component) {
            function Scatterplot(props) {
                !function(instance, Constructor) {
                    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                }(this, Scatterplot);
                var _this = function(self, call) {
                    if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !call || "object" != typeof call && "function" != typeof call ? self : call;
                }(this, (Scatterplot.__proto__ || Object.getPrototypeOf(Scatterplot)).call(this, props));
                return _this._getScatterplotOptions = function() {
                    var options = _this.props.options, series = _this._getScatterplotSeries();
                    return _extends({}, options, {
                        series: series
                    });
                }, _this.state = {
                    options: !1
                }, _this;
            }
            return function(subClass, superClass) {
                if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
            }(Scatterplot, _react.Component), _createClass(Scatterplot, [ {
                key: "shouldComponentUpdate",
                value: function(nextProps) {
                    return !nextProps.freeze;
                }
            }, {
                key: "componentDidMount",
                value: function() {
                    var theme = this.props.theme;
                    if (this.updateOptions(), theme && ("string" == typeof theme && this.setState({
                        themeId: theme
                    }), "object" === (void 0 === theme ? "undefined" : _typeof(theme)))) {
                        var themeId = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
                        this.setState({
                            themeId: themeId
                        }), _echarts2.default.registerTheme(themeId, this.props.theme);
                    }
                }
            }, {
                key: "componentDidUpdate",
                value: function(prevProps) {
                    var _props = this.props, loading = _props.loading, data = _props.data, xVar = _props.xVar, yVar = _props.yVar, zVar = _props.zVar, selected = _props.selected, highlighted = _props.highlighted, options = _props.options, freeze = _props.freeze;
                    loading || Boolean(prevProps.data) === Boolean(data) && prevProps.xVar === xVar && prevProps.zVar === zVar && prevProps.yVar === yVar && (0, 
                    _lodash2.default)(prevProps.highlighted, highlighted) && (0, _lodash2.default)(prevProps.selected, selected) && (0, 
                    _lodash2.default)(prevProps.options, options) && (!prevProps.freeze || freeze) || this.updateOptions();
                }
            }, {
                key: "updateOptions",
                value: function() {
                    var options = (0, _style.getScatterplotOptions)(this._getScatterplotOptions());
                    this.setState({
                        options: options
                    });
                }
            }, {
                key: "_getHighlightedSeries",
                value: function(scatterData, sizeScale) {
                    var _props2 = this.props, _props2$highlighted = _props2.highlighted, highlighted = void 0 === _props2$highlighted ? [] : _props2$highlighted, options = _props2.options, zVar = _props2.zVar, idDim = zVar ? 3 : 2, baseSeries = {
                        id: "highlighted",
                        type: "scatter",
                        symbolSize: zVar ? function(value) {
                            return sizeScale(value[2]);
                        } : 10,
                        z: 3
                    }, overrides = options ? getDataSeries("highlighted", options.series) : {}, data = highlighted.map(function(id, i) {
                        return scatterData.find(function(d) {
                            return d[idDim] === id;
                        });
                    }).filter(function(d) {
                        return Boolean(d);
                    });
                    return (0, _lodash4.default)(_extends({}, baseSeries, {
                        data: data
                    }), overrides || {});
                }
            }, {
                key: "_getSelectedSeries",
                value: function(scatterData, sizeScale) {
                    var _props3 = this.props, _props3$selected = _props3.selected, selected = void 0 === _props3$selected ? [] : _props3$selected, options = _props3.options, idDim = _props3.zVar ? 3 : 2, baseSeries = {
                        id: "selected",
                        type: "scatter",
                        symbolSize: function(value) {
                            return sizeScale(value[2]);
                        },
                        z: 4
                    }, overrides = options ? getDataSeries("selected", options.series) : {}, data = selected.map(function(id, i) {
                        return scatterData.find(function(d) {
                            return d[idDim] === id;
                        });
                    }).filter(function(d) {
                        return Boolean(d);
                    });
                    return (0, _lodash4.default)(_extends({}, baseSeries, {
                        data: data
                    }), overrides || {});
                }
            }, {
                key: "_getBaseSeries",
                value: function(scatterData, sizeScale) {
                    var options = this.props.options, overrides = options ? getDataSeries("base", options.series) : {};
                    return (0, _lodash4.default)({
                        id: "base",
                        type: "scatter",
                        data: scatterData,
                        symbolSize: function(value) {
                            return sizeScale(value[2]);
                        },
                        z: 2
                    }, overrides || {});
                }
            }, {
                key: "_getScatterplotSeries",
                value: function() {
                    var _props4 = this.props, data = _props4.data, xVar = _props4.xVar, yVar = _props4.yVar, zVar = _props4.zVar, options = _props4.options, otherSeries = options && options.series ? options.series.filter(function(s) {
                        return -1 === [ "base", "selected", "highlighted" ].indexOf(s.id);
                    }) : [];
                    if (data && data[xVar] && data[yVar] && (zVar && data[zVar] || !zVar)) {
                        var sizeScale = zVar ? getDataScale(data[zVar], {
                            range: [ 6, 48 ]
                        }) : function() {
                            return 10;
                        }, scatterData = zVar ? (0, _utils.getScatterplotData)(data[xVar], data[yVar], data[zVar]) : (0, 
                        _utils.getScatterplotData)(data[xVar], data[yVar]);
                        return [ this._getBaseSeries(scatterData, sizeScale), this._getSelectedSeries(scatterData, sizeScale), this._getHighlightedSeries(scatterData, sizeScale) ].concat(function(arr) {
                            if (Array.isArray(arr)) {
                                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
                                return arr2;
                            }
                            return Array.from(arr);
                        }(otherSeries));
                    }
                    return [];
                }
            }, {
                key: "_onChartReady",
                value: function(e) {
                    this.props.onHover && e.on("mouseover", this.props.onHover), this.props.onHover && e.on("mouseout", this.props.onHover), 
                    this.props.onMouseMove && e.on("mousemove", this.props.onMouseMove), this.props.onClick && e.on("click", this.props.onClick), 
                    this.props.onMouseOver && e.getDom().addEventListener("mouseover", this.props.onMouseEnter), 
                    this.props.onMouseOut && e.getDom().addEventListener("mouseout", this.props.onMouseLeave), 
                    this.echart = e, this.props.onReady && this.props.onReady(e);
                }
            }, {
                key: "getOptionOverrides",
                value: function() {
                    return this.state.options;
                }
            }, {
                key: "render",
                value: function() {
                    return this.state.options && _react2.default.createElement(_core2.default, {
                        echarts: _echarts2.default,
                        onChartReady: this._onChartReady.bind(this),
                        style: _extends({
                            position: "absolute",
                            top: 0,
                            left: 0,
                            width: "100%",
                            height: "100%"
                        }, this.props.style),
                        option: this.state.options,
                        notMerge: this.props.notMerge,
                        theme: this.state.themeId,
                        showLoading: this.props.loading,
                        loadingOption: {
                            color: "#0078d4"
                        }
                    });
                }
            } ]), Scatterplot;
        }();
        exports.default = Scatterplot;
    }, function(module, exports, __webpack_require__) {
        "use strict";
        module.exports = function(fn, thisArg) {
            return function() {
                for (var args = new Array(arguments.length), i = 0; i < args.length; i++) args[i] = arguments[i];
                return fn.apply(thisArg, args);
            };
        };
    }, function(module, exports, __webpack_require__) {
        "use strict";
        var utils = __webpack_require__(11), settle = __webpack_require__(160), buildURL = __webpack_require__(162), parseHeaders = __webpack_require__(163), isURLSameOrigin = __webpack_require__(164), createError = __webpack_require__(79);
        module.exports = function(config) {
            return new Promise(function(resolve, reject) {
                var requestData = config.data, requestHeaders = config.headers;
                utils.isFormData(requestData) && delete requestHeaders["Content-Type"];
                var request = new XMLHttpRequest();
                if (config.auth) {
                    var username = config.auth.username || "", password = config.auth.password || "";
                    requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
                }
                if (request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), !0), 
                request.timeout = config.timeout, request.onreadystatechange = function() {
                    if (request && 4 === request.readyState && (0 !== request.status || request.responseURL && 0 === request.responseURL.indexOf("file:"))) {
                        var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null, response = {
                            data: config.responseType && "text" !== config.responseType ? request.response : request.responseText,
                            status: request.status,
                            statusText: request.statusText,
                            headers: responseHeaders,
                            config: config,
                            request: request
                        };
                        settle(resolve, reject, response), request = null;
                    }
                }, request.onerror = function() {
                    reject(createError("Network Error", config, null, request)), request = null;
                }, request.ontimeout = function() {
                    reject(createError("timeout of " + config.timeout + "ms exceeded", config, "ECONNABORTED", request)), 
                    request = null;
                }, utils.isStandardBrowserEnv()) {
                    var cookies = __webpack_require__(165), xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
                    xsrfValue && (requestHeaders[config.xsrfHeaderName] = xsrfValue);
                }
                if ("setRequestHeader" in request && utils.forEach(requestHeaders, function(val, key) {
                    void 0 === requestData && "content-type" === key.toLowerCase() ? delete requestHeaders[key] : request.setRequestHeader(key, val);
                }), config.withCredentials && (request.withCredentials = !0), config.responseType) try {
                    request.responseType = config.responseType;
                } catch (e) {
                    if ("json" !== config.responseType) throw e;
                }
                "function" == typeof config.onDownloadProgress && request.addEventListener("progress", config.onDownloadProgress), 
                "function" == typeof config.onUploadProgress && request.upload && request.upload.addEventListener("progress", config.onUploadProgress), 
                config.cancelToken && config.cancelToken.promise.then(function(cancel) {
                    request && (request.abort(), reject(cancel), request = null);
                }), void 0 === requestData && (requestData = null), request.send(requestData);
            });
        };
    }, function(module, exports, __webpack_require__) {
        "use strict";
        var enhanceError = __webpack_require__(161);
        module.exports = function(message, config, code, request, response) {
            var error = new Error(message);
            return enhanceError(error, config, code, request, response);
        };
    }, function(module, exports, __webpack_require__) {
        "use strict";
        module.exports = function(value) {
            return !(!value || !value.__CANCEL__);
        };
    }, function(module, exports, __webpack_require__) {
        "use strict";
        function Cancel(message) {
            this.message = message;
        }
        Cancel.prototype.toString = function() {
            return "Cancel" + (this.message ? ": " + this.message : "");
        }, Cancel.prototype.__CANCEL__ = !0, module.exports = Cancel;
    }, function(module, exports, __webpack_require__) {
        (function(global, module) {
            var LARGE_ARRAY_SIZE = 200, HASH_UNDEFINED = "__lodash_hash_undefined__", HOT_COUNT = 800, HOT_SPAN = 16, MAX_SAFE_INTEGER = 9007199254740991, argsTag = "[object Arguments]", asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", nullTag = "[object Null]", objectTag = "[object Object]", proxyTag = "[object Proxy]", undefinedTag = "[object Undefined]", reIsHostCtor = /^\[object .+?Constructor\]$/, reIsUint = /^(?:0|[1-9]\d*)$/, typedArrayTags = {};
            typedArrayTags["[object Float32Array]"] = typedArrayTags["[object Float64Array]"] = typedArrayTags["[object Int8Array]"] = typedArrayTags["[object Int16Array]"] = typedArrayTags["[object Int32Array]"] = typedArrayTags["[object Uint8Array]"] = typedArrayTags["[object Uint8ClampedArray]"] = typedArrayTags["[object Uint16Array]"] = typedArrayTags["[object Uint32Array]"] = !0, 
            typedArrayTags[argsTag] = typedArrayTags["[object Array]"] = typedArrayTags["[object ArrayBuffer]"] = typedArrayTags["[object Boolean]"] = typedArrayTags["[object DataView]"] = typedArrayTags["[object Date]"] = typedArrayTags["[object Error]"] = typedArrayTags[funcTag] = typedArrayTags["[object Map]"] = typedArrayTags["[object Number]"] = typedArrayTags[objectTag] = typedArrayTags["[object RegExp]"] = typedArrayTags["[object Set]"] = typedArrayTags["[object String]"] = typedArrayTags["[object WeakMap]"] = !1;
            var freeGlobal = "object" == typeof global && global && global.Object === Object && global, freeSelf = "object" == typeof self && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), freeExports = "object" == typeof exports && exports && !exports.nodeType && exports, freeModule = freeExports && "object" == typeof module && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports, freeProcess = moduleExports && freeGlobal.process, nodeUtil = function() {
                try {
                    var types = freeModule && freeModule.require && freeModule.require("util").types;
                    return types || freeProcess && freeProcess.binding && freeProcess.binding("util");
                } catch (e) {}
            }(), nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
            var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype, coreJsData = root["__core-js_shared__"], funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, maskSrcKey = function() {
                var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
                return uid ? "Symbol(src)_1." + uid : "";
            }(), nativeObjectToString = objectProto.toString, objectCtorString = funcToString.call(Object), reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Buffer = moduleExports ? root.Buffer : void 0, Symbol = root.Symbol, Uint8Array = root.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0, getPrototype = function(func, transform) {
                return function(arg) {
                    return func(transform(arg));
                };
            }(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol ? Symbol.toStringTag : void 0, defineProperty = function() {
                try {
                    var func = getNative(Object, "defineProperty");
                    return func({}, "", {}), func;
                } catch (e) {}
            }(), nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0, nativeMax = Math.max, nativeNow = Date.now, Map = getNative(root, "Map"), nativeCreate = getNative(Object, "create"), baseCreate = function() {
                function object() {}
                return function(proto) {
                    if (!isObject(proto)) return {};
                    if (objectCreate) return objectCreate(proto);
                    object.prototype = proto;
                    var result = new object();
                    return object.prototype = void 0, result;
                };
            }();
            function Hash(entries) {
                var index = -1, length = null == entries ? 0 : entries.length;
                for (this.clear(); ++index < length; ) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                }
            }
            function ListCache(entries) {
                var index = -1, length = null == entries ? 0 : entries.length;
                for (this.clear(); ++index < length; ) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                }
            }
            function MapCache(entries) {
                var index = -1, length = null == entries ? 0 : entries.length;
                for (this.clear(); ++index < length; ) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                }
            }
            function Stack(entries) {
                var data = this.__data__ = new ListCache(entries);
                this.size = data.size;
            }
            function arrayLikeKeys(value, inherited) {
                var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? function(n, iteratee) {
                    for (var index = -1, result = Array(n); ++index < n; ) result[index] = iteratee(index);
                    return result;
                }(value.length, String) : [], length = result.length;
                for (var key in value) !inherited && !hasOwnProperty.call(value, key) || skipIndexes && ("length" == key || isBuff && ("offset" == key || "parent" == key) || isType && ("buffer" == key || "byteLength" == key || "byteOffset" == key) || isIndex(key, length)) || result.push(key);
                return result;
            }
            function assignMergeValue(object, key, value) {
                (void 0 === value || eq(object[key], value)) && (void 0 !== value || key in object) || baseAssignValue(object, key, value);
            }
            function assignValue(object, key, value) {
                var objValue = object[key];
                hasOwnProperty.call(object, key) && eq(objValue, value) && (void 0 !== value || key in object) || baseAssignValue(object, key, value);
            }
            function assocIndexOf(array, key) {
                for (var length = array.length; length--; ) if (eq(array[length][0], key)) return length;
                return -1;
            }
            function baseAssignValue(object, key, value) {
                "__proto__" == key && defineProperty ? defineProperty(object, key, {
                    configurable: !0,
                    enumerable: !0,
                    value: value,
                    writable: !0
                }) : object[key] = value;
            }
            Hash.prototype.clear = function() {
                this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
            }, Hash.prototype.delete = function(key) {
                var result = this.has(key) && delete this.__data__[key];
                return this.size -= result ? 1 : 0, result;
            }, Hash.prototype.get = function(key) {
                var data = this.__data__;
                if (nativeCreate) {
                    var result = data[key];
                    return result === HASH_UNDEFINED ? void 0 : result;
                }
                return hasOwnProperty.call(data, key) ? data[key] : void 0;
            }, Hash.prototype.has = function(key) {
                var data = this.__data__;
                return nativeCreate ? void 0 !== data[key] : hasOwnProperty.call(data, key);
            }, Hash.prototype.set = function(key, value) {
                var data = this.__data__;
                return this.size += this.has(key) ? 0 : 1, data[key] = nativeCreate && void 0 === value ? HASH_UNDEFINED : value, 
                this;
            }, ListCache.prototype.clear = function() {
                this.__data__ = [], this.size = 0;
            }, ListCache.prototype.delete = function(key) {
                var data = this.__data__, index = assocIndexOf(data, key);
                return !(index < 0 || (index == data.length - 1 ? data.pop() : splice.call(data, index, 1), 
                --this.size, 0));
            }, ListCache.prototype.get = function(key) {
                var data = this.__data__, index = assocIndexOf(data, key);
                return index < 0 ? void 0 : data[index][1];
            }, ListCache.prototype.has = function(key) {
                return assocIndexOf(this.__data__, key) > -1;
            }, ListCache.prototype.set = function(key, value) {
                var data = this.__data__, index = assocIndexOf(data, key);
                return index < 0 ? (++this.size, data.push([ key, value ])) : data[index][1] = value, 
                this;
            }, MapCache.prototype.clear = function() {
                this.size = 0, this.__data__ = {
                    hash: new Hash(),
                    map: new (Map || ListCache)(),
                    string: new Hash()
                };
            }, MapCache.prototype.delete = function(key) {
                var result = getMapData(this, key).delete(key);
                return this.size -= result ? 1 : 0, result;
            }, MapCache.prototype.get = function(key) {
                return getMapData(this, key).get(key);
            }, MapCache.prototype.has = function(key) {
                return getMapData(this, key).has(key);
            }, MapCache.prototype.set = function(key, value) {
                var data = getMapData(this, key), size = data.size;
                return data.set(key, value), this.size += data.size == size ? 0 : 1, this;
            }, Stack.prototype.clear = function() {
                this.__data__ = new ListCache(), this.size = 0;
            }, Stack.prototype.delete = function(key) {
                var data = this.__data__, result = data.delete(key);
                return this.size = data.size, result;
            }, Stack.prototype.get = function(key) {
                return this.__data__.get(key);
            }, Stack.prototype.has = function(key) {
                return this.__data__.has(key);
            }, Stack.prototype.set = function(key, value) {
                var data = this.__data__;
                if (data instanceof ListCache) {
                    var pairs = data.__data__;
                    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) return pairs.push([ key, value ]), 
                    this.size = ++data.size, this;
                    data = this.__data__ = new MapCache(pairs);
                }
                return data.set(key, value), this.size = data.size, this;
            };
            var baseFor = function(fromRight) {
                return function(object, iteratee, keysFunc) {
                    for (var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length; length--; ) {
                        var key = props[fromRight ? length : ++index];
                        if (!1 === iteratee(iterable[key], key, iterable)) break;
                    }
                    return object;
                };
            }();
            function baseGetTag(value) {
                return null == value ? void 0 === value ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(value) ? function(value) {
                    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
                    try {
                        value[symToStringTag] = void 0;
                        var unmasked = !0;
                    } catch (e) {}
                    var result = nativeObjectToString.call(value);
                    unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]);
                    return result;
                }(value) : function(value) {
                    return nativeObjectToString.call(value);
                }(value);
            }
            function baseIsArguments(value) {
                return isObjectLike(value) && baseGetTag(value) == argsTag;
            }
            function baseIsNative(value) {
                return !(!isObject(value) || function(func) {
                    return !!maskSrcKey && maskSrcKey in func;
                }(value)) && (isFunction(value) ? reIsNative : reIsHostCtor).test(function(func) {
                    if (null != func) {
                        try {
                            return funcToString.call(func);
                        } catch (e) {}
                        try {
                            return func + "";
                        } catch (e) {}
                    }
                    return "";
                }(value));
            }
            function baseKeysIn(object) {
                if (!isObject(object)) return function(object) {
                    var result = [];
                    if (null != object) for (var key in Object(object)) result.push(key);
                    return result;
                }(object);
                var isProto = isPrototype(object), result = [];
                for (var key in object) ("constructor" != key || !isProto && hasOwnProperty.call(object, key)) && result.push(key);
                return result;
            }
            function baseMerge(object, source, srcIndex, customizer, stack) {
                object !== source && baseFor(source, function(srcValue, key) {
                    if (stack || (stack = new Stack()), isObject(srcValue)) !function(object, source, key, srcIndex, mergeFunc, customizer, stack) {
                        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
                        if (stacked) return void assignMergeValue(object, key, stacked);
                        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0, isCommon = void 0 === newValue;
                        if (isCommon) {
                            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
                            newValue = srcValue, isArr || isBuff || isTyped ? isArray(objValue) ? newValue = objValue : !function(value) {
                                return isObjectLike(value) && isArrayLike(value);
                            }(objValue) ? isBuff ? (isCommon = !1, newValue = function(buffer, isDeep) {
                                if (isDeep) return buffer.slice();
                                var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
                                return buffer.copy(result), result;
                            }(srcValue, !0)) : isTyped ? (isCommon = !1, newValue = function(typedArray, isDeep) {
                                var buffer = isDeep ? function(arrayBuffer) {
                                    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
                                    return new Uint8Array(result).set(new Uint8Array(arrayBuffer)), result;
                                }(typedArray.buffer) : typedArray.buffer;
                                return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
                            }(srcValue, !0)) : newValue = [] : newValue = function(source, array) {
                                var index = -1, length = source.length;
                                array || (array = Array(length));
                                for (;++index < length; ) array[index] = source[index];
                                return array;
                            }(objValue) : function(value) {
                                if (!isObjectLike(value) || baseGetTag(value) != objectTag) return !1;
                                var proto = getPrototype(value);
                                if (null === proto) return !0;
                                var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
                                return "function" == typeof Ctor && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
                            }(srcValue) || isArguments(srcValue) ? (newValue = objValue, isArguments(objValue) ? newValue = function(value) {
                                return function(source, props, object, customizer) {
                                    var isNew = !object;
                                    object || (object = {});
                                    var index = -1, length = props.length;
                                    for (;++index < length; ) {
                                        var key = props[index], newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
                                        void 0 === newValue && (newValue = source[key]), isNew ? baseAssignValue(object, key, newValue) : assignValue(object, key, newValue);
                                    }
                                    return object;
                                }(value, keysIn(value));
                            }(objValue) : isObject(objValue) && !isFunction(objValue) || (newValue = function(object) {
                                return "function" != typeof object.constructor || isPrototype(object) ? {} : baseCreate(getPrototype(object));
                            }(srcValue))) : isCommon = !1;
                        }
                        isCommon && (stack.set(srcValue, newValue), mergeFunc(newValue, srcValue, srcIndex, customizer, stack), 
                        stack.delete(srcValue));
                        assignMergeValue(object, key, newValue);
                    }(object, source, key, srcIndex, baseMerge, customizer, stack); else {
                        var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
                        void 0 === newValue && (newValue = srcValue), assignMergeValue(object, key, newValue);
                    }
                }, keysIn);
            }
            function baseRest(func, start) {
                return setToString(function(func, start, transform) {
                    return start = nativeMax(void 0 === start ? func.length - 1 : start, 0), function() {
                        for (var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length); ++index < length; ) array[index] = args[start + index];
                        index = -1;
                        for (var otherArgs = Array(start + 1); ++index < start; ) otherArgs[index] = args[index];
                        return otherArgs[start] = transform(array), function(func, thisArg, args) {
                            switch (args.length) {
                              case 0:
                                return func.call(thisArg);

                              case 1:
                                return func.call(thisArg, args[0]);

                              case 2:
                                return func.call(thisArg, args[0], args[1]);

                              case 3:
                                return func.call(thisArg, args[0], args[1], args[2]);
                            }
                            return func.apply(thisArg, args);
                        }(func, this, otherArgs);
                    };
                }(func, start, identity), func + "");
            }
            function getMapData(map, key) {
                var data = map.__data__;
                return function(value) {
                    var type = typeof value;
                    return "string" == type || "number" == type || "symbol" == type || "boolean" == type ? "__proto__" !== value : null === value;
                }(key) ? data["string" == typeof key ? "string" : "hash"] : data.map;
            }
            function getNative(object, key) {
                var value = function(object, key) {
                    return null == object ? void 0 : object[key];
                }(object, key);
                return baseIsNative(value) ? value : void 0;
            }
            function isIndex(value, length) {
                var type = typeof value;
                return !!(length = null == length ? MAX_SAFE_INTEGER : length) && ("number" == type || "symbol" != type && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
            }
            function isPrototype(value) {
                var Ctor = value && value.constructor;
                return value === ("function" == typeof Ctor && Ctor.prototype || objectProto);
            }
            function safeGet(object, key) {
                if (("constructor" !== key || "function" != typeof object[key]) && "__proto__" != key) return object[key];
            }
            var setToString = function(func) {
                var count = 0, lastCalled = 0;
                return function() {
                    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
                    if (lastCalled = stamp, remaining > 0) {
                        if (++count >= HOT_COUNT) return arguments[0];
                    } else count = 0;
                    return func.apply(void 0, arguments);
                };
            }(defineProperty ? function(func, string) {
                return defineProperty(func, "toString", {
                    configurable: !0,
                    enumerable: !1,
                    value: function(value) {
                        return function() {
                            return value;
                        };
                    }(string),
                    writable: !0
                });
            } : identity);
            function eq(value, other) {
                return value === other || value != value && other != other;
            }
            var isArguments = baseIsArguments(function() {
                return arguments;
            }()) ? baseIsArguments : function(value) {
                return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
            }, isArray = Array.isArray;
            function isArrayLike(value) {
                return null != value && isLength(value.length) && !isFunction(value);
            }
            var isBuffer = nativeIsBuffer || function() {
                return !1;
            };
            function isFunction(value) {
                if (!isObject(value)) return !1;
                var tag = baseGetTag(value);
                return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
            }
            function isLength(value) {
                return "number" == typeof value && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
            }
            function isObject(value) {
                var type = typeof value;
                return null != value && ("object" == type || "function" == type);
            }
            function isObjectLike(value) {
                return null != value && "object" == typeof value;
            }
            var isTypedArray = nodeIsTypedArray ? function(func) {
                return function(value) {
                    return func(value);
                };
            }(nodeIsTypedArray) : function(value) {
                return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
            };
            function keysIn(object) {
                return isArrayLike(object) ? arrayLikeKeys(object, !0) : baseKeysIn(object);
            }
            var merge = function(assigner) {
                return baseRest(function(object, sources) {
                    var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
                    for (customizer = assigner.length > 3 && "function" == typeof customizer ? (length--, 
                    customizer) : void 0, guard && function(value, index, object) {
                        if (!isObject(object)) return !1;
                        var type = typeof index;
                        return !!("number" == type ? isArrayLike(object) && isIndex(index, object.length) : "string" == type && index in object) && eq(object[index], value);
                    }(sources[0], sources[1], guard) && (customizer = length < 3 ? void 0 : customizer, 
                    length = 1), object = Object(object); ++index < length; ) {
                        var source = sources[index];
                        source && assigner(object, source, index, customizer);
                    }
                    return object;
                });
            }(function(object, source, srcIndex) {
                baseMerge(object, source, srcIndex);
            });
            function identity(value) {
                return value;
            }
            module.exports = merge;
        }).call(this, __webpack_require__(52), __webpack_require__(83)(module));
    }, function(module, exports) {
        module.exports = function(module) {
            return module.webpackPolyfill || (module.deprecate = function() {}, module.paths = [], 
            module.children || (module.children = []), Object.defineProperty(module, "loaded", {
                enumerable: !0,
                get: function() {
                    return module.l;
                }
            }), Object.defineProperty(module, "id", {
                enumerable: !0,
                get: function() {
                    return module.i;
                }
            }), module.webpackPolyfill = 1), module;
        };
    }, function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = function(fn) {
            var delay = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 30, timer = null;
            return function() {
                for (var _this = this, _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                clearTimeout(timer), timer = setTimeout(function() {
                    fn.apply(_this, args);
                }, delay);
            };
        }, module.exports = exports.default;
    }, function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        exports.SizeSensorId = "size-sensor-id", exports.SensorStyle = "display:block;position:absolute;top:0;left:0;height:100%;width:100%;overflow:hidden;pointer-events:none;z-index:-1;opacity:0", 
        exports.SensorClassName = "size-sensor-object";
    }, function(module, exports, __webpack_require__) {
        var guid = __webpack_require__(87), env = __webpack_require__(7), zrUtil = __webpack_require__(0), Handler = __webpack_require__(188), Storage = __webpack_require__(192), Painter = __webpack_require__(196), Animation = __webpack_require__(199), HandlerProxy = __webpack_require__(200), useVML = !env.canvasSupported, painterCtors = {
            canvas: Painter
        }, instances = {};
        var ZRender = function(id, dom, opts) {
            opts = opts || {}, this.dom = dom, this.id = id;
            var self = this, storage = new Storage(), rendererType = opts.renderer;
            if (useVML) {
                if (!painterCtors.vml) throw new Error("You need to require 'zrender/vml/vml' to support IE8");
                rendererType = "vml";
            } else rendererType && painterCtors[rendererType] || (rendererType = "canvas");
            var painter = new painterCtors[rendererType](dom, storage, opts, id);
            this.storage = storage, this.painter = painter;
            var handerProxy = env.node || env.worker ? null : new HandlerProxy(painter.getViewportRoot());
            this.handler = new Handler(storage, painter, handerProxy, painter.root), this.animation = new Animation({
                stage: {
                    update: zrUtil.bind(this.flush, this)
                }
            }), this.animation.start(), this._needsRefresh;
            var oldDelFromStorage = storage.delFromStorage, oldAddToStorage = storage.addToStorage;
            storage.delFromStorage = function(el) {
                oldDelFromStorage.call(storage, el), el && el.removeSelfFromZr(self);
            }, storage.addToStorage = function(el) {
                oldAddToStorage.call(storage, el), el.addSelfToZr(self);
            };
        };
        ZRender.prototype = {
            constructor: ZRender,
            getId: function() {
                return this.id;
            },
            add: function(el) {
                this.storage.addRoot(el), this._needsRefresh = !0;
            },
            remove: function(el) {
                this.storage.delRoot(el), this._needsRefresh = !0;
            },
            configLayer: function(zLevel, config) {
                this.painter.configLayer && this.painter.configLayer(zLevel, config), this._needsRefresh = !0;
            },
            setBackgroundColor: function(backgroundColor) {
                this.painter.setBackgroundColor && this.painter.setBackgroundColor(backgroundColor), 
                this._needsRefresh = !0;
            },
            refreshImmediately: function() {
                this._needsRefresh = this._needsRefreshHover = !1, this.painter.refresh(), this._needsRefresh = this._needsRefreshHover = !1;
            },
            refresh: function() {
                this._needsRefresh = !0;
            },
            flush: function() {
                var triggerRendered;
                this._needsRefresh && (triggerRendered = !0, this.refreshImmediately()), this._needsRefreshHover && (triggerRendered = !0, 
                this.refreshHoverImmediately()), triggerRendered && this.trigger("rendered");
            },
            addHover: function(el, style) {
                if (this.painter.addHover) {
                    var elMirror = this.painter.addHover(el, style);
                    return this.refreshHover(), elMirror;
                }
            },
            removeHover: function(el) {
                this.painter.removeHover && (this.painter.removeHover(el), this.refreshHover());
            },
            clearHover: function() {
                this.painter.clearHover && (this.painter.clearHover(), this.refreshHover());
            },
            refreshHover: function() {
                this._needsRefreshHover = !0;
            },
            refreshHoverImmediately: function() {
                this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.refreshHover();
            },
            resize: function(opts) {
                opts = opts || {}, this.painter.resize(opts.width, opts.height), this.handler.resize();
            },
            clearAnimation: function() {
                this.animation.clear();
            },
            getWidth: function() {
                return this.painter.getWidth();
            },
            getHeight: function() {
                return this.painter.getHeight();
            },
            pathToImage: function(e, dpr) {
                return this.painter.pathToImage(e, dpr);
            },
            setCursorStyle: function(cursorStyle) {
                this.handler.setCursorStyle(cursorStyle);
            },
            findHover: function(x, y) {
                return this.handler.findHover(x, y);
            },
            on: function(eventName, eventHandler, context) {
                this.handler.on(eventName, eventHandler, context);
            },
            off: function(eventName, eventHandler) {
                this.handler.off(eventName, eventHandler);
            },
            trigger: function(eventName, event) {
                this.handler.trigger(eventName, event);
            },
            clear: function() {
                this.storage.delRoot(), this.painter.clear();
            },
            dispose: function() {
                this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), 
                this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, 
                function(id) {
                    delete instances[id];
                }(this.id);
            }
        }, exports.version = "4.1.0", exports.init = function(dom, opts) {
            var zr = new ZRender(guid(), dom, opts);
            return instances[zr.id] = zr, zr;
        }, exports.dispose = function(zr) {
            if (zr) zr.dispose(); else {
                for (var key in instances) instances.hasOwnProperty(key) && instances[key].dispose();
                instances = {};
            }
            return this;
        }, exports.getInstance = function(id) {
            return instances[id];
        }, exports.registerPainter = function(name, Ctor) {
            painterCtors[name] = Ctor;
        };
    }, function(module, exports) {
        var idStart = 2311;
        module.exports = function() {
            return idStart++;
        };
    }, function(module, exports, __webpack_require__) {
        var guid = __webpack_require__(87), Eventful = __webpack_require__(23), Transformable = __webpack_require__(89), Animatable = __webpack_require__(193), zrUtil = __webpack_require__(0), Element = function(opts) {
            Transformable.call(this, opts), Eventful.call(this, opts), Animatable.call(this, opts), 
            this.id = opts.id || guid();
        };
        Element.prototype = {
            type: "element",
            name: "",
            __zr: null,
            ignore: !1,
            clipPath: null,
            isGroup: !1,
            drift: function(dx, dy) {
                switch (this.draggable) {
                  case "horizontal":
                    dy = 0;
                    break;

                  case "vertical":
                    dx = 0;
                }
                var m = this.transform;
                m || (m = this.transform = [ 1, 0, 0, 1, 0, 0 ]), m[4] += dx, m[5] += dy, this.decomposeTransform(), 
                this.dirty(!1);
            },
            beforeUpdate: function() {},
            afterUpdate: function() {},
            update: function() {
                this.updateTransform();
            },
            traverse: function(cb, context) {},
            attrKV: function(key, value) {
                if ("position" === key || "scale" === key || "origin" === key) {
                    if (value) {
                        var target = this[key];
                        target || (target = this[key] = []), target[0] = value[0], target[1] = value[1];
                    }
                } else this[key] = value;
            },
            hide: function() {
                this.ignore = !0, this.__zr && this.__zr.refresh();
            },
            show: function() {
                this.ignore = !1, this.__zr && this.__zr.refresh();
            },
            attr: function(key, value) {
                if ("string" == typeof key) this.attrKV(key, value); else if (zrUtil.isObject(key)) for (var name in key) key.hasOwnProperty(name) && this.attrKV(name, key[name]);
                return this.dirty(!1), this;
            },
            setClipPath: function(clipPath) {
                var zr = this.__zr;
                zr && clipPath.addSelfToZr(zr), this.clipPath && this.clipPath !== clipPath && this.removeClipPath(), 
                this.clipPath = clipPath, clipPath.__zr = zr, clipPath.__clipTarget = this, this.dirty(!1);
            },
            removeClipPath: function() {
                var clipPath = this.clipPath;
                clipPath && (clipPath.__zr && clipPath.removeSelfFromZr(clipPath.__zr), clipPath.__zr = null, 
                clipPath.__clipTarget = null, this.clipPath = null, this.dirty(!1));
            },
            addSelfToZr: function(zr) {
                this.__zr = zr;
                var animators = this.animators;
                if (animators) for (var i = 0; i < animators.length; i++) zr.animation.addAnimator(animators[i]);
                this.clipPath && this.clipPath.addSelfToZr(zr);
            },
            removeSelfFromZr: function(zr) {
                this.__zr = null;
                var animators = this.animators;
                if (animators) for (var i = 0; i < animators.length; i++) zr.animation.removeAnimator(animators[i]);
                this.clipPath && this.clipPath.removeSelfFromZr(zr);
            }
        }, zrUtil.mixin(Element, Animatable), zrUtil.mixin(Element, Transformable), zrUtil.mixin(Element, Eventful);
        var _default = Element;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var matrix = __webpack_require__(17), vector = __webpack_require__(6), mIdentity = matrix.identity, EPSILON = 5e-5;
        function isNotAroundZero(val) {
            return val > EPSILON || val < -EPSILON;
        }
        var Transformable = function(opts) {
            (opts = opts || {}).position || (this.position = [ 0, 0 ]), null == opts.rotation && (this.rotation = 0), 
            opts.scale || (this.scale = [ 1, 1 ]), this.origin = this.origin || null;
        }, transformableProto = Transformable.prototype;
        transformableProto.transform = null, transformableProto.needLocalTransform = function() {
            return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);
        };
        var scaleTmp = [];
        transformableProto.updateTransform = function() {
            var parent = this.parent, parentHasTransform = parent && parent.transform, needLocalTransform = this.needLocalTransform(), m = this.transform;
            if (needLocalTransform || parentHasTransform) {
                m = m || matrix.create(), needLocalTransform ? this.getLocalTransform(m) : mIdentity(m), 
                parentHasTransform && (needLocalTransform ? matrix.mul(m, parent.transform, m) : matrix.copy(m, parent.transform)), 
                this.transform = m;
                var globalScaleRatio = this.globalScaleRatio;
                if (null != globalScaleRatio && 1 !== globalScaleRatio) {
                    this.getGlobalScale(scaleTmp);
                    var relX = scaleTmp[0] < 0 ? -1 : 1, relY = scaleTmp[1] < 0 ? -1 : 1, sx = ((scaleTmp[0] - relX) * globalScaleRatio + relX) / scaleTmp[0] || 0, sy = ((scaleTmp[1] - relY) * globalScaleRatio + relY) / scaleTmp[1] || 0;
                    m[0] *= sx, m[1] *= sx, m[2] *= sy, m[3] *= sy;
                }
                this.invTransform = this.invTransform || matrix.create(), matrix.invert(this.invTransform, m);
            } else m && mIdentity(m);
        }, transformableProto.getLocalTransform = function(m) {
            return Transformable.getLocalTransform(this, m);
        }, transformableProto.setTransform = function(ctx) {
            var m = this.transform, dpr = ctx.dpr || 1;
            m ? ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]) : ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }, transformableProto.restoreTransform = function(ctx) {
            var dpr = ctx.dpr || 1;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        };
        var tmpTransform = [], originTransform = matrix.create();
        transformableProto.setLocalTransform = function(m) {
            if (m) {
                var sx = m[0] * m[0] + m[1] * m[1], sy = m[2] * m[2] + m[3] * m[3], position = this.position, scale = this.scale;
                isNotAroundZero(sx - 1) && (sx = Math.sqrt(sx)), isNotAroundZero(sy - 1) && (sy = Math.sqrt(sy)), 
                m[0] < 0 && (sx = -sx), m[3] < 0 && (sy = -sy), position[0] = m[4], position[1] = m[5], 
                scale[0] = sx, scale[1] = sy, this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);
            }
        }, transformableProto.decomposeTransform = function() {
            if (this.transform) {
                var parent = this.parent, m = this.transform;
                parent && parent.transform && (matrix.mul(tmpTransform, parent.invTransform, m), 
                m = tmpTransform);
                var origin = this.origin;
                origin && (origin[0] || origin[1]) && (originTransform[4] = origin[0], originTransform[5] = origin[1], 
                matrix.mul(tmpTransform, m, originTransform), tmpTransform[4] -= origin[0], tmpTransform[5] -= origin[1], 
                m = tmpTransform), this.setLocalTransform(m);
            }
        }, transformableProto.getGlobalScale = function(out) {
            var m = this.transform;
            return out = out || [], m ? (out[0] = Math.sqrt(m[0] * m[0] + m[1] * m[1]), out[1] = Math.sqrt(m[2] * m[2] + m[3] * m[3]), 
            m[0] < 0 && (out[0] = -out[0]), m[3] < 0 && (out[1] = -out[1]), out) : (out[0] = 1, 
            out[1] = 1, out);
        }, transformableProto.transformCoordToLocal = function(x, y) {
            var v2 = [ x, y ], invTransform = this.invTransform;
            return invTransform && vector.applyTransform(v2, v2, invTransform), v2;
        }, transformableProto.transformCoordToGlobal = function(x, y) {
            var v2 = [ x, y ], transform = this.transform;
            return transform && vector.applyTransform(v2, v2, transform), v2;
        }, Transformable.getLocalTransform = function(target, m) {
            mIdentity(m = m || []);
            var origin = target.origin, scale = target.scale || [ 1, 1 ], rotation = target.rotation || 0, position = target.position || [ 0, 0 ];
            return origin && (m[4] -= origin[0], m[5] -= origin[1]), matrix.scale(m, m, scale), 
            rotation && matrix.rotate(m, m, rotation), origin && (m[4] += origin[0], m[5] += origin[1]), 
            m[4] += position[0], m[5] += position[1], m;
        };
        var _default = Transformable;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var Clip = __webpack_require__(194), color = __webpack_require__(20), isArrayLike = __webpack_require__(0).isArrayLike, arraySlice = Array.prototype.slice;
        function defaultGetter(target, key) {
            return target[key];
        }
        function defaultSetter(target, key, value) {
            target[key] = value;
        }
        function interpolateNumber(p0, p1, percent) {
            return (p1 - p0) * percent + p0;
        }
        function interpolateString(p0, p1, percent) {
            return percent > .5 ? p1 : p0;
        }
        function interpolateArray(p0, p1, percent, out, arrDim) {
            var len = p0.length;
            if (1 === arrDim) for (var i = 0; i < len; i++) out[i] = interpolateNumber(p0[i], p1[i], percent); else {
                var len2 = len && p0[0].length;
                for (i = 0; i < len; i++) for (var j = 0; j < len2; j++) out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);
            }
        }
        function fillArr(arr0, arr1, arrDim) {
            var arr0Len = arr0.length, arr1Len = arr1.length;
            if (arr0Len !== arr1Len) if (arr0Len > arr1Len) arr0.length = arr1Len; else for (var i = arr0Len; i < arr1Len; i++) arr0.push(1 === arrDim ? arr1[i] : arraySlice.call(arr1[i]));
            var len2 = arr0[0] && arr0[0].length;
            for (i = 0; i < arr0.length; i++) if (1 === arrDim) isNaN(arr0[i]) && (arr0[i] = arr1[i]); else for (var j = 0; j < len2; j++) isNaN(arr0[i][j]) && (arr0[i][j] = arr1[i][j]);
        }
        function isArraySame(arr0, arr1, arrDim) {
            if (arr0 === arr1) return !0;
            var len = arr0.length;
            if (len !== arr1.length) return !1;
            if (1 === arrDim) {
                for (var i = 0; i < len; i++) if (arr0[i] !== arr1[i]) return !1;
            } else {
                var len2 = arr0[0].length;
                for (i = 0; i < len; i++) for (var j = 0; j < len2; j++) if (arr0[i][j] !== arr1[i][j]) return !1;
            }
            return !0;
        }
        function catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {
            var len = p0.length;
            if (1 === arrDim) for (var i = 0; i < len; i++) out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3); else {
                var len2 = p0[0].length;
                for (i = 0; i < len; i++) for (var j = 0; j < len2; j++) out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);
            }
        }
        function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
            var v0 = .5 * (p2 - p0), v1 = .5 * (p3 - p1);
            return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
        }
        function cloneValue(value) {
            if (isArrayLike(value)) {
                var len = value.length;
                if (isArrayLike(value[0])) {
                    for (var ret = [], i = 0; i < len; i++) ret.push(arraySlice.call(value[i]));
                    return ret;
                }
                return arraySlice.call(value);
            }
            return value;
        }
        function rgba2String(rgba) {
            return rgba[0] = Math.floor(rgba[0]), rgba[1] = Math.floor(rgba[1]), rgba[2] = Math.floor(rgba[2]), 
            "rgba(" + rgba.join(",") + ")";
        }
        function createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {
            var getter = animator._getter, setter = animator._setter, useSpline = "spline" === easing, trackLen = keyframes.length;
            if (trackLen) {
                var trackMaxTime, firstVal = keyframes[0].value, isValueArray = isArrayLike(firstVal), isValueColor = !1, isValueString = !1, arrDim = isValueArray ? function(keyframes) {
                    var lastValue = keyframes[keyframes.length - 1].value;
                    return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;
                }(keyframes) : 0;
                keyframes.sort(function(a, b) {
                    return a.time - b.time;
                }), trackMaxTime = keyframes[trackLen - 1].time;
                for (var kfPercents = [], kfValues = [], prevValue = keyframes[0].value, isAllValueEqual = !0, i = 0; i < trackLen; i++) {
                    kfPercents.push(keyframes[i].time / trackMaxTime);
                    var value = keyframes[i].value;
                    if (isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue || (isAllValueEqual = !1), 
                    prevValue = value, "string" == typeof value) {
                        var colorArray = color.parse(value);
                        colorArray ? (value = colorArray, isValueColor = !0) : isValueString = !0;
                    }
                    kfValues.push(value);
                }
                if (forceAnimate || !isAllValueEqual) {
                    var lastValue = kfValues[trackLen - 1];
                    for (i = 0; i < trackLen - 1; i++) isValueArray ? fillArr(kfValues[i], lastValue, arrDim) : !isNaN(kfValues[i]) || isNaN(lastValue) || isValueString || isValueColor || (kfValues[i] = lastValue);
                    isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);
                    var w, p0, p1, p2, p3, lastFrame = 0, lastFramePercent = 0;
                    if (isValueColor) var rgba = [ 0, 0, 0, 0 ];
                    var clip = new Clip({
                        target: animator._target,
                        life: trackMaxTime,
                        loop: animator._loop,
                        delay: animator._delay,
                        onframe: function(target, percent) {
                            var frame;
                            if (percent < 0) frame = 0; else if (percent < lastFramePercent) {
                                for (frame = Math.min(lastFrame + 1, trackLen - 1); frame >= 0 && !(kfPercents[frame] <= percent); frame--) ;
                                frame = Math.min(frame, trackLen - 2);
                            } else {
                                for (frame = lastFrame; frame < trackLen && !(kfPercents[frame] > percent); frame++) ;
                                frame = Math.min(frame - 1, trackLen - 2);
                            }
                            lastFrame = frame, lastFramePercent = percent;
                            var range = kfPercents[frame + 1] - kfPercents[frame];
                            if (0 !== range) if (w = (percent - kfPercents[frame]) / range, useSpline) if (p1 = kfValues[frame], 
                            p0 = kfValues[0 === frame ? frame : frame - 1], p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1], 
                            p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2], isValueArray) catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim); else {
                                if (isValueColor) value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1), 
                                value = rgba2String(rgba); else {
                                    if (isValueString) return interpolateString(p1, p2, w);
                                    value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);
                                }
                                setter(target, propName, value);
                            } else if (isValueArray) interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim); else {
                                var value;
                                if (isValueColor) interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1), 
                                value = rgba2String(rgba); else {
                                    if (isValueString) return interpolateString(kfValues[frame], kfValues[frame + 1], w);
                                    value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);
                                }
                                setter(target, propName, value);
                            }
                        },
                        ondestroy: oneTrackDone
                    });
                    return easing && "spline" !== easing && (clip.easing = easing), clip;
                }
            }
        }
        var Animator = function(target, loop, getter, setter) {
            this._tracks = {}, this._target = target, this._loop = loop || !1, this._getter = getter || defaultGetter, 
            this._setter = setter || defaultSetter, this._clipCount = 0, this._delay = 0, this._doneList = [], 
            this._onframeList = [], this._clipList = [];
        };
        Animator.prototype = {
            when: function(time, props) {
                var tracks = this._tracks;
                for (var propName in props) if (props.hasOwnProperty(propName)) {
                    if (!tracks[propName]) {
                        tracks[propName] = [];
                        var value = this._getter(this._target, propName);
                        if (null == value) continue;
                        0 !== time && tracks[propName].push({
                            time: 0,
                            value: cloneValue(value)
                        });
                    }
                    tracks[propName].push({
                        time: time,
                        value: props[propName]
                    });
                }
                return this;
            },
            during: function(callback) {
                return this._onframeList.push(callback), this;
            },
            pause: function() {
                for (var i = 0; i < this._clipList.length; i++) this._clipList[i].pause();
                this._paused = !0;
            },
            resume: function() {
                for (var i = 0; i < this._clipList.length; i++) this._clipList[i].resume();
                this._paused = !1;
            },
            isPaused: function() {
                return !!this._paused;
            },
            _doneCallback: function() {
                this._tracks = {}, this._clipList.length = 0;
                for (var doneList = this._doneList, len = doneList.length, i = 0; i < len; i++) doneList[i].call(this);
            },
            start: function(easing, forceAnimate) {
                var lastClip, self = this, clipCount = 0, oneTrackDone = function() {
                    --clipCount || self._doneCallback();
                };
                for (var propName in this._tracks) if (this._tracks.hasOwnProperty(propName)) {
                    var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate);
                    clip && (this._clipList.push(clip), clipCount++, this.animation && this.animation.addClip(clip), 
                    lastClip = clip);
                }
                if (lastClip) {
                    var oldOnFrame = lastClip.onframe;
                    lastClip.onframe = function(target, percent) {
                        oldOnFrame(target, percent);
                        for (var i = 0; i < self._onframeList.length; i++) self._onframeList[i](target, percent);
                    };
                }
                return clipCount || this._doneCallback(), this;
            },
            stop: function(forwardToLast) {
                for (var clipList = this._clipList, animation = this.animation, i = 0; i < clipList.length; i++) {
                    var clip = clipList[i];
                    forwardToLast && clip.onframe(this._target, 1), animation && animation.removeClip(clip);
                }
                clipList.length = 0;
            },
            delay: function(time) {
                return this._delay = time, this;
            },
            done: function(cb) {
                return cb && this._doneList.push(cb), this;
            },
            getClips: function() {
                return this._clipList;
            }
        };
        var _default = Animator;
        module.exports = _default;
    }, function(module, exports) {
        var LinkedList = function() {
            this.head = null, this.tail = null, this._len = 0;
        }, linkedListProto = LinkedList.prototype;
        linkedListProto.insert = function(val) {
            var entry = new Entry(val);
            return this.insertEntry(entry), entry;
        }, linkedListProto.insertEntry = function(entry) {
            this.head ? (this.tail.next = entry, entry.prev = this.tail, entry.next = null, 
            this.tail = entry) : this.head = this.tail = entry, this._len++;
        }, linkedListProto.remove = function(entry) {
            var prev = entry.prev, next = entry.next;
            prev ? prev.next = next : this.head = next, next ? next.prev = prev : this.tail = prev, 
            entry.next = entry.prev = null, this._len--;
        }, linkedListProto.len = function() {
            return this._len;
        }, linkedListProto.clear = function() {
            this.head = this.tail = null, this._len = 0;
        };
        var Entry = function(val) {
            this.value = val, this.next, this.prev;
        }, LRU = function(maxSize) {
            this._list = new LinkedList(), this._map = {}, this._maxSize = maxSize || 10, this._lastRemovedEntry = null;
        }, LRUProto = LRU.prototype;
        LRUProto.put = function(key, value) {
            var list = this._list, map = this._map, removed = null;
            if (null == map[key]) {
                var len = list.len(), entry = this._lastRemovedEntry;
                if (len >= this._maxSize && len > 0) {
                    var leastUsedEntry = list.head;
                    list.remove(leastUsedEntry), delete map[leastUsedEntry.key], removed = leastUsedEntry.value, 
                    this._lastRemovedEntry = leastUsedEntry;
                }
                entry ? entry.value = value : entry = new Entry(value), entry.key = key, list.insertEntry(entry), 
                map[key] = entry;
            }
            return removed;
        }, LRUProto.get = function(key) {
            var entry = this._map[key], list = this._list;
            if (null != entry) return entry !== list.tail && (list.remove(entry), list.insertEntry(entry)), 
            entry.value;
        }, LRUProto.clear = function() {
            this._list.clear(), this._map = {};
        };
        var _default = LRU;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var debugMode = __webpack_require__(35).debugMode, log = function() {};
        1 === debugMode ? log = function() {
            for (var k in arguments) throw new Error(arguments[k]);
        } : debugMode > 1 && (log = function() {
            for (var k in arguments) console.log(arguments[k]);
        });
        var _default = log;
        module.exports = _default;
    }, function(module, exports) {
        var SHADOW_PROPS = {
            shadowBlur: 1,
            shadowOffsetX: 1,
            shadowOffsetY: 1,
            textShadowBlur: 1,
            textShadowOffsetX: 1,
            textShadowOffsetY: 1,
            textBoxShadowBlur: 1,
            textBoxShadowOffsetX: 1,
            textBoxShadowOffsetY: 1
        };
        module.exports = function(ctx, propName, value) {
            return SHADOW_PROPS.hasOwnProperty(propName) ? value * ctx.dpr : value;
        };
    }, function(module, exports) {
        var Pattern = function(image, repeat) {
            this.image = image, this.repeat = repeat, this.type = "pattern";
        };
        Pattern.prototype.getCanvasPattern = function(ctx) {
            return ctx.createPattern(this.image, this.repeat || "repeat");
        };
        var _default = Pattern;
        module.exports = _default;
    }, function(module, exports) {
        var _default = "undefined" != typeof window && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(func) {
            setTimeout(func, 16);
        };
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var _util = __webpack_require__(0), retrieve2 = _util.retrieve2, retrieve3 = _util.retrieve3, each = _util.each, normalizeCssArray = _util.normalizeCssArray, isString = _util.isString, isObject = _util.isObject, textContain = __webpack_require__(21), roundRectHelper = __webpack_require__(97), imageHelper = __webpack_require__(56), fixShadow = __webpack_require__(93), _constant = __webpack_require__(36), ContextCachedBy = _constant.ContextCachedBy, WILL_BE_RESTORED = _constant.WILL_BE_RESTORED, DEFAULT_FONT = textContain.DEFAULT_FONT, VALID_TEXT_ALIGN = {
            left: 1,
            right: 1,
            center: 1
        }, VALID_TEXT_VERTICAL_ALIGN = {
            top: 1,
            bottom: 1,
            middle: 1
        }, SHADOW_STYLE_COMMON_PROPS = [ [ "textShadowBlur", "shadowBlur", 0 ], [ "textShadowOffsetX", "shadowOffsetX", 0 ], [ "textShadowOffsetY", "shadowOffsetY", 0 ], [ "textShadowColor", "shadowColor", "transparent" ] ], _tmpTextPositionResult = {}, _tmpBoxPositionResult = {};
        function normalizeStyle(style) {
            if (style) {
                style.font = textContain.makeFont(style);
                var textAlign = style.textAlign;
                "middle" === textAlign && (textAlign = "center"), style.textAlign = null == textAlign || VALID_TEXT_ALIGN[textAlign] ? textAlign : "left";
                var textVerticalAlign = style.textVerticalAlign || style.textBaseline;
                "center" === textVerticalAlign && (textVerticalAlign = "middle"), style.textVerticalAlign = null == textVerticalAlign || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : "top", 
                style.textPadding && (style.textPadding = normalizeCssArray(style.textPadding));
            }
        }
        function applyTextRotation(ctx, style, rect, x, y) {
            if (rect && style.textRotation) {
                var origin = style.textOrigin;
                "center" === origin ? (x = rect.width / 2 + rect.x, y = rect.height / 2 + rect.y) : origin && (x = origin[0] + rect.x, 
                y = origin[1] + rect.y), ctx.translate(x, y), ctx.rotate(-style.textRotation), ctx.translate(-x, -y);
            }
        }
        function placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {
            var tokenStyle = style.rich[token.styleName] || {};
            tokenStyle.text = token.text;
            var textVerticalAlign = token.textVerticalAlign, y = lineTop + lineHeight / 2;
            "top" === textVerticalAlign ? y = lineTop + token.height / 2 : "bottom" === textVerticalAlign && (y = lineTop + lineHeight - token.height / 2), 
            !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, "right" === textAlign ? x - token.width : "center" === textAlign ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);
            var textPadding = token.textPadding;
            textPadding && (x = getTextXForPadding(x, textAlign, textPadding), y -= token.height / 2 - textPadding[2] - token.textHeight / 2), 
            setCtx(ctx, "shadowBlur", retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0)), 
            setCtx(ctx, "shadowColor", tokenStyle.textShadowColor || style.textShadowColor || "transparent"), 
            setCtx(ctx, "shadowOffsetX", retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0)), 
            setCtx(ctx, "shadowOffsetY", retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0)), 
            setCtx(ctx, "textAlign", textAlign), setCtx(ctx, "textBaseline", "middle"), setCtx(ctx, "font", token.font || DEFAULT_FONT);
            var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth), textFill = getFill(tokenStyle.textFill || style.textFill), textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth);
            textStroke && (setCtx(ctx, "lineWidth", textStrokeWidth), setCtx(ctx, "strokeStyle", textStroke), 
            ctx.strokeText(token.text, x, y)), textFill && (setCtx(ctx, "fillStyle", textFill), 
            ctx.fillText(token.text, x, y));
        }
        function needDrawBackground(style) {
            return !!(style.textBackgroundColor || style.textBorderWidth && style.textBorderColor);
        }
        function drawBackground(hostEl, ctx, style, x, y, width, height) {
            var textBackgroundColor = style.textBackgroundColor, textBorderWidth = style.textBorderWidth, textBorderColor = style.textBorderColor, isPlainBg = isString(textBackgroundColor);
            if (setCtx(ctx, "shadowBlur", style.textBoxShadowBlur || 0), setCtx(ctx, "shadowColor", style.textBoxShadowColor || "transparent"), 
            setCtx(ctx, "shadowOffsetX", style.textBoxShadowOffsetX || 0), setCtx(ctx, "shadowOffsetY", style.textBoxShadowOffsetY || 0), 
            isPlainBg || textBorderWidth && textBorderColor) {
                ctx.beginPath();
                var textBorderRadius = style.textBorderRadius;
                textBorderRadius ? roundRectHelper.buildPath(ctx, {
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    r: textBorderRadius
                }) : ctx.rect(x, y, width, height), ctx.closePath();
            }
            if (isPlainBg) if (setCtx(ctx, "fillStyle", textBackgroundColor), null != style.fillOpacity) {
                var originalGlobalAlpha = ctx.globalAlpha;
                ctx.globalAlpha = style.fillOpacity * style.opacity, ctx.fill(), ctx.globalAlpha = originalGlobalAlpha;
            } else ctx.fill(); else if (isObject(textBackgroundColor)) {
                var image = textBackgroundColor.image;
                (image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor)) && imageHelper.isImageReady(image) && ctx.drawImage(image, x, y, width, height);
            }
            if (textBorderWidth && textBorderColor) if (setCtx(ctx, "lineWidth", textBorderWidth), 
            setCtx(ctx, "strokeStyle", textBorderColor), null != style.strokeOpacity) {
                originalGlobalAlpha = ctx.globalAlpha;
                ctx.globalAlpha = style.strokeOpacity * style.opacity, ctx.stroke(), ctx.globalAlpha = originalGlobalAlpha;
            } else ctx.stroke();
        }
        function onBgImageLoaded(image, textBackgroundColor) {
            textBackgroundColor.image = image;
        }
        function getBoxPosition(out, hostEl, style, rect) {
            var baseX = style.x || 0, baseY = style.y || 0, textAlign = style.textAlign, textVerticalAlign = style.textVerticalAlign;
            if (rect) {
                var textPosition = style.textPosition;
                if (textPosition instanceof Array) baseX = rect.x + parsePercent(textPosition[0], rect.width), 
                baseY = rect.y + parsePercent(textPosition[1], rect.height); else {
                    var res = hostEl && hostEl.calculateTextPosition ? hostEl.calculateTextPosition(_tmpTextPositionResult, style, rect) : textContain.calculateTextPosition(_tmpTextPositionResult, style, rect);
                    baseX = res.x, baseY = res.y, textAlign = textAlign || res.textAlign, textVerticalAlign = textVerticalAlign || res.textVerticalAlign;
                }
                var textOffset = style.textOffset;
                textOffset && (baseX += textOffset[0], baseY += textOffset[1]);
            }
            return (out = out || {}).baseX = baseX, out.baseY = baseY, out.textAlign = textAlign, 
            out.textVerticalAlign = textVerticalAlign, out;
        }
        function setCtx(ctx, prop, value) {
            return ctx[prop] = fixShadow(ctx, prop, value), ctx[prop];
        }
        function getStroke(stroke, lineWidth) {
            return null == stroke || lineWidth <= 0 || "transparent" === stroke || "none" === stroke ? null : stroke.image || stroke.colorStops ? "#000" : stroke;
        }
        function getFill(fill) {
            return null == fill || "none" === fill ? null : fill.image || fill.colorStops ? "#000" : fill;
        }
        function parsePercent(value, maxValue) {
            return "string" == typeof value ? value.lastIndexOf("%") >= 0 ? parseFloat(value) / 100 * maxValue : parseFloat(value) : value;
        }
        function getTextXForPadding(x, textAlign, textPadding) {
            return "right" === textAlign ? x - textPadding[1] : "center" === textAlign ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];
        }
        exports.normalizeTextStyle = function(style) {
            return normalizeStyle(style), each(style.rich, normalizeStyle), style;
        }, exports.renderText = function(hostEl, ctx, text, style, rect, prevEl) {
            style.rich ? function(hostEl, ctx, text, style, rect, prevEl) {
                prevEl !== WILL_BE_RESTORED && (ctx.__attrCachedBy = ContextCachedBy.NONE);
                var contentBlock = hostEl.__textCotentBlock;
                contentBlock && !hostEl.__dirtyText || (contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style)), 
                function(hostEl, ctx, contentBlock, style, rect) {
                    var contentWidth = contentBlock.width, outerWidth = contentBlock.outerWidth, outerHeight = contentBlock.outerHeight, textPadding = style.textPadding, boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect), baseX = boxPos.baseX, baseY = boxPos.baseY, textAlign = boxPos.textAlign, textVerticalAlign = boxPos.textVerticalAlign;
                    applyTextRotation(ctx, style, rect, baseX, baseY);
                    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign), boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign), xLeft = boxX, lineTop = boxY;
                    textPadding && (xLeft += textPadding[3], lineTop += textPadding[0]);
                    var xRight = xLeft + contentWidth;
                    needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);
                    for (var i = 0; i < contentBlock.lines.length; i++) {
                        for (var token, line = contentBlock.lines[i], tokens = line.tokens, tokenCount = tokens.length, lineHeight = line.lineHeight, usedWidth = line.width, leftIndex = 0, lineXLeft = xLeft, lineXRight = xRight, rightIndex = tokenCount - 1; leftIndex < tokenCount && (!(token = tokens[leftIndex]).textAlign || "left" === token.textAlign); ) placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, "left"), 
                        usedWidth -= token.width, lineXLeft += token.width, leftIndex++;
                        for (;rightIndex >= 0 && "right" === (token = tokens[rightIndex]).textAlign; ) placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, "right"), 
                        usedWidth -= token.width, lineXRight -= token.width, rightIndex--;
                        for (lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2; leftIndex <= rightIndex; ) token = tokens[leftIndex], 
                        placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, "center"), 
                        lineXLeft += token.width, leftIndex++;
                        lineTop += lineHeight;
                    }
                }(hostEl, ctx, contentBlock, style, rect);
            }(hostEl, ctx, text, style, rect, prevEl) : function(hostEl, ctx, text, style, rect, prevEl) {
                "use strict";
                var prevStyle, needDrawBg = needDrawBackground(style), checkCache = !1, cachedByMe = ctx.__attrCachedBy === ContextCachedBy.PLAIN_TEXT;
                prevEl !== WILL_BE_RESTORED ? (prevEl && (prevStyle = prevEl.style, checkCache = !needDrawBg && cachedByMe && prevStyle), 
                ctx.__attrCachedBy = needDrawBg ? ContextCachedBy.NONE : ContextCachedBy.PLAIN_TEXT) : cachedByMe && (ctx.__attrCachedBy = ContextCachedBy.NONE);
                var styleFont = style.font || DEFAULT_FONT;
                checkCache && styleFont === (prevStyle.font || DEFAULT_FONT) || (ctx.font = styleFont);
                var computedFont = hostEl.__computedFont;
                hostEl.__styleFont !== styleFont && (hostEl.__styleFont = styleFont, computedFont = hostEl.__computedFont = ctx.font);
                var textPadding = style.textPadding, textLineHeight = style.textLineHeight, contentBlock = hostEl.__textCotentBlock;
                contentBlock && !hostEl.__dirtyText || (contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, computedFont, textPadding, textLineHeight, style.truncate));
                var outerHeight = contentBlock.outerHeight, textLines = contentBlock.lines, lineHeight = contentBlock.lineHeight, boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect), baseX = boxPos.baseX, baseY = boxPos.baseY, textAlign = boxPos.textAlign || "left", textVerticalAlign = boxPos.textVerticalAlign;
                applyTextRotation(ctx, style, rect, baseX, baseY);
                var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign), textX = baseX, textY = boxY;
                if (needDrawBg || textPadding) {
                    var textWidth = textContain.getWidth(text, computedFont), outerWidth = textWidth;
                    textPadding && (outerWidth += textPadding[1] + textPadding[3]);
                    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);
                    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight), 
                    textPadding && (textX = getTextXForPadding(baseX, textAlign, textPadding), textY += textPadding[0]);
                }
                ctx.textAlign = textAlign, ctx.textBaseline = "middle", ctx.globalAlpha = style.opacity || 1;
                for (var i = 0; i < SHADOW_STYLE_COMMON_PROPS.length; i++) {
                    var propItem = SHADOW_STYLE_COMMON_PROPS[i], styleProp = propItem[0], ctxProp = propItem[1], val = style[styleProp];
                    checkCache && val === prevStyle[styleProp] || (ctx[ctxProp] = fixShadow(ctx, ctxProp, val || propItem[2]));
                }
                textY += lineHeight / 2;
                var textStrokeWidth = style.textStrokeWidth, textStrokeWidthPrev = checkCache ? prevStyle.textStrokeWidth : null, strokeWidthChanged = !checkCache || textStrokeWidth !== textStrokeWidthPrev, strokeChanged = !checkCache || strokeWidthChanged || style.textStroke !== prevStyle.textStroke, textStroke = getStroke(style.textStroke, textStrokeWidth), textFill = getFill(style.textFill);
                if (textStroke && (strokeWidthChanged && (ctx.lineWidth = textStrokeWidth), strokeChanged && (ctx.strokeStyle = textStroke)), 
                textFill && (checkCache && style.textFill === prevStyle.textFill || (ctx.fillStyle = textFill)), 
                1 === textLines.length) textStroke && ctx.strokeText(textLines[0], textX, textY), 
                textFill && ctx.fillText(textLines[0], textX, textY); else for (var i = 0; i < textLines.length; i++) textStroke && ctx.strokeText(textLines[i], textX, textY), 
                textFill && ctx.fillText(textLines[i], textX, textY), textY += lineHeight;
            }(hostEl, ctx, text, style, rect, prevEl);
        }, exports.getStroke = getStroke, exports.getFill = getFill, exports.needDrawText = function(text, style) {
            return null != text && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);
        };
    }, function(module, exports) {
        exports.buildPath = function(ctx, shape) {
            var r1, r2, r3, r4, total, x = shape.x, y = shape.y, width = shape.width, height = shape.height, r = shape.r;
            width < 0 && (x += width, width = -width), height < 0 && (y += height, height = -height), 
            "number" == typeof r ? r1 = r2 = r3 = r4 = r : r instanceof Array ? 1 === r.length ? r1 = r2 = r3 = r4 = r[0] : 2 === r.length ? (r1 = r3 = r[0], 
            r2 = r4 = r[1]) : 3 === r.length ? (r1 = r[0], r2 = r4 = r[1], r3 = r[2]) : (r1 = r[0], 
            r2 = r[1], r3 = r[2], r4 = r[3]) : r1 = r2 = r3 = r4 = 0, r1 + r2 > width && (r1 *= width / (total = r1 + r2), 
            r2 *= width / total), r3 + r4 > width && (r3 *= width / (total = r3 + r4), r4 *= width / total), 
            r2 + r3 > height && (r2 *= height / (total = r2 + r3), r3 *= height / total), r1 + r4 > height && (r1 *= height / (total = r1 + r4), 
            r4 *= height / total), ctx.moveTo(x + r1, y), ctx.lineTo(x + width - r2, y), 0 !== r2 && ctx.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0), 
            ctx.lineTo(x + width, y + height - r3), 0 !== r3 && ctx.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2), 
            ctx.lineTo(x + r4, y + height), 0 !== r4 && ctx.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI), 
            ctx.lineTo(x, y + r1), 0 !== r1 && ctx.arc(x + r1, y + r1, r1, Math.PI, 1.5 * Math.PI);
        };
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(5).__DEV__;
        var _util = __webpack_require__(0), each = _util.each, filter = _util.filter, map = _util.map, isArray = _util.isArray, indexOf = _util.indexOf, isObject = _util.isObject, isString = _util.isString, createHashMap = _util.createHashMap, assert = _util.assert, clone = _util.clone, merge = _util.merge, extend = _util.extend, mixin = _util.mixin, modelUtil = __webpack_require__(3), Model = __webpack_require__(14), ComponentModel = __webpack_require__(13), globalDefault = __webpack_require__(218), colorPaletteMixin = __webpack_require__(112), resetSourceDefaulter = __webpack_require__(40).resetSourceDefaulter, OPTION_INNER_KEY = "\0_ec_inner", GlobalModel = Model.extend({
            init: function(option, parentModel, theme, optionManager) {
                theme = theme || {}, this.option = null, this._theme = new Model(theme), this._optionManager = optionManager;
            },
            setOption: function(option, optionPreprocessorFuncs) {
                assert(!(OPTION_INNER_KEY in option), "please use chart.getOption()"), this._optionManager.setOption(option, optionPreprocessorFuncs), 
                this.resetOption(null);
            },
            resetOption: function(type) {
                var optionChanged = !1, optionManager = this._optionManager;
                if (!type || "recreate" === type) {
                    var baseOption = optionManager.mountOption("recreate" === type);
                    this.option && "recreate" !== type ? (this.restoreData(), this.mergeOption(baseOption)) : function(baseOption) {
                        baseOption = baseOption, this.option = {}, this.option[OPTION_INNER_KEY] = 1, this._componentsMap = createHashMap({
                            series: []
                        }), this._seriesIndices, this._seriesIndicesMap, function(option, theme) {
                            var notMergeColorLayer = option.color && !option.colorLayer;
                            each(theme, function(themeItem, name) {
                                "colorLayer" === name && notMergeColorLayer || ComponentModel.hasClass(name) || ("object" == typeof themeItem ? option[name] = option[name] ? merge(option[name], themeItem, !1) : clone(themeItem) : null == option[name] && (option[name] = themeItem));
                            });
                        }(baseOption, this._theme.option), merge(baseOption, globalDefault, !1), this.mergeOption(baseOption);
                    }.call(this, baseOption), optionChanged = !0;
                }
                if ("timeline" !== type && "media" !== type || this.restoreData(), !type || "recreate" === type || "timeline" === type) {
                    var timelineOption = optionManager.getTimelineOption(this);
                    timelineOption && (this.mergeOption(timelineOption), optionChanged = !0);
                }
                if (!type || "recreate" === type || "media" === type) {
                    var mediaOptions = optionManager.getMediaOption(this, this._api);
                    mediaOptions.length && each(mediaOptions, function(mediaOption) {
                        this.mergeOption(mediaOption, optionChanged = !0);
                    }, this);
                }
                return optionChanged;
            },
            mergeOption: function(newOption) {
                var option = this.option, componentsMap = this._componentsMap, newCptTypes = [];
                resetSourceDefaulter(this), each(newOption, function(componentOption, mainType) {
                    null != componentOption && (ComponentModel.hasClass(mainType) ? mainType && newCptTypes.push(mainType) : option[mainType] = null == option[mainType] ? clone(componentOption) : merge(option[mainType], componentOption, !0));
                }), ComponentModel.topologicalTravel(newCptTypes, ComponentModel.getAllClassMainTypes(), function(mainType, dependencies) {
                    var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]), mapResult = modelUtil.mappingToExists(componentsMap.get(mainType), newCptOptionList);
                    modelUtil.makeIdAndName(mapResult), each(mapResult, function(item, index) {
                        var opt = item.option;
                        isObject(opt) && (item.keyInfo.mainType = mainType, item.keyInfo.subType = function(mainType, newCptOption, existComponent) {
                            return newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType : ComponentModel.determineSubType(mainType, newCptOption);
                        }(mainType, opt, item.exist));
                    });
                    var dependentModels = function(componentsMap, types) {
                        isArray(types) || (types = types ? [ types ] : []);
                        var ret = {};
                        return each(types, function(type) {
                            ret[type] = (componentsMap.get(type) || []).slice();
                        }), ret;
                    }(componentsMap, dependencies);
                    option[mainType] = [], componentsMap.set(mainType, []), each(mapResult, function(resultItem, index) {
                        var componentModel = resultItem.exist, newCptOption = resultItem.option;
                        if (assert(isObject(newCptOption) || componentModel, "Empty component definition"), 
                        newCptOption) {
                            var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, !0);
                            if (componentModel && componentModel instanceof ComponentModelClass) componentModel.name = resultItem.keyInfo.name, 
                            componentModel.mergeOption(newCptOption, this), componentModel.optionUpdated(newCptOption, !1); else {
                                var extraOpt = extend({
                                    dependentModels: dependentModels,
                                    componentIndex: index
                                }, resultItem.keyInfo);
                                componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt), extend(componentModel, extraOpt), 
                                componentModel.init(newCptOption, this, this, extraOpt), componentModel.optionUpdated(null, !0);
                            }
                        } else componentModel.mergeOption({}, this), componentModel.optionUpdated({}, !1);
                        componentsMap.get(mainType)[index] = componentModel, option[mainType][index] = componentModel.option;
                    }, this), "series" === mainType && createSeriesIndices(this, componentsMap.get("series"));
                }, this), this._seriesIndicesMap = createHashMap(this._seriesIndices = this._seriesIndices || []);
            },
            getOption: function() {
                var option = clone(this.option);
                return each(option, function(opts, mainType) {
                    if (ComponentModel.hasClass(mainType)) {
                        for (var i = (opts = modelUtil.normalizeToArray(opts)).length - 1; i >= 0; i--) modelUtil.isIdInner(opts[i]) && opts.splice(i, 1);
                        option[mainType] = opts;
                    }
                }), delete option[OPTION_INNER_KEY], option;
            },
            getTheme: function() {
                return this._theme;
            },
            getComponent: function(mainType, idx) {
                var list = this._componentsMap.get(mainType);
                if (list) return list[idx || 0];
            },
            queryComponents: function(condition) {
                var mainType = condition.mainType;
                if (!mainType) return [];
                var result, index = condition.index, id = condition.id, name = condition.name, cpts = this._componentsMap.get(mainType);
                if (!cpts || !cpts.length) return [];
                if (null != index) isArray(index) || (index = [ index ]), result = filter(map(index, function(idx) {
                    return cpts[idx];
                }), function(val) {
                    return !!val;
                }); else if (null != id) {
                    var isIdArray = isArray(id);
                    result = filter(cpts, function(cpt) {
                        return isIdArray && indexOf(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;
                    });
                } else if (null != name) {
                    var isNameArray = isArray(name);
                    result = filter(cpts, function(cpt) {
                        return isNameArray && indexOf(name, cpt.name) >= 0 || !isNameArray && cpt.name === name;
                    });
                } else result = cpts.slice();
                return filterBySubType(result, condition);
            },
            findComponents: function(condition) {
                var query = condition.query, mainType = condition.mainType, queryCond = function(q) {
                    var indexAttr = mainType + "Index", idAttr = mainType + "Id", nameAttr = mainType + "Name";
                    return !q || null == q[indexAttr] && null == q[idAttr] && null == q[nameAttr] ? null : {
                        mainType: mainType,
                        index: q[indexAttr],
                        id: q[idAttr],
                        name: q[nameAttr]
                    };
                }(query);
                return function(res) {
                    return condition.filter ? filter(res, condition.filter) : res;
                }(filterBySubType(queryCond ? this.queryComponents(queryCond) : this._componentsMap.get(mainType), condition));
            },
            eachComponent: function(mainType, cb, context) {
                var componentsMap = this._componentsMap;
                if ("function" == typeof mainType) context = cb, cb = mainType, componentsMap.each(function(components, componentType) {
                    each(components, function(component, index) {
                        cb.call(context, componentType, component, index);
                    });
                }); else if (isString(mainType)) each(componentsMap.get(mainType), cb, context); else if (isObject(mainType)) {
                    var queryResult = this.findComponents(mainType);
                    each(queryResult, cb, context);
                }
            },
            getSeriesByName: function(name) {
                var series = this._componentsMap.get("series");
                return filter(series, function(oneSeries) {
                    return oneSeries.name === name;
                });
            },
            getSeriesByIndex: function(seriesIndex) {
                return this._componentsMap.get("series")[seriesIndex];
            },
            getSeriesByType: function(subType) {
                var series = this._componentsMap.get("series");
                return filter(series, function(oneSeries) {
                    return oneSeries.subType === subType;
                });
            },
            getSeries: function() {
                return this._componentsMap.get("series").slice();
            },
            getSeriesCount: function() {
                return this._componentsMap.get("series").length;
            },
            eachSeries: function(cb, context) {
                each(this._seriesIndices, function(rawSeriesIndex) {
                    var series = this._componentsMap.get("series")[rawSeriesIndex];
                    cb.call(context, series, rawSeriesIndex);
                }, this);
            },
            eachRawSeries: function(cb, context) {
                each(this._componentsMap.get("series"), cb, context);
            },
            eachSeriesByType: function(subType, cb, context) {
                each(this._seriesIndices, function(rawSeriesIndex) {
                    var series = this._componentsMap.get("series")[rawSeriesIndex];
                    series.subType === subType && cb.call(context, series, rawSeriesIndex);
                }, this);
            },
            eachRawSeriesByType: function(subType, cb, context) {
                return each(this.getSeriesByType(subType), cb, context);
            },
            isSeriesFiltered: function(seriesModel) {
                return null == this._seriesIndicesMap.get(seriesModel.componentIndex);
            },
            getCurrentSeriesIndices: function() {
                return (this._seriesIndices || []).slice();
            },
            filterSeries: function(cb, context) {
                createSeriesIndices(this, filter(this._componentsMap.get("series"), cb, context));
            },
            restoreData: function(payload) {
                var componentsMap = this._componentsMap;
                createSeriesIndices(this, componentsMap.get("series"));
                var componentTypes = [];
                componentsMap.each(function(components, componentType) {
                    componentTypes.push(componentType);
                }), ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function(componentType, dependencies) {
                    each(componentsMap.get(componentType), function(component) {
                        ("series" !== componentType || !function(seriesModel, payload) {
                            if (payload) {
                                var index = payload.seiresIndex, id = payload.seriesId, name = payload.seriesName;
                                return null != index && seriesModel.componentIndex !== index || null != id && seriesModel.id !== id || null != name && seriesModel.name !== name;
                            }
                        }(component, payload)) && component.restoreData();
                    });
                });
            }
        });
        function createSeriesIndices(ecModel, seriesModels) {
            ecModel._seriesIndicesMap = createHashMap(ecModel._seriesIndices = map(seriesModels, function(series) {
                return series.componentIndex;
            }) || []);
        }
        function filterBySubType(components, condition) {
            return condition.hasOwnProperty("subType") ? filter(components, function(cpt) {
                return cpt.subType === condition.subType;
            }) : components;
        }
        mixin(GlobalModel, colorPaletteMixin);
        var _default = GlobalModel;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var Path = __webpack_require__(8), PathProxy = __webpack_require__(38), transformPath = __webpack_require__(207), mathSqrt = Math.sqrt, mathSin = Math.sin, mathCos = Math.cos, PI = Math.PI, vMag = function(v) {
            return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
        }, vRatio = function(u, v) {
            return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
        }, vAngle = function(u, v) {
            return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
        };
        function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
            var psi = psiDeg * (PI / 180), xp = mathCos(psi) * (x1 - x2) / 2 + mathSin(psi) * (y1 - y2) / 2, yp = -1 * mathSin(psi) * (x1 - x2) / 2 + mathCos(psi) * (y1 - y2) / 2, lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
            lambda > 1 && (rx *= mathSqrt(lambda), ry *= mathSqrt(lambda));
            var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0, cxp = f * rx * yp / ry, cyp = f * -ry * xp / rx, cx = (x1 + x2) / 2 + mathCos(psi) * cxp - mathSin(psi) * cyp, cy = (y1 + y2) / 2 + mathSin(psi) * cxp + mathCos(psi) * cyp, theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]), u = [ (xp - cxp) / rx, (yp - cyp) / ry ], v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ], dTheta = vAngle(u, v);
            vRatio(u, v) <= -1 && (dTheta = PI), vRatio(u, v) >= 1 && (dTheta = 0), 0 === fs && dTheta > 0 && (dTheta -= 2 * PI), 
            1 === fs && dTheta < 0 && (dTheta += 2 * PI), path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
        }
        var commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/gi, numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
        function createPathOptions(str, opts) {
            var pathProxy = function(data) {
                if (!data) return new PathProxy();
                for (var prevCmd, cpx = 0, cpy = 0, subpathX = cpx, subpathY = cpy, path = new PathProxy(), CMD = PathProxy.CMD, cmdList = data.match(commandReg), l = 0; l < cmdList.length; l++) {
                    for (var cmd, cmdText = cmdList[l], cmdStr = cmdText.charAt(0), p = cmdText.match(numberReg) || [], pLen = p.length, i = 0; i < pLen; i++) p[i] = parseFloat(p[i]);
                    for (var off = 0; off < pLen; ) {
                        var ctlPtx, ctlPty, rx, ry, psi, fa, fs, x1 = cpx, y1 = cpy;
                        switch (cmdStr) {
                          case "l":
                            cpx += p[off++], cpy += p[off++], cmd = CMD.L, path.addData(cmd, cpx, cpy);
                            break;

                          case "L":
                            cpx = p[off++], cpy = p[off++], cmd = CMD.L, path.addData(cmd, cpx, cpy);
                            break;

                          case "m":
                            cpx += p[off++], cpy += p[off++], cmd = CMD.M, path.addData(cmd, cpx, cpy), subpathX = cpx, 
                            subpathY = cpy, cmdStr = "l";
                            break;

                          case "M":
                            cpx = p[off++], cpy = p[off++], cmd = CMD.M, path.addData(cmd, cpx, cpy), subpathX = cpx, 
                            subpathY = cpy, cmdStr = "L";
                            break;

                          case "h":
                            cpx += p[off++], cmd = CMD.L, path.addData(cmd, cpx, cpy);
                            break;

                          case "H":
                            cpx = p[off++], cmd = CMD.L, path.addData(cmd, cpx, cpy);
                            break;

                          case "v":
                            cpy += p[off++], cmd = CMD.L, path.addData(cmd, cpx, cpy);
                            break;

                          case "V":
                            cpy = p[off++], cmd = CMD.L, path.addData(cmd, cpx, cpy);
                            break;

                          case "C":
                            cmd = CMD.C, path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]), 
                            cpx = p[off - 2], cpy = p[off - 1];
                            break;

                          case "c":
                            cmd = CMD.C, path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy), 
                            cpx += p[off - 2], cpy += p[off - 1];
                            break;

                          case "S":
                            ctlPtx = cpx, ctlPty = cpy;
                            var len = path.len(), pathData = path.data;
                            prevCmd === CMD.C && (ctlPtx += cpx - pathData[len - 4], ctlPty += cpy - pathData[len - 3]), 
                            cmd = CMD.C, x1 = p[off++], y1 = p[off++], cpx = p[off++], cpy = p[off++], path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
                            break;

                          case "s":
                            ctlPtx = cpx, ctlPty = cpy, len = path.len(), pathData = path.data, prevCmd === CMD.C && (ctlPtx += cpx - pathData[len - 4], 
                            ctlPty += cpy - pathData[len - 3]), cmd = CMD.C, x1 = cpx + p[off++], y1 = cpy + p[off++], 
                            cpx += p[off++], cpy += p[off++], path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
                            break;

                          case "Q":
                            x1 = p[off++], y1 = p[off++], cpx = p[off++], cpy = p[off++], cmd = CMD.Q, path.addData(cmd, x1, y1, cpx, cpy);
                            break;

                          case "q":
                            x1 = p[off++] + cpx, y1 = p[off++] + cpy, cpx += p[off++], cpy += p[off++], cmd = CMD.Q, 
                            path.addData(cmd, x1, y1, cpx, cpy);
                            break;

                          case "T":
                            ctlPtx = cpx, ctlPty = cpy, len = path.len(), pathData = path.data, prevCmd === CMD.Q && (ctlPtx += cpx - pathData[len - 4], 
                            ctlPty += cpy - pathData[len - 3]), cpx = p[off++], cpy = p[off++], cmd = CMD.Q, 
                            path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
                            break;

                          case "t":
                            ctlPtx = cpx, ctlPty = cpy, len = path.len(), pathData = path.data, prevCmd === CMD.Q && (ctlPtx += cpx - pathData[len - 4], 
                            ctlPty += cpy - pathData[len - 3]), cpx += p[off++], cpy += p[off++], cmd = CMD.Q, 
                            path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
                            break;

                          case "A":
                            rx = p[off++], ry = p[off++], psi = p[off++], fa = p[off++], fs = p[off++], processArc(x1 = cpx, y1 = cpy, cpx = p[off++], cpy = p[off++], fa, fs, rx, ry, psi, cmd = CMD.A, path);
                            break;

                          case "a":
                            rx = p[off++], ry = p[off++], psi = p[off++], fa = p[off++], fs = p[off++], processArc(x1 = cpx, y1 = cpy, cpx += p[off++], cpy += p[off++], fa, fs, rx, ry, psi, cmd = CMD.A, path);
                        }
                    }
                    "z" !== cmdStr && "Z" !== cmdStr || (cmd = CMD.Z, path.addData(cmd), cpx = subpathX, 
                    cpy = subpathY), prevCmd = cmd;
                }
                return path.toStatic(), path;
            }(str);
            return (opts = opts || {}).buildPath = function(path) {
                if (path.setData) {
                    path.setData(pathProxy.data), (ctx = path.getContext()) && path.rebuildPath(ctx);
                } else {
                    var ctx = path;
                    pathProxy.rebuildPath(ctx);
                }
            }, opts.applyTransform = function(m) {
                transformPath(pathProxy, m), this.dirty(!0);
            }, opts;
        }
        exports.createFromString = function(str, opts) {
            return new Path(createPathOptions(str, opts));
        }, exports.extendFromString = function(str, opts) {
            return Path.extend(createPathOptions(str, opts));
        }, exports.mergePath = function(pathEls, opts) {
            for (var pathList = [], len = pathEls.length, i = 0; i < len; i++) {
                var pathEl = pathEls[i];
                pathEl.path || pathEl.createPathProxy(), pathEl.__dirtyPath && pathEl.buildPath(pathEl.path, pathEl.shape, !0), 
                pathList.push(pathEl.path);
            }
            var pathBundle = new Path(opts);
            return pathBundle.createPathProxy(), pathBundle.buildPath = function(path) {
                path.appendPath(pathList);
                var ctx = path.getContext();
                ctx && path.rebuildPath(ctx);
            }, pathBundle;
        };
    }, function(module, exports, __webpack_require__) {
        var vec2 = __webpack_require__(6), curve = __webpack_require__(22), mathMin = Math.min, mathMax = Math.max, mathSin = Math.sin, mathCos = Math.cos, PI2 = 2 * Math.PI, start = vec2.create(), end = vec2.create(), extremity = vec2.create();
        var xDim = [], yDim = [];
        exports.fromPoints = function(points, min, max) {
            if (0 !== points.length) {
                var i, p = points[0], left = p[0], right = p[0], top = p[1], bottom = p[1];
                for (i = 1; i < points.length; i++) p = points[i], left = mathMin(left, p[0]), right = mathMax(right, p[0]), 
                top = mathMin(top, p[1]), bottom = mathMax(bottom, p[1]);
                min[0] = left, min[1] = top, max[0] = right, max[1] = bottom;
            }
        }, exports.fromLine = function(x0, y0, x1, y1, min, max) {
            min[0] = mathMin(x0, x1), min[1] = mathMin(y0, y1), max[0] = mathMax(x0, x1), max[1] = mathMax(y0, y1);
        }, exports.fromCubic = function(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {
            var i, cubicExtrema = curve.cubicExtrema, cubicAt = curve.cubicAt, n = cubicExtrema(x0, x1, x2, x3, xDim);
            for (min[0] = 1 / 0, min[1] = 1 / 0, max[0] = -1 / 0, max[1] = -1 / 0, i = 0; i < n; i++) {
                var x = cubicAt(x0, x1, x2, x3, xDim[i]);
                min[0] = mathMin(x, min[0]), max[0] = mathMax(x, max[0]);
            }
            for (n = cubicExtrema(y0, y1, y2, y3, yDim), i = 0; i < n; i++) {
                var y = cubicAt(y0, y1, y2, y3, yDim[i]);
                min[1] = mathMin(y, min[1]), max[1] = mathMax(y, max[1]);
            }
            min[0] = mathMin(x0, min[0]), max[0] = mathMax(x0, max[0]), min[0] = mathMin(x3, min[0]), 
            max[0] = mathMax(x3, max[0]), min[1] = mathMin(y0, min[1]), max[1] = mathMax(y0, max[1]), 
            min[1] = mathMin(y3, min[1]), max[1] = mathMax(y3, max[1]);
        }, exports.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {
            var quadraticExtremum = curve.quadraticExtremum, quadraticAt = curve.quadraticAt, tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0), ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0), x = quadraticAt(x0, x1, x2, tx), y = quadraticAt(y0, y1, y2, ty);
            min[0] = mathMin(x0, x2, x), min[1] = mathMin(y0, y2, y), max[0] = mathMax(x0, x2, x), 
            max[1] = mathMax(y0, y2, y);
        }, exports.fromArc = function(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {
            var vec2Min = vec2.min, vec2Max = vec2.max, diff = Math.abs(startAngle - endAngle);
            if (diff % PI2 < 1e-4 && diff > 1e-4) return min[0] = x - rx, min[1] = y - ry, max[0] = x + rx, 
            void (max[1] = y + ry);
            if (start[0] = mathCos(startAngle) * rx + x, start[1] = mathSin(startAngle) * ry + y, 
            end[0] = mathCos(endAngle) * rx + x, end[1] = mathSin(endAngle) * ry + y, vec2Min(min, start, end), 
            vec2Max(max, start, end), (startAngle %= PI2) < 0 && (startAngle += PI2), (endAngle %= PI2) < 0 && (endAngle += PI2), 
            startAngle > endAngle && !anticlockwise ? endAngle += PI2 : startAngle < endAngle && anticlockwise && (startAngle += PI2), 
            anticlockwise) {
                var tmp = endAngle;
                endAngle = startAngle, startAngle = tmp;
            }
            for (var angle = 0; angle < endAngle; angle += Math.PI / 2) angle > startAngle && (extremity[0] = mathCos(angle) * rx + x, 
            extremity[1] = mathSin(angle) * ry + y, vec2Min(min, extremity, min), vec2Max(max, extremity, max));
        };
    }, function(module, exports) {
        exports.containStroke = function(x0, y0, x1, y1, lineWidth, x, y) {
            if (0 === lineWidth) return !1;
            var _l = lineWidth, _a = 0;
            if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) return !1;
            if (x0 === x1) return Math.abs(x - x0) <= _l / 2;
            var tmp = (_a = (y0 - y1) / (x0 - x1)) * x - y + (x0 * y1 - x1 * y0) / (x0 - x1);
            return tmp * tmp / (_a * _a + 1) <= _l / 2 * _l / 2;
        };
    }, function(module, exports, __webpack_require__) {
        var quadraticProjectPoint = __webpack_require__(22).quadraticProjectPoint;
        exports.containStroke = function(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
            if (0 === lineWidth) return !1;
            var _l = lineWidth;
            return !(y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) && quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null) <= _l / 2;
        };
    }, function(module, exports) {
        var PI2 = 2 * Math.PI;
        exports.normalizeRadian = function(angle) {
            return (angle %= PI2) < 0 && (angle += PI2), angle;
        };
    }, function(module, exports) {
        module.exports = function(x0, y0, x1, y1, x, y) {
            if (y > y0 && y > y1 || y < y0 && y < y1) return 0;
            if (y1 === y0) return 0;
            var dir = y1 < y0 ? 1 : -1, t = (y - y0) / (y1 - y0);
            1 !== t && 0 !== t || (dir = y1 < y0 ? .5 : -.5);
            var x_ = t * (x1 - x0) + x0;
            return x_ === x ? 1 / 0 : x_ > x ? dir : 0;
        };
    }, function(module, exports, __webpack_require__) {
        var _default = __webpack_require__(8).extend({
            type: "circle",
            shape: {
                cx: 0,
                cy: 0,
                r: 0
            },
            buildPath: function(ctx, shape, inBundle) {
                inBundle && ctx.moveTo(shape.cx + shape.r, shape.cy), ctx.arc(shape.cx, shape.cy, shape.r, 0, 2 * Math.PI, !0);
            }
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var env = __webpack_require__(7), shadowTemp = [ [ "shadowBlur", 0 ], [ "shadowColor", "#000" ], [ "shadowOffsetX", 0 ], [ "shadowOffsetY", 0 ] ];
        module.exports = function(orignalBrush) {
            return env.browser.ie && env.browser.version >= 11 ? function() {
                var modified, clipPaths = this.__clipPaths, style = this.style;
                if (clipPaths) for (var i = 0; i < clipPaths.length; i++) {
                    var clipPath = clipPaths[i], shape = clipPath && clipPath.shape, type = clipPath && clipPath.type;
                    if (shape && ("sector" === type && shape.startAngle === shape.endAngle || "rect" === type && (!shape.width || !shape.height))) {
                        for (var j = 0; j < shadowTemp.length; j++) shadowTemp[j][2] = style[shadowTemp[j][0]], 
                        style[shadowTemp[j][0]] = shadowTemp[j][1];
                        modified = !0;
                        break;
                    }
                }
                if (orignalBrush.apply(this, arguments), modified) for (j = 0; j < shadowTemp.length; j++) style[shadowTemp[j][0]] = shadowTemp[j][2];
            } : orignalBrush;
        };
    }, function(module, exports, __webpack_require__) {
        var Path = __webpack_require__(8), polyHelper = __webpack_require__(108), _default = Path.extend({
            type: "polygon",
            shape: {
                points: null,
                smooth: !1,
                smoothConstraint: null
            },
            buildPath: function(ctx, shape) {
                polyHelper.buildPath(ctx, shape, !0);
            }
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var smoothSpline = __webpack_require__(210), smoothBezier = __webpack_require__(211);
        exports.buildPath = function(ctx, shape, closePath) {
            var points = shape.points, smooth = shape.smooth;
            if (points && points.length >= 2) {
                if (smooth && "spline" !== smooth) {
                    var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);
                    ctx.moveTo(points[0][0], points[0][1]);
                    for (var len = points.length, i = 0; i < (closePath ? len : len - 1); i++) {
                        var cp1 = controlPoints[2 * i], cp2 = controlPoints[2 * i + 1], p = points[(i + 1) % len];
                        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
                    }
                } else {
                    "spline" === smooth && (points = smoothSpline(points, closePath)), ctx.moveTo(points[0][0], points[0][1]), 
                    i = 1;
                    for (var l = points.length; i < l; i++) ctx.lineTo(points[i][0], points[i][1]);
                }
                closePath && ctx.closePath();
            }
        };
    }, function(module, exports, __webpack_require__) {
        var Path = __webpack_require__(8), polyHelper = __webpack_require__(108), _default = Path.extend({
            type: "polyline",
            shape: {
                points: null,
                smooth: !1,
                smoothConstraint: null
            },
            style: {
                stroke: "#000",
                fill: null
            },
            buildPath: function(ctx, shape) {
                polyHelper.buildPath(ctx, shape, !1);
            }
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var Path = __webpack_require__(8), roundRectHelper = __webpack_require__(97), subPixelOptimizeRect = __webpack_require__(59).subPixelOptimizeRect, subPixelOptimizeOutputShape = {}, _default = Path.extend({
            type: "rect",
            shape: {
                r: 0,
                x: 0,
                y: 0,
                width: 0,
                height: 0
            },
            buildPath: function(ctx, shape) {
                var x, y, width, height;
                this.subPixelOptimize ? (subPixelOptimizeRect(subPixelOptimizeOutputShape, shape, this.style), 
                x = subPixelOptimizeOutputShape.x, y = subPixelOptimizeOutputShape.y, width = subPixelOptimizeOutputShape.width, 
                height = subPixelOptimizeOutputShape.height, subPixelOptimizeOutputShape.r = shape.r, 
                shape = subPixelOptimizeOutputShape) : (x = shape.x, y = shape.y, width = shape.width, 
                height = shape.height), shape.r ? roundRectHelper.buildPath(ctx, shape) : ctx.rect(x, y, width, height), 
                ctx.closePath();
            }
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var Path = __webpack_require__(8), subPixelOptimizeLine = __webpack_require__(59).subPixelOptimizeLine, subPixelOptimizeOutputShape = {}, _default = Path.extend({
            type: "line",
            shape: {
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 0,
                percent: 1
            },
            style: {
                stroke: "#000",
                fill: null
            },
            buildPath: function(ctx, shape) {
                var x1, y1, x2, y2;
                this.subPixelOptimize ? (subPixelOptimizeLine(subPixelOptimizeOutputShape, shape, this.style), 
                x1 = subPixelOptimizeOutputShape.x1, y1 = subPixelOptimizeOutputShape.y1, x2 = subPixelOptimizeOutputShape.x2, 
                y2 = subPixelOptimizeOutputShape.y2) : (x1 = shape.x1, y1 = shape.y1, x2 = shape.x2, 
                y2 = shape.y2);
                var percent = shape.percent;
                0 !== percent && (ctx.moveTo(x1, y1), percent < 1 && (x2 = x1 * (1 - percent) + x2 * percent, 
                y2 = y1 * (1 - percent) + y2 * percent), ctx.lineTo(x2, y2));
            },
            pointAt: function(p) {
                var shape = this.shape;
                return [ shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p ];
            }
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var _model = __webpack_require__(3), makeInner = _model.makeInner, normalizeToArray = _model.normalizeToArray, inner = makeInner();
        var _default = {
            clearColorPalette: function() {
                inner(this).colorIdx = 0, inner(this).colorNameMap = {};
            },
            getColorFromPalette: function(name, scope, requestColorNum) {
                var scopeFields = inner(scope = scope || this), colorIdx = scopeFields.colorIdx || 0, colorNameMap = scopeFields.colorNameMap = scopeFields.colorNameMap || {};
                if (colorNameMap.hasOwnProperty(name)) return colorNameMap[name];
                var defaultColorPalette = normalizeToArray(this.get("color", !0)), layeredColorPalette = this.get("colorLayer", !0), colorPalette = null != requestColorNum && layeredColorPalette ? function(colors, requestColorNum) {
                    for (var paletteNum = colors.length, i = 0; i < paletteNum; i++) if (colors[i].length > requestColorNum) return colors[i];
                    return colors[paletteNum - 1];
                }(layeredColorPalette, requestColorNum) : defaultColorPalette;
                if ((colorPalette = colorPalette || defaultColorPalette) && colorPalette.length) {
                    var color = colorPalette[colorIdx];
                    return name && (colorNameMap[name] = color), scopeFields.colorIdx = (colorIdx + 1) % colorPalette.length, 
                    color;
                }
            }
        };
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(5).__DEV__;
        var _util = __webpack_require__(0), createHashMap = _util.createHashMap, each = (_util.retrieve, 
        _util.each);
        var fetchers = {
            cartesian2d: function(seriesModel, result, axisMap, categoryAxisMap) {
                var xAxisModel = seriesModel.getReferringComponents("xAxis")[0], yAxisModel = seriesModel.getReferringComponents("yAxis")[0];
                result.coordSysDims = [ "x", "y" ], axisMap.set("x", xAxisModel), axisMap.set("y", yAxisModel), 
                isCategory(xAxisModel) && (categoryAxisMap.set("x", xAxisModel), result.firstCategoryDimIndex = 0), 
                isCategory(yAxisModel) && (categoryAxisMap.set("y", yAxisModel), result.firstCategoryDimIndex = 1);
            },
            singleAxis: function(seriesModel, result, axisMap, categoryAxisMap) {
                var singleAxisModel = seriesModel.getReferringComponents("singleAxis")[0];
                result.coordSysDims = [ "single" ], axisMap.set("single", singleAxisModel), isCategory(singleAxisModel) && (categoryAxisMap.set("single", singleAxisModel), 
                result.firstCategoryDimIndex = 0);
            },
            polar: function(seriesModel, result, axisMap, categoryAxisMap) {
                var polarModel = seriesModel.getReferringComponents("polar")[0], radiusAxisModel = polarModel.findAxisModel("radiusAxis"), angleAxisModel = polarModel.findAxisModel("angleAxis");
                result.coordSysDims = [ "radius", "angle" ], axisMap.set("radius", radiusAxisModel), 
                axisMap.set("angle", angleAxisModel), isCategory(radiusAxisModel) && (categoryAxisMap.set("radius", radiusAxisModel), 
                result.firstCategoryDimIndex = 0), isCategory(angleAxisModel) && (categoryAxisMap.set("angle", angleAxisModel), 
                result.firstCategoryDimIndex = 1);
            },
            geo: function(seriesModel, result, axisMap, categoryAxisMap) {
                result.coordSysDims = [ "lng", "lat" ];
            },
            parallel: function(seriesModel, result, axisMap, categoryAxisMap) {
                var ecModel = seriesModel.ecModel, parallelModel = ecModel.getComponent("parallel", seriesModel.get("parallelIndex")), coordSysDims = result.coordSysDims = parallelModel.dimensions.slice();
                each(parallelModel.parallelAxisIndex, function(axisIndex, index) {
                    var axisModel = ecModel.getComponent("parallelAxis", axisIndex), axisDim = coordSysDims[index];
                    axisMap.set(axisDim, axisModel), isCategory(axisModel) && null == result.firstCategoryDimIndex && (categoryAxisMap.set(axisDim, axisModel), 
                    result.firstCategoryDimIndex = index);
                });
            }
        };
        function isCategory(axisModel) {
            return "category" === axisModel.get("type");
        }
        exports.getCoordSysDefineBySeries = function(seriesModel) {
            var coordSysName = seriesModel.get("coordinateSystem"), result = {
                coordSysName: coordSysName,
                coordSysDims: [],
                axisMap: createHashMap(),
                categoryAxisMap: createHashMap()
            }, fetch = fetchers[coordSysName];
            if (fetch) return fetch(seriesModel, result, result.axisMap, result.categoryAxisMap), 
            result;
        };
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), echartsAPIList = [ "getDom", "getZr", "getWidth", "getHeight", "getDevicePixelRatio", "dispatchAction", "isDisposed", "on", "off", "getDataURL", "getConnectedDataURL", "getModel", "getOption", "getViewOfComponentModel", "getViewOfSeriesModel" ];
        var _default = function(chartInstance) {
            zrUtil.each(echartsAPIList, function(name) {
                this[name] = zrUtil.bind(chartInstance[name], chartInstance);
            }, this);
        };
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var retrieveRawValue = __webpack_require__(30).retrieveRawValue, _format = __webpack_require__(9), getTooltipMarker = _format.getTooltipMarker, formatTpl = _format.formatTpl, getTooltipRenderMode = __webpack_require__(3).getTooltipRenderMode, DIMENSION_LABEL_REG = /\{@(.+?)\}/g, _default = {
            getDataParams: function(dataIndex, dataType) {
                var data = this.getData(dataType), rawValue = this.getRawValue(dataIndex, dataType), rawDataIndex = data.getRawIndex(dataIndex), name = data.getName(dataIndex), itemOpt = data.getRawDataItem(dataIndex), color = data.getItemVisual(dataIndex, "color"), tooltipModel = this.ecModel.getComponent("tooltip"), renderModeOption = tooltipModel && tooltipModel.get("renderMode"), renderMode = getTooltipRenderMode(renderModeOption), mainType = this.mainType, isSeries = "series" === mainType, userOutput = data.userOutput;
                return {
                    componentType: mainType,
                    componentSubType: this.subType,
                    componentIndex: this.componentIndex,
                    seriesType: isSeries ? this.subType : null,
                    seriesIndex: this.seriesIndex,
                    seriesId: isSeries ? this.id : null,
                    seriesName: isSeries ? this.name : null,
                    name: name,
                    dataIndex: rawDataIndex,
                    data: itemOpt,
                    dataType: dataType,
                    value: rawValue,
                    color: color,
                    dimensionNames: userOutput ? userOutput.dimensionNames : null,
                    encode: userOutput ? userOutput.encode : null,
                    marker: getTooltipMarker({
                        color: color,
                        renderMode: renderMode
                    }),
                    $vars: [ "seriesName", "name", "value" ]
                };
            },
            getFormattedLabel: function(dataIndex, status, dataType, dimIndex, labelProp) {
                status = status || "normal";
                var data = this.getData(dataType), itemModel = data.getItemModel(dataIndex), params = this.getDataParams(dataIndex, dataType);
                null != dimIndex && params.value instanceof Array && (params.value = params.value[dimIndex]);
                var formatter = itemModel.get("normal" === status ? [ labelProp || "label", "formatter" ] : [ status, labelProp || "label", "formatter" ]);
                return "function" == typeof formatter ? (params.status = status, params.dimensionIndex = dimIndex, 
                formatter(params)) : "string" == typeof formatter ? formatTpl(formatter, params).replace(DIMENSION_LABEL_REG, function(origin, dim) {
                    var len = dim.length;
                    return "[" === dim.charAt(0) && "]" === dim.charAt(len - 1) && (dim = +dim.slice(1, len - 1)), 
                    retrieveRawValue(data, dataIndex, dim);
                }) : void 0;
            },
            getRawValue: function(idx, dataType) {
                return retrieveRawValue(this.getData(dataType), idx);
            },
            formatTooltip: function() {}
        };
        module.exports = _default;
    }, function(module, exports) {
        function defaultKeyGetter(item) {
            return item;
        }
        function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context) {
            this._old = oldArr, this._new = newArr, this._oldKeyGetter = oldKeyGetter || defaultKeyGetter, 
            this._newKeyGetter = newKeyGetter || defaultKeyGetter, this.context = context;
        }
        function initIndexMap(arr, map, keyArr, keyGetterName, dataDiffer) {
            for (var i = 0; i < arr.length; i++) {
                var key = "_ec_" + dataDiffer[keyGetterName](arr[i], i), existence = map[key];
                null == existence ? (keyArr.push(key), map[key] = i) : (existence.length || (map[key] = existence = [ existence ]), 
                existence.push(i));
            }
        }
        DataDiffer.prototype = {
            constructor: DataDiffer,
            add: function(func) {
                return this._add = func, this;
            },
            update: function(func) {
                return this._update = func, this;
            },
            remove: function(func) {
                return this._remove = func, this;
            },
            execute: function() {
                var oldArr = this._old, newArr = this._new, newDataIndexMap = {}, oldDataKeyArr = [], newDataKeyArr = [];
                for (initIndexMap(oldArr, {}, oldDataKeyArr, "_oldKeyGetter", this), initIndexMap(newArr, newDataIndexMap, newDataKeyArr, "_newKeyGetter", this), 
                i = 0; i < oldArr.length; i++) {
                    if (null != (idx = newDataIndexMap[key = oldDataKeyArr[i]])) (len = idx.length) ? (1 === len && (newDataIndexMap[key] = null), 
                    idx = idx.unshift()) : newDataIndexMap[key] = null, this._update && this._update(idx, i); else this._remove && this._remove(i);
                }
                for (var i = 0; i < newDataKeyArr.length; i++) {
                    var key = newDataKeyArr[i];
                    if (newDataIndexMap.hasOwnProperty(key)) {
                        var idx;
                        if (null == (idx = newDataIndexMap[key])) continue;
                        if (idx.length) for (var j = 0, len = idx.length; j < len; j++) this._add && this._add(idx[j]); else this._add && this._add(idx);
                    }
                }
            }
        };
        var _default = DataDiffer;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var completeDimensions = __webpack_require__(118);
        module.exports = function(source, opt) {
            return completeDimensions((opt = opt || {}).coordDimensions || [], source, {
                dimsDef: opt.dimensionsDefine || source.dimensionsDefine,
                encodeDef: opt.encodeDefine || source.encodeDefine,
                dimCount: opt.dimensionsCount,
                generateCoord: opt.generateCoord,
                generateCoordCount: opt.generateCoordCount
            });
        };
    }, function(module, exports, __webpack_require__) {
        var _util = __webpack_require__(0), createHashMap = _util.createHashMap, each = _util.each, isString = _util.isString, defaults = _util.defaults, extend = _util.extend, isObject = _util.isObject, clone = _util.clone, normalizeToArray = __webpack_require__(3).normalizeToArray, guessOrdinal = __webpack_require__(40).guessOrdinal, Source = __webpack_require__(28), OTHER_DIMENSIONS = __webpack_require__(66).OTHER_DIMENSIONS;
        function genName(name, map, fromZero) {
            if (fromZero || null != map.get(name)) {
                for (var i = 0; null != map.get(name + i); ) i++;
                name += i;
            }
            return map.set(name, !0), name;
        }
        var _default = function(sysDims, source, opt) {
            Source.isInstance(source) || (source = Source.seriesDataToSource(source)), opt = opt || {}, 
            sysDims = (sysDims || []).slice();
            for (var dimsDef = (opt.dimsDef || []).slice(), encodeDef = createHashMap(opt.encodeDef), dataDimNameMap = createHashMap(), coordDimNameMap = createHashMap(), result = [], dimCount = function(source, sysDims, dimsDef, optDimCount) {
                var dimCount = Math.max(source.dimensionsDetectCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);
                return each(sysDims, function(sysDimItem) {
                    var sysDimItemDimsDef = sysDimItem.dimsDef;
                    sysDimItemDimsDef && (dimCount = Math.max(dimCount, sysDimItemDimsDef.length));
                }), dimCount;
            }(source, sysDims, dimsDef, opt.dimCount), i = 0; i < dimCount; i++) {
                var dimDefItem = dimsDef[i] = extend({}, isObject(dimsDef[i]) ? dimsDef[i] : {
                    name: dimsDef[i]
                }), userDimName = dimDefItem.name, resultItem = result[i] = {
                    otherDims: {}
                };
                null != userDimName && null == dataDimNameMap.get(userDimName) && (resultItem.name = resultItem.displayName = userDimName, 
                dataDimNameMap.set(userDimName, i)), null != dimDefItem.type && (resultItem.type = dimDefItem.type), 
                null != dimDefItem.displayName && (resultItem.displayName = dimDefItem.displayName);
            }
            encodeDef.each(function(dataDims, coordDim) {
                if (1 === (dataDims = normalizeToArray(dataDims).slice()).length && !isString(dataDims[0]) && dataDims[0] < 0) encodeDef.set(coordDim, !1); else {
                    var validDataDims = encodeDef.set(coordDim, []);
                    each(dataDims, function(resultDimIdx, idx) {
                        isString(resultDimIdx) && (resultDimIdx = dataDimNameMap.get(resultDimIdx)), null != resultDimIdx && resultDimIdx < dimCount && (validDataDims[idx] = resultDimIdx, 
                        applyDim(result[resultDimIdx], coordDim, idx));
                    });
                }
            });
            var availDimIdx = 0;
            function applyDim(resultItem, coordDim, coordDimIndex) {
                null != OTHER_DIMENSIONS.get(coordDim) ? resultItem.otherDims[coordDim] = coordDimIndex : (resultItem.coordDim = coordDim, 
                resultItem.coordDimIndex = coordDimIndex, coordDimNameMap.set(coordDim, !0));
            }
            each(sysDims, function(sysDimItem, sysDimIndex) {
                var coordDim, sysDimItemDimsDef, sysDimItemOtherDims;
                if (isString(sysDimItem)) coordDim = sysDimItem, sysDimItem = {}; else {
                    coordDim = sysDimItem.name;
                    var ordinalMeta = sysDimItem.ordinalMeta;
                    sysDimItem.ordinalMeta = null, (sysDimItem = clone(sysDimItem)).ordinalMeta = ordinalMeta, 
                    sysDimItemDimsDef = sysDimItem.dimsDef, sysDimItemOtherDims = sysDimItem.otherDims, 
                    sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;
                }
                if (!1 !== (dataDims = encodeDef.get(coordDim))) {
                    var dataDims;
                    if (!(dataDims = normalizeToArray(dataDims)).length) for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {
                        for (;availDimIdx < result.length && null != result[availDimIdx].coordDim; ) availDimIdx++;
                        availDimIdx < result.length && dataDims.push(availDimIdx++);
                    }
                    each(dataDims, function(resultDimIdx, coordDimIndex) {
                        var resultItem = result[resultDimIdx];
                        if (applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex), null == resultItem.name && sysDimItemDimsDef) {
                            var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];
                            !isObject(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {
                                name: sysDimItemDimsDefItem
                            }), resultItem.name = resultItem.displayName = sysDimItemDimsDefItem.name, resultItem.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;
                        }
                        sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);
                    });
                }
            });
            var generateCoord = opt.generateCoord, generateCoordCount = opt.generateCoordCount, fromZero = null != generateCoordCount;
            generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;
            for (var extra = generateCoord || "value", resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) null == (resultItem = result[resultDimIdx] = result[resultDimIdx] || {}).coordDim && (resultItem.coordDim = genName(extra, coordDimNameMap, fromZero), 
            resultItem.coordDimIndex = 0, (!generateCoord || generateCoordCount <= 0) && (resultItem.isExtraCoord = !0), 
            generateCoordCount--), null == resultItem.name && (resultItem.name = genName(resultItem.coordDim, dataDimNameMap)), 
            null == resultItem.type && guessOrdinal(source, resultDimIdx, resultItem.name) && (resultItem.type = "ordinal");
            return result;
        };
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var _util = __webpack_require__(0), createHashMap = _util.createHashMap, isObject = _util.isObject, map = _util.map;
        function OrdinalMeta(opt) {
            this.categories = opt.categories || [], this._needCollect = opt.needCollect, this._deduplication = opt.deduplication, 
            this._map;
        }
        OrdinalMeta.createByAxisModel = function(axisModel) {
            var option = axisModel.option, data = option.data, categories = data && map(data, getName);
            return new OrdinalMeta({
                categories: categories,
                needCollect: !categories,
                deduplication: !1 !== option.dedplication
            });
        };
        var proto = OrdinalMeta.prototype;
        function getOrCreateMap(ordinalMeta) {
            return ordinalMeta._map || (ordinalMeta._map = createHashMap(ordinalMeta.categories));
        }
        function getName(obj) {
            return isObject(obj) && null != obj.value ? obj.value : obj + "";
        }
        proto.getOrdinal = function(category) {
            return getOrCreateMap(this).get(category);
        }, proto.parseAndCollect = function(category) {
            var index, needCollect = this._needCollect;
            if ("string" != typeof category && !needCollect) return category;
            if (needCollect && !this._deduplication) return index = this.categories.length, 
            this.categories[index] = category, index;
            var map = getOrCreateMap(this);
            return null == (index = map.get(category)) && (needCollect ? (index = this.categories.length, 
            this.categories[index] = category, map.set(category, index)) : index = NaN), index;
        };
        var _default = OrdinalMeta;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var numberUtil = __webpack_require__(4), roundNumber = numberUtil.round;
        function getIntervalPrecision(interval) {
            return numberUtil.getPrecisionSafe(interval) + 2;
        }
        function clamp(niceTickExtent, idx, extent) {
            niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);
        }
        function fixExtent(niceTickExtent, extent) {
            !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]), !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]), 
            clamp(niceTickExtent, 0, extent), clamp(niceTickExtent, 1, extent), niceTickExtent[0] > niceTickExtent[1] && (niceTickExtent[0] = niceTickExtent[1]);
        }
        exports.intervalScaleNiceTicks = function(extent, splitNumber, minInterval, maxInterval) {
            var result = {}, span = extent[1] - extent[0], interval = result.interval = numberUtil.nice(span / splitNumber, !0);
            null != minInterval && interval < minInterval && (interval = result.interval = minInterval), 
            null != maxInterval && interval > maxInterval && (interval = result.interval = maxInterval);
            var precision = result.intervalPrecision = getIntervalPrecision(interval);
            return fixExtent(result.niceTickExtent = [ roundNumber(Math.ceil(extent[0] / interval) * interval, precision), roundNumber(Math.floor(extent[1] / interval) * interval, precision) ], extent), 
            result;
        }, exports.getIntervalPrecision = getIntervalPrecision, exports.fixExtent = fixExtent, 
        exports.intervalScaleGetTicks = function(interval, extent, niceTickExtent, intervalPrecision) {
            var ticks = [];
            if (!interval) return ticks;
            extent[0] < niceTickExtent[0] && ticks.push(extent[0]);
            for (var tick = niceTickExtent[0]; tick <= niceTickExtent[1] && (ticks.push(tick), 
            (tick = roundNumber(tick + interval, intervalPrecision)) !== ticks[ticks.length - 1]); ) if (ticks.length > 1e4) return [];
            return extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1]) && ticks.push(extent[1]), 
            ticks;
        };
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), parsePercent = __webpack_require__(4).parsePercent, isDimensionStacked = __webpack_require__(19).isDimensionStacked, createRenderPlanner = __webpack_require__(42), STACK_PREFIX = "__ec_stack_", LargeArr = "undefined" != typeof Float32Array ? Float32Array : Array;
        function getSeriesStackId(seriesModel) {
            return seriesModel.get("stack") || STACK_PREFIX + seriesModel.seriesIndex;
        }
        function getAxisKey(axis) {
            return axis.dim + axis.index;
        }
        function prepareLayoutBarSeries(seriesType, ecModel) {
            var seriesModels = [];
            return ecModel.eachSeriesByType(seriesType, function(seriesModel) {
                isOnCartesian(seriesModel) && !isInLargeMode(seriesModel) && seriesModels.push(seriesModel);
            }), seriesModels;
        }
        function makeColumnLayout(barSeries) {
            var seriesInfoList = [];
            return zrUtil.each(barSeries, function(seriesModel) {
                var data = seriesModel.getData(), baseAxis = seriesModel.coordinateSystem.getBaseAxis(), axisExtent = baseAxis.getExtent(), bandWidth = "category" === baseAxis.type ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count(), barWidth = parsePercent(seriesModel.get("barWidth"), bandWidth), barMaxWidth = parsePercent(seriesModel.get("barMaxWidth"), bandWidth), barGap = seriesModel.get("barGap"), barCategoryGap = seriesModel.get("barCategoryGap");
                seriesInfoList.push({
                    bandWidth: bandWidth,
                    barWidth: barWidth,
                    barMaxWidth: barMaxWidth,
                    barGap: barGap,
                    barCategoryGap: barCategoryGap,
                    axisKey: getAxisKey(baseAxis),
                    stackId: getSeriesStackId(seriesModel)
                });
            }), doCalBarWidthAndOffset(seriesInfoList);
        }
        function doCalBarWidthAndOffset(seriesInfoList) {
            var columnsMap = {};
            zrUtil.each(seriesInfoList, function(seriesInfo, idx) {
                var axisKey = seriesInfo.axisKey, bandWidth = seriesInfo.bandWidth, columnsOnAxis = columnsMap[axisKey] || {
                    bandWidth: bandWidth,
                    remainedWidth: bandWidth,
                    autoWidthCount: 0,
                    categoryGap: "20%",
                    gap: "30%",
                    stacks: {}
                }, stacks = columnsOnAxis.stacks;
                columnsMap[axisKey] = columnsOnAxis;
                var stackId = seriesInfo.stackId;
                stacks[stackId] || columnsOnAxis.autoWidthCount++, stacks[stackId] = stacks[stackId] || {
                    width: 0,
                    maxWidth: 0
                };
                var barWidth = seriesInfo.barWidth;
                barWidth && !stacks[stackId].width && (stacks[stackId].width = barWidth, barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth), 
                columnsOnAxis.remainedWidth -= barWidth);
                var barMaxWidth = seriesInfo.barMaxWidth;
                barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
                var barGap = seriesInfo.barGap;
                null != barGap && (columnsOnAxis.gap = barGap);
                var barCategoryGap = seriesInfo.barCategoryGap;
                null != barCategoryGap && (columnsOnAxis.categoryGap = barCategoryGap);
            });
            var result = {};
            return zrUtil.each(columnsMap, function(columnsOnAxis, coordSysName) {
                result[coordSysName] = {};
                var stacks = columnsOnAxis.stacks, bandWidth = columnsOnAxis.bandWidth, categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth), barGapPercent = parsePercent(columnsOnAxis.gap, 1), remainedWidth = columnsOnAxis.remainedWidth, autoWidthCount = columnsOnAxis.autoWidthCount, autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
                autoWidth = Math.max(autoWidth, 0), zrUtil.each(stacks, function(column, stack) {
                    var maxWidth = column.maxWidth;
                    maxWidth && maxWidth < autoWidth && (maxWidth = Math.min(maxWidth, remainedWidth), 
                    column.width && (maxWidth = Math.min(maxWidth, column.width)), remainedWidth -= maxWidth, 
                    column.width = maxWidth, autoWidthCount--);
                }), autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent), 
                autoWidth = Math.max(autoWidth, 0);
                var lastColumn, widthSum = 0;
                zrUtil.each(stacks, function(column, idx) {
                    column.width || (column.width = autoWidth), lastColumn = column, widthSum += column.width * (1 + barGapPercent);
                }), lastColumn && (widthSum -= lastColumn.width * barGapPercent);
                var offset = -widthSum / 2;
                zrUtil.each(stacks, function(column, stackId) {
                    result[coordSysName][stackId] = result[coordSysName][stackId] || {
                        offset: offset,
                        width: column.width
                    }, offset += column.width * (1 + barGapPercent);
                });
            }), result;
        }
        function retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {
            if (barWidthAndOffset && axis) {
                var result = barWidthAndOffset[getAxisKey(axis)];
                return null != result && null != seriesModel && (result = result[getSeriesStackId(seriesModel)]), 
                result;
            }
        }
        var largeLayout = {
            seriesType: "bar",
            plan: createRenderPlanner(),
            reset: function(seriesModel) {
                if (isOnCartesian(seriesModel) && isInLargeMode(seriesModel)) {
                    var data = seriesModel.getData(), cartesian = seriesModel.coordinateSystem, baseAxis = cartesian.getBaseAxis(), valueAxis = cartesian.getOtherAxis(baseAxis), valueDim = data.mapDimension(valueAxis.dim), baseDim = data.mapDimension(baseAxis.dim), valueAxisHorizontal = valueAxis.isHorizontal(), valueDimIdx = valueAxisHorizontal ? 0 : 1, barWidth = retrieveColumnLayout(makeColumnLayout([ seriesModel ]), baseAxis, seriesModel).width;
                    return barWidth > .5 || (barWidth = .5), {
                        progress: function(params, data) {
                            var dataIndex, count = params.count, largePoints = new LargeArr(2 * count), largeDataIndices = new LargeArr(count), coord = [], valuePair = [], pointsOffset = 0, idxOffset = 0;
                            for (;null != (dataIndex = params.next()); ) valuePair[valueDimIdx] = data.get(valueDim, dataIndex), 
                            valuePair[1 - valueDimIdx] = data.get(baseDim, dataIndex), coord = cartesian.dataToPoint(valuePair, null, coord), 
                            largePoints[pointsOffset++] = coord[0], largePoints[pointsOffset++] = coord[1], 
                            largeDataIndices[idxOffset++] = dataIndex;
                            data.setLayout({
                                largePoints: largePoints,
                                largeDataIndices: largeDataIndices,
                                barWidth: barWidth,
                                valueAxisStart: getValueAxisStart(baseAxis, valueAxis, !1),
                                valueAxisHorizontal: valueAxisHorizontal
                            });
                        }
                    };
                }
            }
        };
        function isOnCartesian(seriesModel) {
            return seriesModel.coordinateSystem && "cartesian2d" === seriesModel.coordinateSystem.type;
        }
        function isInLargeMode(seriesModel) {
            return seriesModel.pipelineContext && seriesModel.pipelineContext.large;
        }
        function getValueAxisStart(baseAxis, valueAxis, stacked) {
            var min, max, extent = valueAxis.getGlobalExtent();
            extent[0] > extent[1] ? (min = extent[1], max = extent[0]) : (min = extent[0], max = extent[1]);
            var valueStart = valueAxis.toGlobalCoord(valueAxis.dataToCoord(0));
            return valueStart < min && (valueStart = min), valueStart > max && (valueStart = max), 
            valueStart;
        }
        exports.getLayoutOnAxis = function(opt) {
            var params = [], baseAxis = opt.axis;
            if ("category" === baseAxis.type) {
                for (var bandWidth = baseAxis.getBandWidth(), i = 0; i < opt.count; i++) params.push(zrUtil.defaults({
                    bandWidth: bandWidth,
                    axisKey: "axis0",
                    stackId: STACK_PREFIX + i
                }, opt));
                var widthAndOffsets = doCalBarWidthAndOffset(params), result = [];
                for (i = 0; i < opt.count; i++) {
                    var item = widthAndOffsets.axis0[STACK_PREFIX + i];
                    item.offsetCenter = item.offset + item.width / 2, result.push(item);
                }
                return result;
            }
        }, exports.prepareLayoutBarSeries = prepareLayoutBarSeries, exports.makeColumnLayout = makeColumnLayout, 
        exports.retrieveColumnLayout = retrieveColumnLayout, exports.layout = function(seriesType, ecModel) {
            var seriesModels = prepareLayoutBarSeries(seriesType, ecModel), barWidthAndOffset = makeColumnLayout(seriesModels), lastStackCoords = {}, lastStackCoordsOrigin = {};
            zrUtil.each(seriesModels, function(seriesModel) {
                var data = seriesModel.getData(), cartesian = seriesModel.coordinateSystem, baseAxis = cartesian.getBaseAxis(), stackId = getSeriesStackId(seriesModel), columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId], columnOffset = columnLayoutInfo.offset, columnWidth = columnLayoutInfo.width, valueAxis = cartesian.getOtherAxis(baseAxis), barMinHeight = seriesModel.get("barMinHeight") || 0;
                lastStackCoords[stackId] = lastStackCoords[stackId] || [], lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || [], 
                data.setLayout({
                    offset: columnOffset,
                    size: columnWidth
                });
                for (var valueDim = data.mapDimension(valueAxis.dim), baseDim = data.mapDimension(baseAxis.dim), stacked = isDimensionStacked(data, valueDim), isValueAxisH = valueAxis.isHorizontal(), valueAxisStart = getValueAxisStart(0, valueAxis), idx = 0, len = data.count(); idx < len; idx++) {
                    var value = data.get(valueDim, idx), baseValue = data.get(baseDim, idx);
                    if (!isNaN(value) && !isNaN(baseValue)) {
                        var x, y, width, height, coord, sign = value >= 0 ? "p" : "n", baseCoord = valueAxisStart;
                        stacked && (lastStackCoords[stackId][baseValue] || (lastStackCoords[stackId][baseValue] = {
                            p: valueAxisStart,
                            n: valueAxisStart
                        }), baseCoord = lastStackCoords[stackId][baseValue][sign]), isValueAxisH ? (x = baseCoord, 
                        y = (coord = cartesian.dataToPoint([ value, baseValue ]))[1] + columnOffset, width = coord[0] - valueAxisStart, 
                        height = columnWidth, Math.abs(width) < barMinHeight && (width = (width < 0 ? -1 : 1) * barMinHeight), 
                        stacked && (lastStackCoords[stackId][baseValue][sign] += width)) : (x = (coord = cartesian.dataToPoint([ baseValue, value ]))[0] + columnOffset, 
                        y = baseCoord, width = columnWidth, height = coord[1] - valueAxisStart, Math.abs(height) < barMinHeight && (height = (height <= 0 ? -1 : 1) * barMinHeight), 
                        stacked && (lastStackCoords[stackId][baseValue][sign] += height)), data.setItemLayout(idx, {
                            x: x,
                            y: y,
                            width: width,
                            height: height
                        });
                    }
                }
            }, this);
        }, exports.largeLayout = largeLayout;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), _default = {
            getMin: function(origin) {
                var option = this.option, min = origin || null == option.rangeStart ? option.min : option.rangeStart;
                return this.axis && null != min && "dataMin" !== min && "function" != typeof min && !zrUtil.eqNaN(min) && (min = this.axis.scale.parse(min)), 
                min;
            },
            getMax: function(origin) {
                var option = this.option, max = origin || null == option.rangeEnd ? option.max : option.rangeEnd;
                return this.axis && null != max && "dataMax" !== max && "function" != typeof max && !zrUtil.eqNaN(max) && (max = this.axis.scale.parse(max)), 
                max;
            },
            getNeedCrossZero: function() {
                var option = this.option;
                return null == option.rangeStart && null == option.rangeEnd && !option.scale;
            },
            getCoordSysModel: zrUtil.noop,
            setRange: function(rangeStart, rangeEnd) {
                this.option.rangeStart = rangeStart, this.option.rangeEnd = rangeEnd;
            },
            resetRange: function() {
                this.option.rangeStart = this.option.rangeEnd = null;
            }
        };
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var _util = __webpack_require__(0), each = _util.each, map = _util.map, _number = __webpack_require__(4), linearMap = _number.linearMap, getPixelPrecision = _number.getPixelPrecision, _axisTickLabelBuilder = __webpack_require__(242), createAxisTicks = _axisTickLabelBuilder.createAxisTicks, createAxisLabels = _axisTickLabelBuilder.createAxisLabels, calculateCategoryInterval = _axisTickLabelBuilder.calculateCategoryInterval, NORMALIZED_EXTENT = [ 0, 1 ], Axis = function(dim, scale, extent) {
            this.dim = dim, this.scale = scale, this._extent = extent || [ 0, 0 ], this.inverse = !1, 
            this.onBand = !1;
        };
        function fixExtentWithBands(extent, nTick) {
            var margin = (extent[1] - extent[0]) / nTick / 2;
            extent[0] += margin, extent[1] -= margin;
        }
        Axis.prototype = {
            constructor: Axis,
            contain: function(coord) {
                var extent = this._extent, min = Math.min(extent[0], extent[1]), max = Math.max(extent[0], extent[1]);
                return coord >= min && coord <= max;
            },
            containData: function(data) {
                return this.contain(this.dataToCoord(data));
            },
            getExtent: function() {
                return this._extent.slice();
            },
            getPixelPrecision: function(dataExtent) {
                return getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);
            },
            setExtent: function(start, end) {
                var extent = this._extent;
                extent[0] = start, extent[1] = end;
            },
            dataToCoord: function(data, clamp) {
                var extent = this._extent, scale = this.scale;
                return data = scale.normalize(data), this.onBand && "ordinal" === scale.type && fixExtentWithBands(extent = extent.slice(), scale.count()), 
                linearMap(data, NORMALIZED_EXTENT, extent, clamp);
            },
            coordToData: function(coord, clamp) {
                var extent = this._extent, scale = this.scale;
                this.onBand && "ordinal" === scale.type && fixExtentWithBands(extent = extent.slice(), scale.count());
                var t = linearMap(coord, extent, NORMALIZED_EXTENT, clamp);
                return this.scale.scale(t);
            },
            pointToData: function(point, clamp) {},
            getTicksCoords: function(opt) {
                var tickModel = (opt = opt || {}).tickModel || this.getTickModel(), result = createAxisTicks(this, tickModel), ticks = result.ticks, ticksCoords = map(ticks, function(tickValue) {
                    return {
                        coord: this.dataToCoord(tickValue),
                        tickValue: tickValue
                    };
                }, this), alignWithLabel = tickModel.get("alignWithLabel");
                return function(axis, ticksCoords, tickCategoryInterval, alignWithLabel, clamp) {
                    var ticksLen = ticksCoords.length;
                    if (!axis.onBand || alignWithLabel || !ticksLen) return;
                    var last, axisExtent = axis.getExtent();
                    if (1 === ticksLen) ticksCoords[0].coord = axisExtent[0], last = ticksCoords[1] = {
                        coord: axisExtent[0]
                    }; else {
                        var shift = ticksCoords[1].coord - ticksCoords[0].coord;
                        each(ticksCoords, function(ticksItem) {
                            ticksItem.coord -= shift / 2;
                            var tickCategoryInterval = tickCategoryInterval || 0;
                            tickCategoryInterval % 2 > 0 && (ticksItem.coord -= shift / (2 * (tickCategoryInterval + 1)));
                        }), last = {
                            coord: ticksCoords[ticksLen - 1].coord + shift
                        }, ticksCoords.push(last);
                    }
                    var inverse = axisExtent[0] > axisExtent[1];
                    littleThan(ticksCoords[0].coord, axisExtent[0]) && (clamp ? ticksCoords[0].coord = axisExtent[0] : ticksCoords.shift());
                    clamp && littleThan(axisExtent[0], ticksCoords[0].coord) && ticksCoords.unshift({
                        coord: axisExtent[0]
                    });
                    littleThan(axisExtent[1], last.coord) && (clamp ? last.coord = axisExtent[1] : ticksCoords.pop());
                    clamp && littleThan(last.coord, axisExtent[1]) && ticksCoords.push({
                        coord: axisExtent[1]
                    });
                    function littleThan(a, b) {
                        return inverse ? a > b : a < b;
                    }
                }(this, ticksCoords, result.tickCategoryInterval, alignWithLabel, opt.clamp), ticksCoords;
            },
            getViewLabels: function() {
                return createAxisLabels(this).labels;
            },
            getLabelModel: function() {
                return this.model.getModel("axisLabel");
            },
            getTickModel: function() {
                return this.model.getModel("axisTick");
            },
            getBandWidth: function() {
                var axisExtent = this._extent, dataExtent = this.scale.getExtent(), len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);
                0 === len && (len = 1);
                var size = Math.abs(axisExtent[1] - axisExtent[0]);
                return Math.abs(size) / len;
            },
            isHorizontal: null,
            getRotate: null,
            calculateCategoryInterval: function() {
                return calculateCategoryInterval(this);
            }
        };
        var _default = Axis;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var retrieveRawValue = __webpack_require__(30).retrieveRawValue;
        exports.getDefaultLabel = function(data, dataIndex) {
            var labelDims = data.mapDimension("defaultedLabel", !0), len = labelDims.length;
            if (1 === len) return retrieveRawValue(data, dataIndex, labelDims[0]);
            if (len) {
                for (var vals = [], i = 0; i < labelDims.length; i++) {
                    var val = retrieveRawValue(data, dataIndex, labelDims[i]);
                    vals.push(val);
                }
                return vals.join(" ");
            }
        };
    }, function(module, exports, __webpack_require__) {
        var isDimensionStacked = __webpack_require__(19).isDimensionStacked, map = __webpack_require__(0).map;
        exports.prepareDataCoordInfo = function(coordSys, data, valueOrigin) {
            var stacked, baseAxis = coordSys.getBaseAxis(), valueAxis = coordSys.getOtherAxis(baseAxis), valueStart = function(valueAxis, valueOrigin) {
                var valueStart = 0, extent = valueAxis.scale.getExtent();
                return "start" === valueOrigin ? valueStart = extent[0] : "end" === valueOrigin ? valueStart = extent[1] : extent[0] > 0 ? valueStart = extent[0] : extent[1] < 0 && (valueStart = extent[1]), 
                valueStart;
            }(valueAxis, valueOrigin), baseAxisDim = baseAxis.dim, valueAxisDim = valueAxis.dim, valueDim = data.mapDimension(valueAxisDim), baseDim = data.mapDimension(baseAxisDim), baseDataOffset = "x" === valueAxisDim || "radius" === valueAxisDim ? 1 : 0, dims = map(coordSys.dimensions, function(coordDim) {
                return data.mapDimension(coordDim);
            }), stackResultDim = data.getCalculationInfo("stackResultDimension");
            return (stacked |= isDimensionStacked(data, dims[0])) && (dims[0] = stackResultDim), 
            (stacked |= isDimensionStacked(data, dims[1])) && (dims[1] = stackResultDim), {
                dataDimsForPoint: dims,
                valueStart: valueStart,
                valueAxisDim: valueAxisDim,
                baseAxisDim: baseAxisDim,
                stacked: !!stacked,
                valueDim: valueDim,
                baseDim: baseDim,
                baseDataOffset: baseDataOffset,
                stackedOverDimension: data.getCalculationInfo("stackedOverDimension")
            };
        }, exports.getStackedOnPoint = function(dataCoordInfo, coordSys, data, idx) {
            var value = NaN;
            dataCoordInfo.stacked && (value = data.get(data.getCalculationInfo("stackedOverDimension"), idx)), 
            isNaN(value) && (value = dataCoordInfo.valueStart);
            var baseDataOffset = dataCoordInfo.baseDataOffset, stackedData = [];
            return stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx), stackedData[1 - baseDataOffset] = value, 
            coordSys.dataToPoint(stackedData);
        };
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), ComponentModel = __webpack_require__(13), axisModelCreator = __webpack_require__(254), axisModelCommonMixin = __webpack_require__(122), AxisModel = ComponentModel.extend({
            type: "cartesian2dAxis",
            axis: null,
            init: function() {
                AxisModel.superApply(this, "init", arguments), this.resetRange();
            },
            mergeOption: function() {
                AxisModel.superApply(this, "mergeOption", arguments), this.resetRange();
            },
            restoreData: function() {
                AxisModel.superApply(this, "restoreData", arguments), this.resetRange();
            },
            getCoordSysModel: function() {
                return this.ecModel.queryComponents({
                    mainType: "grid",
                    index: this.option.gridIndex,
                    id: this.option.gridId
                })[0];
            }
        });
        function getAxisType(axisDim, option) {
            return option.type || (option.data ? "category" : "value");
        }
        zrUtil.merge(AxisModel.prototype, axisModelCommonMixin);
        var extraOption = {
            offset: 0
        };
        axisModelCreator("x", AxisModel, getAxisType, extraOption), axisModelCreator("y", AxisModel, getAxisType, extraOption);
        var _default = AxisModel;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var _util = __webpack_require__(0), retrieve = _util.retrieve, defaults = _util.defaults, extend = _util.extend, each = _util.each, formatUtil = __webpack_require__(9), graphic = __webpack_require__(2), Model = __webpack_require__(14), _number = __webpack_require__(4), isRadianAroundZero = _number.isRadianAroundZero, remRadian = _number.remRadian, createSymbol = __webpack_require__(16).createSymbol, matrixUtil = __webpack_require__(17), v2ApplyTransform = __webpack_require__(6).applyTransform, shouldShowAllLabels = __webpack_require__(26).shouldShowAllLabels, PI = Math.PI, AxisBuilder = function(axisModel, opt) {
            this.opt = opt, this.axisModel = axisModel, defaults(opt, {
                labelOffset: 0,
                nameDirection: 1,
                tickDirection: 1,
                labelDirection: 1,
                silent: !0
            }), this.group = new graphic.Group();
            var dumbGroup = new graphic.Group({
                position: opt.position.slice(),
                rotation: opt.rotation
            });
            dumbGroup.updateTransform(), this._transform = dumbGroup.transform, this._dumbGroup = dumbGroup;
        };
        AxisBuilder.prototype = {
            constructor: AxisBuilder,
            hasBuilder: function(name) {
                return !!builders[name];
            },
            add: function(name) {
                builders[name].call(this);
            },
            getGroup: function() {
                return this.group;
            }
        };
        var builders = {
            axisLine: function() {
                var opt = this.opt, axisModel = this.axisModel;
                if (axisModel.get("axisLine.show")) {
                    var extent = this.axisModel.axis.getExtent(), matrix = this._transform, pt1 = [ extent[0], 0 ], pt2 = [ extent[1], 0 ];
                    matrix && (v2ApplyTransform(pt1, pt1, matrix), v2ApplyTransform(pt2, pt2, matrix));
                    var lineStyle = extend({
                        lineCap: "round"
                    }, axisModel.getModel("axisLine.lineStyle").getLineStyle());
                    this.group.add(new graphic.Line({
                        anid: "line",
                        subPixelOptimize: !0,
                        shape: {
                            x1: pt1[0],
                            y1: pt1[1],
                            x2: pt2[0],
                            y2: pt2[1]
                        },
                        style: lineStyle,
                        strokeContainThreshold: opt.strokeContainThreshold || 5,
                        silent: !0,
                        z2: 1
                    }));
                    var arrows = axisModel.get("axisLine.symbol"), arrowSize = axisModel.get("axisLine.symbolSize"), arrowOffset = axisModel.get("axisLine.symbolOffset") || 0;
                    if ("number" == typeof arrowOffset && (arrowOffset = [ arrowOffset, arrowOffset ]), 
                    null != arrows) {
                        "string" == typeof arrows && (arrows = [ arrows, arrows ]), "string" != typeof arrowSize && "number" != typeof arrowSize || (arrowSize = [ arrowSize, arrowSize ]);
                        var symbolWidth = arrowSize[0], symbolHeight = arrowSize[1];
                        each([ {
                            rotate: opt.rotation + Math.PI / 2,
                            offset: arrowOffset[0],
                            r: 0
                        }, {
                            rotate: opt.rotation - Math.PI / 2,
                            offset: arrowOffset[1],
                            r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))
                        } ], function(point, index) {
                            if ("none" !== arrows[index] && null != arrows[index]) {
                                var symbol = createSymbol(arrows[index], -symbolWidth / 2, -symbolHeight / 2, symbolWidth, symbolHeight, lineStyle.stroke, !0), r = point.r + point.offset, pos = [ pt1[0] + r * Math.cos(opt.rotation), pt1[1] - r * Math.sin(opt.rotation) ];
                                symbol.attr({
                                    rotation: point.rotate,
                                    position: pos,
                                    silent: !0,
                                    z2: 11
                                }), this.group.add(symbol);
                            }
                        }, this);
                    }
                }
            },
            axisTickLabel: function() {
                var axisModel = this.axisModel, opt = this.opt, tickEls = function(axisBuilder, axisModel, opt) {
                    var axis = axisModel.axis;
                    if (!axisModel.get("axisTick.show") || axis.scale.isBlank()) return;
                    for (var tickModel = axisModel.getModel("axisTick"), lineStyleModel = tickModel.getModel("lineStyle"), tickLen = tickModel.get("length"), ticksCoords = axis.getTicksCoords(), pt1 = [], pt2 = [], matrix = axisBuilder._transform, tickEls = [], i = 0; i < ticksCoords.length; i++) {
                        var tickCoord = ticksCoords[i].coord;
                        pt1[0] = tickCoord, pt1[1] = 0, pt2[0] = tickCoord, pt2[1] = opt.tickDirection * tickLen, 
                        matrix && (v2ApplyTransform(pt1, pt1, matrix), v2ApplyTransform(pt2, pt2, matrix));
                        var tickEl = new graphic.Line({
                            anid: "tick_" + ticksCoords[i].tickValue,
                            subPixelOptimize: !0,
                            shape: {
                                x1: pt1[0],
                                y1: pt1[1],
                                x2: pt2[0],
                                y2: pt2[1]
                            },
                            style: defaults(lineStyleModel.getLineStyle(), {
                                stroke: axisModel.get("axisLine.lineStyle.color")
                            }),
                            z2: 2,
                            silent: !0
                        });
                        axisBuilder.group.add(tickEl), tickEls.push(tickEl);
                    }
                    return tickEls;
                }(this, axisModel, opt);
                !function(axisModel, labelEls, tickEls) {
                    if (shouldShowAllLabels(axisModel.axis)) return;
                    var showMinLabel = axisModel.get("axisLabel.showMinLabel"), showMaxLabel = axisModel.get("axisLabel.showMaxLabel");
                    labelEls = labelEls || [], tickEls = tickEls || [];
                    var firstLabel = labelEls[0], nextLabel = labelEls[1], lastLabel = labelEls[labelEls.length - 1], prevLabel = labelEls[labelEls.length - 2], firstTick = tickEls[0], nextTick = tickEls[1], lastTick = tickEls[tickEls.length - 1], prevTick = tickEls[tickEls.length - 2];
                    !1 === showMinLabel ? (ignoreEl(firstLabel), ignoreEl(firstTick)) : isTwoLabelOverlapped(firstLabel, nextLabel) && (showMinLabel ? (ignoreEl(nextLabel), 
                    ignoreEl(nextTick)) : (ignoreEl(firstLabel), ignoreEl(firstTick)));
                    !1 === showMaxLabel ? (ignoreEl(lastLabel), ignoreEl(lastTick)) : isTwoLabelOverlapped(prevLabel, lastLabel) && (showMaxLabel ? (ignoreEl(prevLabel), 
                    ignoreEl(prevTick)) : (ignoreEl(lastLabel), ignoreEl(lastTick)));
                }(axisModel, function(axisBuilder, axisModel, opt) {
                    var axis = axisModel.axis;
                    if (!retrieve(opt.axisLabelShow, axisModel.get("axisLabel.show")) || axis.scale.isBlank()) return;
                    var labelModel = axisModel.getModel("axisLabel"), labelMargin = labelModel.get("margin"), labels = axis.getViewLabels(), labelRotation = (retrieve(opt.labelRotate, labelModel.get("rotate")) || 0) * PI / 180, labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection), rawCategoryData = axisModel.getCategories && axisModel.getCategories(!0), labelEls = [], silent = isLabelSilent(axisModel), triggerEvent = axisModel.get("triggerEvent");
                    return each(labels, function(labelItem, index) {
                        var tickValue = labelItem.tickValue, formattedLabel = labelItem.formattedLabel, rawLabel = labelItem.rawLabel, itemLabelModel = labelModel;
                        rawCategoryData && rawCategoryData[tickValue] && rawCategoryData[tickValue].textStyle && (itemLabelModel = new Model(rawCategoryData[tickValue].textStyle, labelModel, axisModel.ecModel));
                        var textColor = itemLabelModel.getTextColor() || axisModel.get("axisLine.lineStyle.color"), pos = [ axis.dataToCoord(tickValue), opt.labelOffset + opt.labelDirection * labelMargin ], textEl = new graphic.Text({
                            anid: "label_" + tickValue,
                            position: pos,
                            rotation: labelLayout.rotation,
                            silent: silent,
                            z2: 10
                        });
                        graphic.setTextStyle(textEl.style, itemLabelModel, {
                            text: formattedLabel,
                            textAlign: itemLabelModel.getShallow("align", !0) || labelLayout.textAlign,
                            textVerticalAlign: itemLabelModel.getShallow("verticalAlign", !0) || itemLabelModel.getShallow("baseline", !0) || labelLayout.textVerticalAlign,
                            textFill: "function" == typeof textColor ? textColor("category" === axis.type ? rawLabel : "value" === axis.type ? tickValue + "" : tickValue, index) : textColor
                        }), triggerEvent && (textEl.eventData = makeAxisEventDataBase(axisModel), textEl.eventData.targetType = "axisLabel", 
                        textEl.eventData.value = rawLabel), axisBuilder._dumbGroup.add(textEl), textEl.updateTransform(), 
                        labelEls.push(textEl), axisBuilder.group.add(textEl), textEl.decomposeTransform();
                    }), labelEls;
                }(this, axisModel, opt), tickEls);
            },
            axisName: function() {
                var opt = this.opt, axisModel = this.axisModel, name = retrieve(opt.axisName, axisModel.get("name"));
                if (name) {
                    var labelLayout, axisNameAvailableWidth, nameLocation = axisModel.get("nameLocation"), nameDirection = opt.nameDirection, textStyleModel = axisModel.getModel("nameTextStyle"), gap = axisModel.get("nameGap") || 0, extent = this.axisModel.axis.getExtent(), gapSignal = extent[0] > extent[1] ? -1 : 1, pos = [ "start" === nameLocation ? extent[0] - gapSignal * gap : "end" === nameLocation ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0 ], nameRotation = axisModel.get("nameRotate");
                    null != nameRotation && (nameRotation = nameRotation * PI / 180), isNameLocationCenter(nameLocation) ? labelLayout = innerTextLayout(opt.rotation, null != nameRotation ? nameRotation : opt.rotation, nameDirection) : (labelLayout = function(opt, textPosition, textRotate, extent) {
                        var textAlign, textVerticalAlign, rotationDiff = remRadian(textRotate - opt.rotation), inverse = extent[0] > extent[1], onLeft = "start" === textPosition && !inverse || "start" !== textPosition && inverse;
                        isRadianAroundZero(rotationDiff - PI / 2) ? (textVerticalAlign = onLeft ? "bottom" : "top", 
                        textAlign = "center") : isRadianAroundZero(rotationDiff - 1.5 * PI) ? (textVerticalAlign = onLeft ? "top" : "bottom", 
                        textAlign = "center") : (textVerticalAlign = "middle", textAlign = rotationDiff < 1.5 * PI && rotationDiff > PI / 2 ? onLeft ? "left" : "right" : onLeft ? "right" : "left");
                        return {
                            rotation: rotationDiff,
                            textAlign: textAlign,
                            textVerticalAlign: textVerticalAlign
                        };
                    }(opt, nameLocation, nameRotation || 0, extent), null != (axisNameAvailableWidth = opt.axisNameAvailableWidth) && (axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation)), 
                    !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null)));
                    var textFont = textStyleModel.getFont(), truncateOpt = axisModel.get("nameTruncate", !0) || {}, ellipsis = truncateOpt.ellipsis, maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth), truncatedText = null != ellipsis && null != maxWidth ? formatUtil.truncateText(name, maxWidth, textFont, ellipsis, {
                        minChar: 2,
                        placeholder: truncateOpt.placeholder
                    }) : name, tooltipOpt = axisModel.get("tooltip", !0), mainType = axisModel.mainType, formatterParams = {
                        componentType: mainType,
                        name: name,
                        $vars: [ "name" ]
                    };
                    formatterParams[mainType + "Index"] = axisModel.componentIndex;
                    var textEl = new graphic.Text({
                        anid: "name",
                        __fullText: name,
                        __truncatedText: truncatedText,
                        position: pos,
                        rotation: labelLayout.rotation,
                        silent: isLabelSilent(axisModel),
                        z2: 1,
                        tooltip: tooltipOpt && tooltipOpt.show ? extend({
                            content: name,
                            formatter: function() {
                                return name;
                            },
                            formatterParams: formatterParams
                        }, tooltipOpt) : null
                    });
                    graphic.setTextStyle(textEl.style, textStyleModel, {
                        text: truncatedText,
                        textFont: textFont,
                        textFill: textStyleModel.getTextColor() || axisModel.get("axisLine.lineStyle.color"),
                        textAlign: textStyleModel.get("align") || labelLayout.textAlign,
                        textVerticalAlign: textStyleModel.get("verticalAlign") || labelLayout.textVerticalAlign
                    }), axisModel.get("triggerEvent") && (textEl.eventData = makeAxisEventDataBase(axisModel), 
                    textEl.eventData.targetType = "axisName", textEl.eventData.name = name), this._dumbGroup.add(textEl), 
                    textEl.updateTransform(), this.group.add(textEl), textEl.decomposeTransform();
                }
            }
        }, makeAxisEventDataBase = AxisBuilder.makeAxisEventDataBase = function(axisModel) {
            var eventData = {
                componentType: axisModel.mainType,
                componentIndex: axisModel.componentIndex
            };
            return eventData[axisModel.mainType + "Index"] = axisModel.componentIndex, eventData;
        }, innerTextLayout = AxisBuilder.innerTextLayout = function(axisRotation, textRotation, direction) {
            var textAlign, textVerticalAlign, rotationDiff = remRadian(textRotation - axisRotation);
            return isRadianAroundZero(rotationDiff) ? (textVerticalAlign = direction > 0 ? "top" : "bottom", 
            textAlign = "center") : isRadianAroundZero(rotationDiff - PI) ? (textVerticalAlign = direction > 0 ? "bottom" : "top", 
            textAlign = "center") : (textVerticalAlign = "middle", textAlign = rotationDiff > 0 && rotationDiff < PI ? direction > 0 ? "right" : "left" : direction > 0 ? "left" : "right"), 
            {
                rotation: rotationDiff,
                textAlign: textAlign,
                textVerticalAlign: textVerticalAlign
            };
        };
        var isLabelSilent = AxisBuilder.isLabelSilent = function(axisModel) {
            var tooltipOpt = axisModel.get("tooltip");
            return axisModel.get("silent") || !(axisModel.get("triggerEvent") || tooltipOpt && tooltipOpt.show);
        };
        function ignoreEl(el) {
            el && (el.ignore = !0);
        }
        function isTwoLabelOverlapped(current, next, labelLayout) {
            var firstRect = current && current.getBoundingRect().clone(), nextRect = next && next.getBoundingRect().clone();
            if (firstRect && nextRect) {
                var mRotationBack = matrixUtil.identity([]);
                return matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation), firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform())), 
                nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform())), 
                firstRect.intersect(nextRect);
            }
        }
        function isNameLocationCenter(nameLocation) {
            return "middle" === nameLocation || "center" === nameLocation;
        }
        var _default = AxisBuilder;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(5).__DEV__;
        var echarts = __webpack_require__(1), axisPointerModelHelper = __webpack_require__(45), AxisView = echarts.extendComponentView({
            type: "axis",
            _axisPointer: null,
            axisPointerClass: null,
            render: function(axisModel, ecModel, api, payload) {
                this.axisPointerClass && axisPointerModelHelper.fixValue(axisModel), AxisView.superApply(this, "render", arguments), 
                updateAxisPointer(this, axisModel, ecModel, api, payload, !0);
            },
            updateAxisPointer: function(axisModel, ecModel, api, payload, force) {
                updateAxisPointer(this, axisModel, ecModel, api, payload, !1);
            },
            remove: function(ecModel, api) {
                var axisPointer = this._axisPointer;
                axisPointer && axisPointer.remove(api), AxisView.superApply(this, "remove", arguments);
            },
            dispose: function(ecModel, api) {
                disposeAxisPointer(this, api), AxisView.superApply(this, "dispose", arguments);
            }
        });
        function updateAxisPointer(axisView, axisModel, ecModel, api, payload, forceRender) {
            var Clazz = AxisView.getAxisPointerClass(axisView.axisPointerClass);
            if (Clazz) {
                var axisPointerModel = axisPointerModelHelper.getAxisPointerModel(axisModel);
                axisPointerModel ? (axisView._axisPointer || (axisView._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : disposeAxisPointer(axisView, api);
            }
        }
        function disposeAxisPointer(axisView, ecModel, api) {
            var axisPointer = axisView._axisPointer;
            axisPointer && axisPointer.dispose(ecModel, api), axisView._axisPointer = null;
        }
        var axisPointerClazz = [];
        AxisView.registerAxisPointerClass = function(type, clazz) {
            axisPointerClazz[type] = clazz;
        }, AxisView.getAxisPointerClass = function(type) {
            return type && axisPointerClazz[type];
        };
        var _default = AxisView;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0);
        exports.layout = function(gridModel, axisModel, opt) {
            opt = opt || {};
            var grid = gridModel.coordinateSystem, axis = axisModel.axis, layout = {}, otherAxisOnZeroOf = axis.getAxesOnZeroOf()[0], rawAxisPosition = axis.position, axisPosition = otherAxisOnZeroOf ? "onZero" : rawAxisPosition, axisDim = axis.dim, rect = grid.getRect(), rectBound = [ rect.x, rect.x + rect.width, rect.y, rect.y + rect.height ], idx = {
                left: 0,
                right: 1,
                top: 0,
                bottom: 1,
                onZero: 2
            }, axisOffset = axisModel.get("offset") || 0, posBound = "x" === axisDim ? [ rectBound[2] - axisOffset, rectBound[3] + axisOffset ] : [ rectBound[0] - axisOffset, rectBound[1] + axisOffset ];
            if (otherAxisOnZeroOf) {
                var onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0));
                posBound[idx.onZero] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);
            }
            layout.position = [ "y" === axisDim ? posBound[idx[axisPosition]] : rectBound[0], "x" === axisDim ? posBound[idx[axisPosition]] : rectBound[3] ], 
            layout.rotation = Math.PI / 2 * ("x" === axisDim ? 0 : 1), layout.labelDirection = layout.tickDirection = layout.nameDirection = {
                top: -1,
                bottom: 1,
                left: -1,
                right: 1
            }[rawAxisPosition], layout.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx.onZero] : 0, 
            axisModel.get("axisTick.inside") && (layout.tickDirection = -layout.tickDirection), 
            zrUtil.retrieve(opt.labelInside, axisModel.get("axisLabel.inside")) && (layout.labelDirection = -layout.labelDirection);
            var labelRotate = axisModel.get("axisLabel.rotate");
            return layout.labelRotate = "top" === axisPosition ? -labelRotate : labelRotate, 
            layout.z2 = 1, layout;
        };
    }, function(module, exports, __webpack_require__) {
        var graphic = __webpack_require__(2), LineGroup = __webpack_require__(71);
        function LineDraw(ctor) {
            this._ctor = ctor || LineGroup, this.group = new graphic.Group();
        }
        var lineDrawProto = LineDraw.prototype;
        function makeSeriesScope(lineData) {
            var hostModel = lineData.hostModel;
            return {
                lineStyle: hostModel.getModel("lineStyle").getLineStyle(),
                hoverLineStyle: hostModel.getModel("emphasis.lineStyle").getLineStyle(),
                labelModel: hostModel.getModel("label"),
                hoverLabelModel: hostModel.getModel("emphasis.label")
            };
        }
        function isPointNaN(pt) {
            return isNaN(pt[0]) || isNaN(pt[1]);
        }
        function lineNeedsDraw(pts) {
            return !isPointNaN(pts[0]) && !isPointNaN(pts[1]);
        }
        lineDrawProto.isPersistent = function() {
            return !0;
        }, lineDrawProto.updateData = function(lineData) {
            var lineDraw = this, group = lineDraw.group, oldLineData = lineDraw._lineData;
            lineDraw._lineData = lineData, oldLineData || group.removeAll();
            var seriesScope = makeSeriesScope(lineData);
            lineData.diff(oldLineData).add(function(idx) {
                !function(lineDraw, lineData, idx, seriesScope) {
                    if (!lineNeedsDraw(lineData.getItemLayout(idx))) return;
                    var el = new lineDraw._ctor(lineData, idx, seriesScope);
                    lineData.setItemGraphicEl(idx, el), lineDraw.group.add(el);
                }(lineDraw, lineData, idx, seriesScope);
            }).update(function(newIdx, oldIdx) {
                !function(lineDraw, oldLineData, newLineData, oldIdx, newIdx, seriesScope) {
                    var itemEl = oldLineData.getItemGraphicEl(oldIdx);
                    if (!lineNeedsDraw(newLineData.getItemLayout(newIdx))) return void lineDraw.group.remove(itemEl);
                    itemEl ? itemEl.updateData(newLineData, newIdx, seriesScope) : itemEl = new lineDraw._ctor(newLineData, newIdx, seriesScope);
                    newLineData.setItemGraphicEl(newIdx, itemEl), lineDraw.group.add(itemEl);
                }(lineDraw, oldLineData, lineData, oldIdx, newIdx, seriesScope);
            }).remove(function(idx) {
                group.remove(oldLineData.getItemGraphicEl(idx));
            }).execute();
        }, lineDrawProto.updateLayout = function() {
            var lineData = this._lineData;
            lineData && lineData.eachItemGraphicEl(function(el, idx) {
                el.updateLayout(lineData, idx);
            }, this);
        }, lineDrawProto.incrementalPrepareUpdate = function(lineData) {
            this._seriesScope = makeSeriesScope(lineData), this._lineData = null, this.group.removeAll();
        }, lineDrawProto.incrementalUpdate = function(taskParams, lineData) {
            function updateIncrementalAndHover(el) {
                el.isGroup || (el.incremental = el.useHoverLayer = !0);
            }
            for (var idx = taskParams.start; idx < taskParams.end; idx++) {
                if (lineNeedsDraw(lineData.getItemLayout(idx))) {
                    var el = new this._ctor(lineData, idx, this._seriesScope);
                    el.traverse(updateIncrementalAndHover), this.group.add(el), lineData.setItemGraphicEl(idx, el);
                }
            }
        }, lineDrawProto.remove = function() {
            this._clearIncremental(), this._incremental = null, this.group.removeAll();
        }, lineDrawProto._clearIncremental = function() {
            var incremental = this._incremental;
            incremental && incremental.clearDisplaybles();
        };
        var _default = LineDraw;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var graphic = __webpack_require__(2), Line = __webpack_require__(71), zrUtil = __webpack_require__(0), createSymbol = __webpack_require__(16).createSymbol, vec2 = __webpack_require__(6), curveUtil = __webpack_require__(22);
        function EffectLine(lineData, idx, seriesScope) {
            graphic.Group.call(this), this.add(this.createLine(lineData, idx, seriesScope)), 
            this._updateEffectSymbol(lineData, idx);
        }
        var effectLineProto = EffectLine.prototype;
        effectLineProto.createLine = function(lineData, idx, seriesScope) {
            return new Line(lineData, idx, seriesScope);
        }, effectLineProto._updateEffectSymbol = function(lineData, idx) {
            var effectModel = lineData.getItemModel(idx).getModel("effect"), size = effectModel.get("symbolSize"), symbolType = effectModel.get("symbol");
            zrUtil.isArray(size) || (size = [ size, size ]);
            var color = effectModel.get("color") || lineData.getItemVisual(idx, "color"), symbol = this.childAt(1);
            this._symbolType !== symbolType && (this.remove(symbol), (symbol = createSymbol(symbolType, -.5, -.5, 1, 1, color)).z2 = 100, 
            symbol.culling = !0, this.add(symbol)), symbol && (symbol.setStyle("shadowColor", color), 
            symbol.setStyle(effectModel.getItemStyle([ "color" ])), symbol.attr("scale", size), 
            symbol.setColor(color), symbol.attr("scale", size), this._symbolType = symbolType, 
            this._updateEffectAnimation(lineData, effectModel, idx));
        }, effectLineProto._updateEffectAnimation = function(lineData, effectModel, idx) {
            var symbol = this.childAt(1);
            if (symbol) {
                var self = this, points = lineData.getItemLayout(idx), period = 1e3 * effectModel.get("period"), loop = effectModel.get("loop"), constantSpeed = effectModel.get("constantSpeed"), delayExpr = zrUtil.retrieve(effectModel.get("delay"), function(idx) {
                    return idx / lineData.count() * period / 3;
                }), isDelayFunc = "function" == typeof delayExpr;
                if (symbol.ignore = !0, this.updateAnimationPoints(symbol, points), constantSpeed > 0 && (period = this.getLineLength(symbol) / constantSpeed * 1e3), 
                period !== this._period || loop !== this._loop) {
                    symbol.stopAnimation();
                    var delay = delayExpr;
                    isDelayFunc && (delay = delayExpr(idx)), symbol.__t > 0 && (delay = -period * symbol.__t), 
                    symbol.__t = 0;
                    var animator = symbol.animate("", loop).when(period, {
                        __t: 1
                    }).delay(delay).during(function() {
                        self.updateSymbolPosition(symbol);
                    });
                    loop || animator.done(function() {
                        self.remove(symbol);
                    }), animator.start();
                }
                this._period = period, this._loop = loop;
            }
        }, effectLineProto.getLineLength = function(symbol) {
            return vec2.dist(symbol.__p1, symbol.__cp1) + vec2.dist(symbol.__cp1, symbol.__p2);
        }, effectLineProto.updateAnimationPoints = function(symbol, points) {
            symbol.__p1 = points[0], symbol.__p2 = points[1], symbol.__cp1 = points[2] || [ (points[0][0] + points[1][0]) / 2, (points[0][1] + points[1][1]) / 2 ];
        }, effectLineProto.updateData = function(lineData, idx, seriesScope) {
            this.childAt(0).updateData(lineData, idx, seriesScope), this._updateEffectSymbol(lineData, idx);
        }, effectLineProto.updateSymbolPosition = function(symbol) {
            var p1 = symbol.__p1, p2 = symbol.__p2, cp1 = symbol.__cp1, t = symbol.__t, pos = symbol.position, quadraticAt = curveUtil.quadraticAt, quadraticDerivativeAt = curveUtil.quadraticDerivativeAt;
            pos[0] = quadraticAt(p1[0], cp1[0], p2[0], t), pos[1] = quadraticAt(p1[1], cp1[1], p2[1], t);
            var tx = quadraticDerivativeAt(p1[0], cp1[0], p2[0], t), ty = quadraticDerivativeAt(p1[1], cp1[1], p2[1], t);
            symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2, symbol.ignore = !1;
        }, effectLineProto.updateLayout = function(lineData, idx) {
            this.childAt(0).updateLayout(lineData, idx);
            var effectModel = lineData.getItemModel(idx).getModel("effect");
            this._updateEffectAnimation(lineData, effectModel, idx);
        }, zrUtil.inherits(EffectLine, graphic.Group);
        var _default = EffectLine;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var graphic = __webpack_require__(2), zrUtil = __webpack_require__(0);
        function Polyline(lineData, idx, seriesScope) {
            graphic.Group.call(this), this._createPolyline(lineData, idx, seriesScope);
        }
        var polylineProto = Polyline.prototype;
        polylineProto._createPolyline = function(lineData, idx, seriesScope) {
            var points = lineData.getItemLayout(idx), line = new graphic.Polyline({
                shape: {
                    points: points
                }
            });
            this.add(line), this._updateCommonStl(lineData, idx, seriesScope);
        }, polylineProto.updateData = function(lineData, idx, seriesScope) {
            var seriesModel = lineData.hostModel, line = this.childAt(0), target = {
                shape: {
                    points: lineData.getItemLayout(idx)
                }
            };
            graphic.updateProps(line, target, seriesModel, idx), this._updateCommonStl(lineData, idx, seriesScope);
        }, polylineProto._updateCommonStl = function(lineData, idx, seriesScope) {
            var line = this.childAt(0), itemModel = lineData.getItemModel(idx), visualColor = lineData.getItemVisual(idx, "color"), lineStyle = seriesScope && seriesScope.lineStyle, hoverLineStyle = seriesScope && seriesScope.hoverLineStyle;
            seriesScope && !lineData.hasItemOption || (lineStyle = itemModel.getModel("lineStyle").getLineStyle(), 
            hoverLineStyle = itemModel.getModel("emphasis.lineStyle").getLineStyle()), line.useStyle(zrUtil.defaults({
                strokeNoScale: !0,
                fill: "none",
                stroke: visualColor
            }, lineStyle)), line.hoverStyle = hoverLineStyle, graphic.setHoverStyle(this);
        }, polylineProto.updateLayout = function(lineData, idx) {
            this.childAt(0).setShape("points", lineData.getItemLayout(idx));
        }, zrUtil.inherits(Polyline, graphic.Group);
        var _default = Polyline;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var _default = {
            seriesType: "lines",
            plan: __webpack_require__(42)(),
            reset: function(seriesModel) {
                var coordSys = seriesModel.coordinateSystem, isPolyline = seriesModel.get("polyline"), isLarge = seriesModel.pipelineContext.large;
                return {
                    progress: function(params, lineData) {
                        var lineCoords = [];
                        if (isLarge) {
                            var points, segCount = params.end - params.start;
                            if (isPolyline) {
                                for (var totalCoordsCount = 0, i = params.start; i < params.end; i++) totalCoordsCount += seriesModel.getLineCoordsCount(i);
                                points = new Float32Array(segCount + 2 * totalCoordsCount);
                            } else points = new Float32Array(4 * segCount);
                            var offset = 0, pt = [];
                            for (i = params.start; i < params.end; i++) {
                                var len = seriesModel.getLineCoords(i, lineCoords);
                                isPolyline && (points[offset++] = len);
                                for (var k = 0; k < len; k++) pt = coordSys.dataToPoint(lineCoords[k], !1, pt), 
                                points[offset++] = pt[0], points[offset++] = pt[1];
                            }
                            lineData.setLayout("linesPoints", points);
                        } else for (i = params.start; i < params.end; i++) {
                            var itemModel = lineData.getItemModel(i), pts = (len = seriesModel.getLineCoords(i, lineCoords), 
                            []);
                            if (isPolyline) for (var j = 0; j < len; j++) pts.push(coordSys.dataToPoint(lineCoords[j])); else {
                                pts[0] = coordSys.dataToPoint(lineCoords[0]), pts[1] = coordSys.dataToPoint(lineCoords[1]);
                                var curveness = itemModel.get("lineStyle.curveness");
                                +curveness && (pts[2] = [ (pts[0][0] + pts[1][0]) / 2 - (pts[0][1] - pts[1][1]) * curveness, (pts[0][1] + pts[1][1]) / 2 - (pts[1][0] - pts[0][0]) * curveness ]);
                            }
                            lineData.setItemLayout(i, pts);
                        }
                    }
                };
            }
        };
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var BaseAxisPointer = __webpack_require__(280), viewHelper = __webpack_require__(135), cartesianAxisHelper = __webpack_require__(129), AxisView = __webpack_require__(128), CartesianAxisPointer = BaseAxisPointer.extend({
            makeElOption: function(elOption, value, axisModel, axisPointerModel, api) {
                var axis = axisModel.axis, grid = axis.grid, axisPointerType = axisPointerModel.get("type"), otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent(), pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, !0));
                if (axisPointerType && "none" !== axisPointerType) {
                    var elStyle = viewHelper.buildElStyle(axisPointerModel), pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent);
                    pointerOption.style = elStyle, elOption.graphicKey = pointerOption.type, elOption.pointer = pointerOption;
                }
                var layoutInfo = cartesianAxisHelper.layout(grid.model, axisModel);
                viewHelper.buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);
            },
            getHandleTransform: function(value, axisModel, axisPointerModel) {
                var layoutInfo = cartesianAxisHelper.layout(axisModel.axis.grid.model, axisModel, {
                    labelInside: !1
                });
                return layoutInfo.labelMargin = axisPointerModel.get("handle.margin"), {
                    position: viewHelper.getTransformedPosition(axisModel.axis, value, layoutInfo),
                    rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
                };
            },
            updateHandleTransform: function(transform, delta, axisModel, axisPointerModel) {
                var axis = axisModel.axis, grid = axis.grid, axisExtent = axis.getGlobalExtent(!0), otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent(), dimIndex = "x" === axis.dim ? 0 : 1, currPosition = transform.position;
                currPosition[dimIndex] += delta[dimIndex], currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]), 
                currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
                var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2, cursorPoint = [ cursorOtherValue, cursorOtherValue ];
                cursorPoint[dimIndex] = currPosition[dimIndex];
                return {
                    position: currPosition,
                    rotation: transform.rotation,
                    cursorPoint: cursorPoint,
                    tooltipOption: [ {
                        verticalAlign: "middle"
                    }, {
                        align: "center"
                    } ][dimIndex]
                };
            }
        });
        function getCartesian(grid, axis) {
            var opt = {};
            return opt[axis.dim + "AxisIndex"] = axis.index, grid.getCartesian(opt);
        }
        var pointerShapeBuilder = {
            line: function(axis, pixelValue, otherExtent) {
                return {
                    type: "Line",
                    subPixelOptimize: !0,
                    shape: viewHelper.makeLineShape([ pixelValue, otherExtent[0] ], [ pixelValue, otherExtent[1] ], getAxisDimIndex(axis))
                };
            },
            shadow: function(axis, pixelValue, otherExtent) {
                var bandWidth = Math.max(1, axis.getBandWidth()), span = otherExtent[1] - otherExtent[0];
                return {
                    type: "Rect",
                    shape: viewHelper.makeRectShape([ pixelValue - bandWidth / 2, otherExtent[0] ], [ bandWidth, span ], getAxisDimIndex(axis))
                };
            }
        };
        function getAxisDimIndex(axis) {
            return "x" === axis.dim ? 0 : 1;
        }
        AxisView.registerAxisPointerClass("CartesianAxisPointer", CartesianAxisPointer);
        var _default = CartesianAxisPointer;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), graphic = __webpack_require__(2), textContain = __webpack_require__(21), formatUtil = __webpack_require__(9), matrix = __webpack_require__(17), axisHelper = __webpack_require__(26), AxisBuilder = __webpack_require__(127);
        function buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {
            var text = getValueLabel(axisPointerModel.get("value"), axisModel.axis, axisModel.ecModel, axisPointerModel.get("seriesDataIndices"), {
                precision: axisPointerModel.get("label.precision"),
                formatter: axisPointerModel.get("label.formatter")
            }), labelModel = axisPointerModel.getModel("label"), paddings = formatUtil.normalizeCssArray(labelModel.get("padding") || 0), font = labelModel.getFont(), textRect = textContain.getBoundingRect(text, font), position = labelPos.position, width = textRect.width + paddings[1] + paddings[3], height = textRect.height + paddings[0] + paddings[2], align = labelPos.align;
            "right" === align && (position[0] -= width), "center" === align && (position[0] -= width / 2);
            var verticalAlign = labelPos.verticalAlign;
            "bottom" === verticalAlign && (position[1] -= height), "middle" === verticalAlign && (position[1] -= height / 2), 
            function(position, width, height, api) {
                var viewWidth = api.getWidth(), viewHeight = api.getHeight();
                position[0] = Math.min(position[0] + width, viewWidth) - width, position[1] = Math.min(position[1] + height, viewHeight) - height, 
                position[0] = Math.max(position[0], 0), position[1] = Math.max(position[1], 0);
            }(position, width, height, api);
            var bgColor = labelModel.get("backgroundColor");
            bgColor && "auto" !== bgColor || (bgColor = axisModel.get("axisLine.lineStyle.color")), 
            elOption.label = {
                shape: {
                    x: 0,
                    y: 0,
                    width: width,
                    height: height,
                    r: labelModel.get("borderRadius")
                },
                position: position.slice(),
                style: {
                    text: text,
                    textFont: font,
                    textFill: labelModel.getTextColor(),
                    textPosition: "inside",
                    textPadding: paddings,
                    fill: bgColor,
                    stroke: labelModel.get("borderColor") || "transparent",
                    lineWidth: labelModel.get("borderWidth") || 0,
                    shadowBlur: labelModel.get("shadowBlur"),
                    shadowColor: labelModel.get("shadowColor"),
                    shadowOffsetX: labelModel.get("shadowOffsetX"),
                    shadowOffsetY: labelModel.get("shadowOffsetY")
                },
                z2: 10
            };
        }
        function getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {
            value = axis.scale.parse(value);
            var text = axis.scale.getLabel(value, {
                precision: opt.precision
            }), formatter = opt.formatter;
            if (formatter) {
                var params = {
                    value: axisHelper.getAxisRawValue(axis, value),
                    axisDimension: axis.dim,
                    axisIndex: axis.index,
                    seriesData: []
                };
                zrUtil.each(seriesDataIndices, function(idxItem) {
                    var series = ecModel.getSeriesByIndex(idxItem.seriesIndex), dataIndex = idxItem.dataIndexInside, dataParams = series && series.getDataParams(dataIndex);
                    dataParams && params.seriesData.push(dataParams);
                }), zrUtil.isString(formatter) ? text = formatter.replace("{value}", text) : zrUtil.isFunction(formatter) && (text = formatter(params));
            }
            return text;
        }
        function getTransformedPosition(axis, value, layoutInfo) {
            var transform = matrix.create();
            return matrix.rotate(transform, transform, layoutInfo.rotation), matrix.translate(transform, transform, layoutInfo.position), 
            graphic.applyTransform([ axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0) ], transform);
        }
        exports.buildElStyle = function(axisPointerModel) {
            var style, axisPointerType = axisPointerModel.get("type"), styleModel = axisPointerModel.getModel(axisPointerType + "Style");
            return "line" === axisPointerType ? (style = styleModel.getLineStyle()).fill = null : "shadow" === axisPointerType && ((style = styleModel.getAreaStyle()).stroke = null), 
            style;
        }, exports.buildLabelElOption = buildLabelElOption, exports.getValueLabel = getValueLabel, 
        exports.getTransformedPosition = getTransformedPosition, exports.buildCartesianSingleLabelElOption = function(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {
            var textLayout = AxisBuilder.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);
            layoutInfo.labelMargin = axisPointerModel.get("label.margin"), buildLabelElOption(elOption, axisModel, axisPointerModel, api, {
                position: getTransformedPosition(axisModel.axis, value, layoutInfo),
                align: textLayout.textAlign,
                verticalAlign: textLayout.textVerticalAlign
            });
        }, exports.makeLineShape = function(p1, p2, xDimIndex) {
            return {
                x1: p1[xDimIndex = xDimIndex || 0],
                y1: p1[1 - xDimIndex],
                x2: p2[xDimIndex],
                y2: p2[1 - xDimIndex]
            };
        }, exports.makeRectShape = function(xy, wh, xDimIndex) {
            return {
                x: xy[xDimIndex = xDimIndex || 0],
                y: xy[1 - xDimIndex],
                width: wh[xDimIndex],
                height: wh[1 - xDimIndex]
            };
        }, exports.makeSectorShape = function(cx, cy, r0, r, startAngle, endAngle) {
            return {
                cx: cx,
                cy: cy,
                r0: r0,
                r: r,
                startAngle: startAngle,
                endAngle: endAngle,
                clockwise: !0
            };
        };
    }, function(module, exports, __webpack_require__) {
        var echarts = __webpack_require__(1), zrUtil = __webpack_require__(0), axisPointerModelHelper = __webpack_require__(45), axisTrigger = __webpack_require__(281);
        __webpack_require__(282), __webpack_require__(283), __webpack_require__(134), echarts.registerPreprocessor(function(option) {
            if (option) {
                (!option.axisPointer || 0 === option.axisPointer.length) && (option.axisPointer = {});
                var link = option.axisPointer.link;
                link && !zrUtil.isArray(link) && (option.axisPointer.link = [ link ]);
            }
        }), echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, function(ecModel, api) {
            ecModel.getComponent("axisPointer").coordSysAxesInfo = axisPointerModelHelper.collect(ecModel, api);
        }), echarts.registerAction({
            type: "updateAxisPointer",
            event: "updateAxisPointer",
            update: ":updateAxisPointer"
        }, axisTrigger);
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), modelUtil = __webpack_require__(3);
        module.exports = function(finder, ecModel) {
            var seriesModel, point = [], seriesIndex = finder.seriesIndex;
            if (null == seriesIndex || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) return {
                point: []
            };
            var data = seriesModel.getData(), dataIndex = modelUtil.queryDataIndex(data, finder);
            if (null == dataIndex || dataIndex < 0 || zrUtil.isArray(dataIndex)) return {
                point: []
            };
            var el = data.getItemGraphicEl(dataIndex), coordSys = seriesModel.coordinateSystem;
            if (seriesModel.getTooltipPosition) point = seriesModel.getTooltipPosition(dataIndex) || []; else if (coordSys && coordSys.dataToPoint) point = coordSys.dataToPoint(data.getValues(zrUtil.map(coordSys.dimensions, function(dim) {
                return data.mapDimension(dim);
            }), dataIndex, !0)) || []; else if (el) {
                var rect = el.getBoundingRect().clone();
                rect.applyTransform(el.transform), point = [ rect.x + rect.width / 2, rect.y + rect.height / 2 ];
            }
            return {
                point: point,
                el: el
            };
        };
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), env = __webpack_require__(7), inner = (0, __webpack_require__(3).makeInner)(), each = zrUtil.each;
        function onLeave(record, e, dispatchAction) {
            record.handler("leave", null, dispatchAction);
        }
        function doEnter(currTrigger, record, e, dispatchAction) {
            record.handler(currTrigger, e, dispatchAction);
        }
        exports.register = function(key, api, handler) {
            if (!env.node) {
                var zr = api.getZr();
                inner(zr).records || (inner(zr).records = {}), function(zr, api) {
                    function useHandler(eventType, cb) {
                        zr.on(eventType, function(e) {
                            var dis = function(api) {
                                var pendings = {
                                    showTip: [],
                                    hideTip: []
                                }, dispatchAction = function(payload) {
                                    var pendingList = pendings[payload.type];
                                    pendingList ? pendingList.push(payload) : (payload.dispatchAction = dispatchAction, 
                                    api.dispatchAction(payload));
                                };
                                return {
                                    dispatchAction: dispatchAction,
                                    pendings: pendings
                                };
                            }(api);
                            each(inner(zr).records, function(record) {
                                record && cb(record, e, dis.dispatchAction);
                            }), function(pendings, api) {
                                var actuallyPayload, showLen = pendings.showTip.length, hideLen = pendings.hideTip.length;
                                showLen ? actuallyPayload = pendings.showTip[showLen - 1] : hideLen && (actuallyPayload = pendings.hideTip[hideLen - 1]), 
                                actuallyPayload && (actuallyPayload.dispatchAction = null, api.dispatchAction(actuallyPayload));
                            }(dis.pendings, api);
                        });
                    }
                    inner(zr).initialized || (inner(zr).initialized = !0, useHandler("click", zrUtil.curry(doEnter, "click")), 
                    useHandler("mousemove", zrUtil.curry(doEnter, "mousemove")), useHandler("globalout", onLeave));
                }(zr, api), (inner(zr).records[key] || (inner(zr).records[key] = {})).handler = handler;
            }
        }, exports.unregister = function(key, api) {
            if (!env.node) {
                var zr = api.getZr();
                (inner(zr).records || {})[key] && (inner(zr).records[key] = null);
            }
        };
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(13).registerSubTypeDefaulter("dataZoom", function() {
            return "slider";
        });
    }, function(module, exports, __webpack_require__) {
        var echarts = __webpack_require__(1), _util = __webpack_require__(0), createHashMap = _util.createHashMap, each = _util.each;
        echarts.registerProcessor({
            getTargetSeries: function(ecModel) {
                var seriesModelMap = createHashMap();
                return ecModel.eachComponent("dataZoom", function(dataZoomModel) {
                    dataZoomModel.eachTargetAxis(function(dimNames, axisIndex, dataZoomModel) {
                        var axisProxy = dataZoomModel.getAxisProxy(dimNames.name, axisIndex);
                        each(axisProxy.getTargetSeriesModels(), function(seriesModel) {
                            seriesModelMap.set(seriesModel.uid, seriesModel);
                        });
                    });
                }), seriesModelMap;
            },
            modifyOutputEnd: !0,
            overallReset: function(ecModel, api) {
                ecModel.eachComponent("dataZoom", function(dataZoomModel) {
                    dataZoomModel.eachTargetAxis(function(dimNames, axisIndex, dataZoomModel) {
                        dataZoomModel.getAxisProxy(dimNames.name, axisIndex).reset(dataZoomModel, api);
                    }), dataZoomModel.eachTargetAxis(function(dimNames, axisIndex, dataZoomModel) {
                        dataZoomModel.getAxisProxy(dimNames.name, axisIndex).filterData(dataZoomModel, api);
                    });
                }), ecModel.eachComponent("dataZoom", function(dataZoomModel) {
                    var axisProxy = dataZoomModel.findRepresentativeAxisProxy(), percentRange = axisProxy.getDataPercentWindow(), valueRange = axisProxy.getDataValueWindow();
                    dataZoomModel.setRawRange({
                        start: percentRange[0],
                        end: percentRange[1],
                        startValue: valueRange[0],
                        endValue: valueRange[1]
                    }, !0);
                });
            }
        });
    }, function(module, exports, __webpack_require__) {
        var echarts = __webpack_require__(1), zrUtil = __webpack_require__(0), helper = __webpack_require__(72);
        echarts.registerAction("dataZoom", function(payload, ecModel) {
            var linkedNodesFinder = helper.createLinkedNodesFinder(zrUtil.bind(ecModel.eachComponent, ecModel, "dataZoom"), helper.eachAxisDim, function(model, dimNames) {
                return model.get(dimNames.axisIndex);
            }), effectedModels = [];
            ecModel.eachComponent({
                mainType: "dataZoom",
                query: payload
            }, function(model, index) {
                effectedModels.push.apply(effectedModels, linkedNodesFinder(model).nodes);
            }), zrUtil.each(effectedModels, function(dataZoomModel, index) {
                dataZoomModel.setRawRange({
                    start: payload.start,
                    end: payload.end,
                    startValue: payload.startValue,
                    endValue: payload.endValue
                });
            });
        });
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), each = zrUtil.each;
        function has(obj, name) {
            return obj && obj.hasOwnProperty && obj.hasOwnProperty(name);
        }
        module.exports = function(option) {
            var visualMap = option && option.visualMap;
            zrUtil.isArray(visualMap) || (visualMap = visualMap ? [ visualMap ] : []), each(visualMap, function(opt) {
                if (opt) {
                    has(opt, "splitList") && !has(opt, "pieces") && (opt.pieces = opt.splitList, delete opt.splitList);
                    var pieces = opt.pieces;
                    pieces && zrUtil.isArray(pieces) && each(pieces, function(piece) {
                        zrUtil.isObject(piece) && (has(piece, "start") && !has(piece, "min") && (piece.min = piece.start), 
                        has(piece, "end") && !has(piece, "max") && (piece.max = piece.end));
                    });
                }
            });
        };
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(13).registerSubTypeDefaulter("visualMap", function(option) {
            return option.categories || (option.pieces ? option.pieces.length > 0 : option.splitNumber > 0) && !option.calculable ? "piecewise" : "continuous";
        });
    }, function(module, exports, __webpack_require__) {
        var echarts = __webpack_require__(1), zrUtil = __webpack_require__(0), visualSolution = __webpack_require__(145), VisualMapping = __webpack_require__(34), VISUAL_PRIORITY = echarts.PRIORITY.VISUAL.COMPONENT;
        function getColorVisual(seriesModel, visualMapModel, value, valueState) {
            for (var mappings = visualMapModel.targetVisuals[valueState], visualTypes = VisualMapping.prepareVisualTypes(mappings), resultVisual = {
                color: seriesModel.getData().getVisual("color")
            }, i = 0, len = visualTypes.length; i < len; i++) {
                var type = visualTypes[i], mapping = mappings["opacity" === type ? "__alphaForOpacity" : type];
                mapping && mapping.applyVisual(value, getVisual, setVisual);
            }
            return resultVisual.color;
            function getVisual(key) {
                return resultVisual[key];
            }
            function setVisual(key, value) {
                resultVisual[key] = value;
            }
        }
        echarts.registerVisual(VISUAL_PRIORITY, {
            createOnAllSeries: !0,
            reset: function(seriesModel, ecModel) {
                var resetDefines = [];
                return ecModel.eachComponent("visualMap", function(visualMapModel) {
                    var pipelineContext = seriesModel.pipelineContext;
                    !visualMapModel.isTargetSeries(seriesModel) || pipelineContext && pipelineContext.large || resetDefines.push(visualSolution.incrementalApplyVisual(visualMapModel.stateList, visualMapModel.targetVisuals, zrUtil.bind(visualMapModel.getValueState, visualMapModel), visualMapModel.getDataDimension(seriesModel.getData())));
                }), resetDefines;
            }
        }), echarts.registerVisual(VISUAL_PRIORITY, {
            createOnAllSeries: !0,
            reset: function(seriesModel, ecModel) {
                var data = seriesModel.getData(), visualMetaList = [];
                ecModel.eachComponent("visualMap", function(visualMapModel) {
                    if (visualMapModel.isTargetSeries(seriesModel)) {
                        var visualMeta = visualMapModel.getVisualMeta(zrUtil.bind(getColorVisual, null, seriesModel, visualMapModel)) || {
                            stops: [],
                            outerColors: []
                        }, concreteDim = visualMapModel.getDataDimension(data), dimInfo = data.getDimensionInfo(concreteDim);
                        null != dimInfo && (visualMeta.dimension = dimInfo.index, visualMetaList.push(visualMeta));
                    }
                }), seriesModel.getData().setVisual("visualMeta", visualMetaList);
            }
        });
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), VisualMapping = __webpack_require__(34), each = zrUtil.each;
        function hasKeys(obj) {
            if (obj) for (var name in obj) if (obj.hasOwnProperty(name)) return !0;
        }
        exports.createVisualMappings = function(option, stateList, supplementVisualOption) {
            var visualMappings = {};
            return each(stateList, function(state) {
                var mappings = visualMappings[state] = function() {
                    var Creater = function() {};
                    return Creater.prototype.__hidden = Creater.prototype, new Creater();
                }();
                each(option[state], function(visualData, visualType) {
                    if (VisualMapping.isValidType(visualType)) {
                        var mappingOption = {
                            type: visualType,
                            visual: visualData
                        };
                        supplementVisualOption && supplementVisualOption(mappingOption, state), mappings[visualType] = new VisualMapping(mappingOption), 
                        "opacity" === visualType && ((mappingOption = zrUtil.clone(mappingOption)).type = "colorAlpha", 
                        mappings.__hidden.__alphaForOpacity = new VisualMapping(mappingOption));
                    }
                });
            }), visualMappings;
        }, exports.replaceVisualOption = function(thisOption, newOption, keys) {
            var has;
            zrUtil.each(keys, function(key) {
                newOption.hasOwnProperty(key) && hasKeys(newOption[key]) && (has = !0);
            }), has && zrUtil.each(keys, function(key) {
                newOption.hasOwnProperty(key) && hasKeys(newOption[key]) ? thisOption[key] = zrUtil.clone(newOption[key]) : delete thisOption[key];
            });
        }, exports.applyVisual = function(stateList, visualMappings, data, getValueState, scope, dimension) {
            var dataIndex, visualTypesMap = {};
            function getVisual(key) {
                return data.getItemVisual(dataIndex, key);
            }
            function setVisual(key, value) {
                data.setItemVisual(dataIndex, key, value);
            }
            function eachItem(valueOrIndex, index) {
                dataIndex = null == dimension ? valueOrIndex : index;
                var rawDataItem = data.getRawDataItem(dataIndex);
                if (!rawDataItem || !1 !== rawDataItem.visualMap) for (var valueState = getValueState.call(scope, valueOrIndex), mappings = visualMappings[valueState], visualTypes = visualTypesMap[valueState], i = 0, len = visualTypes.length; i < len; i++) {
                    var type = visualTypes[i];
                    mappings[type] && mappings[type].applyVisual(valueOrIndex, getVisual, setVisual);
                }
            }
            zrUtil.each(stateList, function(state) {
                var visualTypes = VisualMapping.prepareVisualTypes(visualMappings[state]);
                visualTypesMap[state] = visualTypes;
            }), null == dimension ? data.each(eachItem) : data.each([ dimension ], eachItem);
        }, exports.incrementalApplyVisual = function(stateList, visualMappings, getValueState, dim) {
            var visualTypesMap = {};
            return zrUtil.each(stateList, function(state) {
                var visualTypes = VisualMapping.prepareVisualTypes(visualMappings[state]);
                visualTypesMap[state] = visualTypes;
            }), {
                progress: function(params, data) {
                    function getVisual(key) {
                        return data.getItemVisual(dataIndex, key);
                    }
                    function setVisual(key, value) {
                        data.setItemVisual(dataIndex, key, value);
                    }
                    var dataIndex;
                    for (null != dim && (dim = data.getDimension(dim)); null != (dataIndex = params.next()); ) {
                        var rawDataItem = data.getRawDataItem(dataIndex);
                        if (!rawDataItem || !1 !== rawDataItem.visualMap) for (var value = null != dim ? data.get(dim, dataIndex, !0) : dataIndex, valueState = getValueState(value), mappings = visualMappings[valueState], visualTypes = visualTypesMap[valueState], i = 0, len = visualTypes.length; i < len; i++) {
                            var type = visualTypes[i];
                            mappings[type] && mappings[type].applyVisual(value, getVisual, setVisual);
                        }
                    }
                }
            };
        };
    }, function(module, exports, __webpack_require__) {
        var echarts = __webpack_require__(1), zrUtil = __webpack_require__(0), env = __webpack_require__(7), visualDefault = __webpack_require__(147), VisualMapping = __webpack_require__(34), visualSolution = __webpack_require__(145), modelUtil = __webpack_require__(3), numberUtil = __webpack_require__(4), mapVisual = VisualMapping.mapVisual, eachVisual = VisualMapping.eachVisual, isArray = zrUtil.isArray, each = zrUtil.each, asc = numberUtil.asc, linearMap = numberUtil.linearMap, noop = zrUtil.noop, _default = echarts.extendComponentModel({
            type: "visualMap",
            dependencies: [ "series" ],
            stateList: [ "inRange", "outOfRange" ],
            replacableOptionKeys: [ "inRange", "outOfRange", "target", "controller", "color" ],
            dataBound: [ -1 / 0, 1 / 0 ],
            layoutMode: {
                type: "box",
                ignoreSize: !0
            },
            defaultOption: {
                show: !0,
                zlevel: 0,
                z: 4,
                seriesIndex: "all",
                min: 0,
                max: 200,
                dimension: null,
                inRange: null,
                outOfRange: null,
                left: 0,
                right: null,
                top: null,
                bottom: 0,
                itemWidth: null,
                itemHeight: null,
                inverse: !1,
                orient: "vertical",
                backgroundColor: "rgba(0,0,0,0)",
                borderColor: "#ccc",
                contentColor: "#5793f3",
                inactiveColor: "#aaa",
                borderWidth: 0,
                padding: 5,
                textGap: 10,
                precision: 0,
                color: null,
                formatter: null,
                text: null,
                textStyle: {
                    color: "#333"
                }
            },
            init: function(option, parentModel, ecModel) {
                this._dataExtent, this.targetVisuals = {}, this.controllerVisuals = {}, this.textStyleModel, 
                this.itemSize, this.mergeDefaultAndTheme(option, ecModel);
            },
            optionUpdated: function(newOption, isInit) {
                var thisOption = this.option;
                env.canvasSupported || (thisOption.realtime = !1), !isInit && visualSolution.replaceVisualOption(thisOption, newOption, this.replacableOptionKeys), 
                this.textStyleModel = this.getModel("textStyle"), this.resetItemSize(), this.completeVisualOption();
            },
            resetVisual: function(supplementVisualOption) {
                var stateList = this.stateList;
                supplementVisualOption = zrUtil.bind(supplementVisualOption, this), this.controllerVisuals = visualSolution.createVisualMappings(this.option.controller, stateList, supplementVisualOption), 
                this.targetVisuals = visualSolution.createVisualMappings(this.option.target, stateList, supplementVisualOption);
            },
            getTargetSeriesIndices: function() {
                var optionSeriesIndex = this.option.seriesIndex, seriesIndices = [];
                return null == optionSeriesIndex || "all" === optionSeriesIndex ? this.ecModel.eachSeries(function(seriesModel, index) {
                    seriesIndices.push(index);
                }) : seriesIndices = modelUtil.normalizeToArray(optionSeriesIndex), seriesIndices;
            },
            eachTargetSeries: function(callback, context) {
                zrUtil.each(this.getTargetSeriesIndices(), function(seriesIndex) {
                    callback.call(context, this.ecModel.getSeriesByIndex(seriesIndex));
                }, this);
            },
            isTargetSeries: function(seriesModel) {
                var is = !1;
                return this.eachTargetSeries(function(model) {
                    model === seriesModel && (is = !0);
                }), is;
            },
            formatValueText: function(value, isCategory, edgeSymbols) {
                var isMinMax, textValue, option = this.option, precision = option.precision, dataBound = this.dataBound, formatter = option.formatter;
                return edgeSymbols = edgeSymbols || [ "<", ">" ], zrUtil.isArray(value) && (value = value.slice(), 
                isMinMax = !0), textValue = isCategory ? value : isMinMax ? [ toFixed(value[0]), toFixed(value[1]) ] : toFixed(value), 
                zrUtil.isString(formatter) ? formatter.replace("{value}", isMinMax ? textValue[0] : textValue).replace("{value2}", isMinMax ? textValue[1] : textValue) : zrUtil.isFunction(formatter) ? isMinMax ? formatter(value[0], value[1]) : formatter(value) : isMinMax ? value[0] === dataBound[0] ? edgeSymbols[0] + " " + textValue[1] : value[1] === dataBound[1] ? edgeSymbols[1] + " " + textValue[0] : textValue[0] + " - " + textValue[1] : textValue;
                function toFixed(val) {
                    return val === dataBound[0] ? "min" : val === dataBound[1] ? "max" : (+val).toFixed(Math.min(precision, 20));
                }
            },
            resetExtent: function() {
                var thisOption = this.option, extent = asc([ thisOption.min, thisOption.max ]);
                this._dataExtent = extent;
            },
            getDataDimension: function(list) {
                var optDim = this.option.dimension, listDimensions = list.dimensions;
                if (null != optDim || listDimensions.length) {
                    if (null != optDim) return list.getDimension(optDim);
                    for (var dimNames = list.dimensions, i = dimNames.length - 1; i >= 0; i--) {
                        var dimName = dimNames[i];
                        if (!list.getDimensionInfo(dimName).isCalculationCoord) return dimName;
                    }
                }
            },
            getExtent: function() {
                return this._dataExtent.slice();
            },
            completeVisualOption: function() {
                var ecModel = this.ecModel, thisOption = this.option, base = {
                    inRange: thisOption.inRange,
                    outOfRange: thisOption.outOfRange
                }, target = thisOption.target || (thisOption.target = {}), controller = thisOption.controller || (thisOption.controller = {});
                zrUtil.merge(target, base), zrUtil.merge(controller, base);
                var isCategory = this.isCategory();
                function completeSingle(base) {
                    isArray(thisOption.color) && !base.inRange && (base.inRange = {
                        color: thisOption.color.slice().reverse()
                    }), base.inRange = base.inRange || {
                        color: ecModel.get("gradientColor")
                    }, each(this.stateList, function(state) {
                        var visualType = base[state];
                        if (zrUtil.isString(visualType)) {
                            var defa = visualDefault.get(visualType, "active", isCategory);
                            defa ? (base[state] = {}, base[state][visualType] = defa) : delete base[state];
                        }
                    }, this);
                }
                completeSingle.call(this, target), completeSingle.call(this, controller), function(base, stateExist, stateAbsent) {
                    var optExist = base[stateExist], optAbsent = base[stateAbsent];
                    optExist && !optAbsent && (optAbsent = base[stateAbsent] = {}, each(optExist, function(visualData, visualType) {
                        if (VisualMapping.isValidType(visualType)) {
                            var defa = visualDefault.get(visualType, "inactive", isCategory);
                            null != defa && (optAbsent[visualType] = defa, "color" !== visualType || optAbsent.hasOwnProperty("opacity") || optAbsent.hasOwnProperty("colorAlpha") || (optAbsent.opacity = [ 0, 0 ]));
                        }
                    }));
                }.call(this, target, "inRange", "outOfRange"), function(controller) {
                    var symbolExists = (controller.inRange || {}).symbol || (controller.outOfRange || {}).symbol, symbolSizeExists = (controller.inRange || {}).symbolSize || (controller.outOfRange || {}).symbolSize, inactiveColor = this.get("inactiveColor");
                    each(this.stateList, function(state) {
                        var itemSize = this.itemSize, visuals = controller[state];
                        visuals || (visuals = controller[state] = {
                            color: isCategory ? inactiveColor : [ inactiveColor ]
                        }), null == visuals.symbol && (visuals.symbol = symbolExists && zrUtil.clone(symbolExists) || (isCategory ? "roundRect" : [ "roundRect" ])), 
                        null == visuals.symbolSize && (visuals.symbolSize = symbolSizeExists && zrUtil.clone(symbolSizeExists) || (isCategory ? itemSize[0] : [ itemSize[0], itemSize[0] ])), 
                        visuals.symbol = mapVisual(visuals.symbol, function(symbol) {
                            return "none" === symbol || "square" === symbol ? "roundRect" : symbol;
                        });
                        var symbolSize = visuals.symbolSize;
                        if (null != symbolSize) {
                            var max = -1 / 0;
                            eachVisual(symbolSize, function(value) {
                                value > max && (max = value);
                            }), visuals.symbolSize = mapVisual(symbolSize, function(value) {
                                return linearMap(value, [ 0, max ], [ 0, itemSize[0] ], !0);
                            });
                        }
                    }, this);
                }.call(this, controller);
            },
            resetItemSize: function() {
                this.itemSize = [ parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight")) ];
            },
            isCategory: function() {
                return !!this.option.categories;
            },
            setSelected: noop,
            getValueState: noop,
            getVisualMeta: noop
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), visualDefault = {
            get: function(visualType, key, isCategory) {
                var value = zrUtil.clone((defaultOption[visualType] || {})[key]);
                return isCategory && zrUtil.isArray(value) ? value[value.length - 1] : value;
            }
        }, defaultOption = {
            color: {
                active: [ "#006edd", "#e0ffff" ],
                inactive: [ "rgba(0,0,0,0)" ]
            },
            colorHue: {
                active: [ 0, 360 ],
                inactive: [ 0, 0 ]
            },
            colorSaturation: {
                active: [ .3, 1 ],
                inactive: [ 0, 0 ]
            },
            colorLightness: {
                active: [ .9, .5 ],
                inactive: [ 0, 0 ]
            },
            colorAlpha: {
                active: [ .3, 1 ],
                inactive: [ 0, 0 ]
            },
            opacity: {
                active: [ .3, 1 ],
                inactive: [ 0, 0 ]
            },
            symbol: {
                active: [ "circle", "roundRect", "diamond" ],
                inactive: [ "none" ]
            },
            symbolSize: {
                active: [ 10, 50 ],
                inactive: [ 0, 0 ]
            }
        }, _default = visualDefault;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var echarts = __webpack_require__(1), zrUtil = __webpack_require__(0), graphic = __webpack_require__(2), formatUtil = __webpack_require__(9), layout = __webpack_require__(10), VisualMapping = __webpack_require__(34), _default = echarts.extendComponentView({
            type: "visualMap",
            autoPositionValues: {
                left: 1,
                right: 1,
                top: 1,
                bottom: 1
            },
            init: function(ecModel, api) {
                this.ecModel = ecModel, this.api = api, this.visualMapModel;
            },
            render: function(visualMapModel, ecModel, api, payload) {
                this.visualMapModel = visualMapModel, !1 !== visualMapModel.get("show") ? this.doRender.apply(this, arguments) : this.group.removeAll();
            },
            renderBackground: function(group) {
                var visualMapModel = this.visualMapModel, padding = formatUtil.normalizeCssArray(visualMapModel.get("padding") || 0), rect = group.getBoundingRect();
                group.add(new graphic.Rect({
                    z2: -1,
                    silent: !0,
                    shape: {
                        x: rect.x - padding[3],
                        y: rect.y - padding[0],
                        width: rect.width + padding[3] + padding[1],
                        height: rect.height + padding[0] + padding[2]
                    },
                    style: {
                        fill: visualMapModel.get("backgroundColor"),
                        stroke: visualMapModel.get("borderColor"),
                        lineWidth: visualMapModel.get("borderWidth")
                    }
                }));
            },
            getControllerVisual: function(targetValue, visualCluster, opts) {
                var forceState = (opts = opts || {}).forceState, visualMapModel = this.visualMapModel, visualObj = {};
                if ("symbol" === visualCluster && (visualObj.symbol = visualMapModel.get("itemSymbol")), 
                "color" === visualCluster) {
                    var defaultColor = visualMapModel.get("contentColor");
                    visualObj.color = defaultColor;
                }
                function getter(key) {
                    return visualObj[key];
                }
                function setter(key, value) {
                    visualObj[key] = value;
                }
                var mappings = visualMapModel.controllerVisuals[forceState || visualMapModel.getValueState(targetValue)], visualTypes = VisualMapping.prepareVisualTypes(mappings);
                return zrUtil.each(visualTypes, function(type) {
                    var visualMapping = mappings[type];
                    opts.convertOpacityToAlpha && "opacity" === type && (type = "colorAlpha", visualMapping = mappings.__alphaForOpacity), 
                    VisualMapping.dependsOn(type, visualCluster) && visualMapping && visualMapping.applyVisual(targetValue, getter, setter);
                }), visualObj[visualCluster];
            },
            positionGroup: function(group) {
                var model = this.visualMapModel, api = this.api;
                layout.positionElement(group, model.getBoxLayoutParams(), {
                    width: api.getWidth(),
                    height: api.getHeight()
                });
            },
            doRender: zrUtil.noop
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), getLayoutRect = __webpack_require__(10).getLayoutRect;
        exports.getItemAlign = function(visualMapModel, api, itemSize) {
            var modelOption = visualMapModel.option, itemAlign = modelOption.align;
            if (null != itemAlign && "auto" !== itemAlign) return itemAlign;
            for (var ecSize = {
                width: api.getWidth(),
                height: api.getHeight()
            }, realIndex = "horizontal" === modelOption.orient ? 1 : 0, paramsSet = [ [ "left", "right", "width" ], [ "top", "bottom", "height" ] ], reals = paramsSet[realIndex], fakeValue = [ 0, null, 10 ], layoutInput = {}, i = 0; i < 3; i++) layoutInput[paramsSet[1 - realIndex][i]] = fakeValue[i], 
            layoutInput[reals[i]] = 2 === i ? itemSize[0] : modelOption[reals[i]];
            var rParam = [ [ "x", "width", 3 ], [ "y", "height", 0 ] ][realIndex], rect = getLayoutRect(layoutInput, ecSize, modelOption.padding);
            return reals[(rect.margin[rParam[2]] || 0) + rect[rParam[0]] + .5 * rect[rParam[1]] < .5 * ecSize[rParam[1]] ? 0 : 1];
        }, exports.makeHighDownBatch = function(batch, visualMapModel) {
            return zrUtil.each(batch || [], function(batchItem) {
                null != batchItem.dataIndex && (batchItem.dataIndexInside = batchItem.dataIndex, 
                batchItem.dataIndex = null), batchItem.highlightKey = "visualMap" + (visualMapModel ? visualMapModel.componentIndex : "");
            }), batch;
        };
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(1).registerAction({
            type: "selectDataRange",
            event: "dataRangeSelected",
            update: "update"
        }, function(payload, ecModel) {
            ecModel.eachComponent({
                mainType: "visualMap",
                query: payload
            }, function(model) {
                model.setSelected(payload.selected);
            });
        });
    }, function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__(152);
    }, function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _SedaScatterplot = __webpack_require__(153);
        Object.defineProperty(exports, "default", {
            enumerable: !0,
            get: function() {
                return function(obj) {
                    return obj && obj.__esModule ? obj : {
                        default: obj
                    };
                }(_SedaScatterplot).default;
            }
        });
        var _Scatterplot = __webpack_require__(76);
        Object.defineProperty(exports, "Scatterplot", {
            enumerable: !0,
            get: function() {
                return _Scatterplot.Scatterplot;
            }
        });
        var _utils = __webpack_require__(50);
        Object.defineProperty(exports, "fetchReducedPair", {
            enumerable: !0,
            get: function() {
                return _utils.fetchReducedPair;
            }
        }), Object.defineProperty(exports, "fetchScatterplotVars", {
            enumerable: !0,
            get: function() {
                return _utils.fetchScatterplotVars;
            }
        }), Object.defineProperty(exports, "getScatterplotData", {
            enumerable: !0,
            get: function() {
                return _utils.getScatterplotData;
            }
        }), Object.defineProperty(exports, "mergeDatasets", {
            enumerable: !0,
            get: function() {
                return _utils.mergeDatasets;
            }
        });
    }, function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.SedaScatterplot = void 0;
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _react = __webpack_require__(49), _react2 = _interopRequireDefault(_react), _Scatterplot2 = _interopRequireDefault(__webpack_require__(76)), _utils = __webpack_require__(50);
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        var getDataForId = function(id, data) {
            return Object.keys(data).reduce(function(acc, curr) {
                return (data[curr][id] || 0 === data[curr][id]) && (acc[curr] = data[curr][id]), 
                acc;
            }, {});
        }, getDataIndex = function(id, series) {
            return series.findIndex(function(d) {
                return d[3] === id;
            });
        }, SedaScatterplot = exports.SedaScatterplot = function(_Component) {
            function SedaScatterplot(props) {
                !function(instance, Constructor) {
                    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                }(this, SedaScatterplot);
                var _this = function(self, call) {
                    if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !call || "object" != typeof call && "function" != typeof call ? self : call;
                }(this, (SedaScatterplot.__proto__ || Object.getPrototypeOf(SedaScatterplot)).call(this, props));
                return _this._onClick = function(e) {
                    if (_this.props.onClick) {
                        var prefix = _this.props.prefix || "unprefixed", data = _this.props.data, locationData = _extends({
                            id: e.data[3]
                        }, getDataForId(e.data[3], data[prefix]));
                        _this.props.onClick && _this.props.onClick(locationData, e);
                    }
                }, _this._onReady = function(echart) {
                    _this.echart = echart;
                }, _this._onHover = function(e) {
                    if (_this.props.onHover) {
                        var prefix = _this.props.prefix || "unprefixed", data = _this.props.data, idIndex = _this.props.zVar ? 3 : 2, hoverData = e && e.data && e.data.hasOwnProperty("value") ? e.data.value : e.data, locationData = hoverData && "mouseover" === e.type ? _extends({
                            id: hoverData[idIndex]
                        }, getDataForId(hoverData[idIndex], data[prefix])) : null;
                        locationData ? (_this.props.onHover(locationData, e), _this.hoverTimeout && (clearTimeout(_this.hoverTimeout), 
                        _this.hoverTimeout = null)) : _this.hoverTimeout = setTimeout(function() {
                            _this.props.onHover(null, e);
                        }, 200);
                    }
                }, _this._onMouseMove = function(e) {
                    _this.props.onMouseMove && _this.props.onMouseMove(e);
                }, _this.loaded = !1, _this.hoverTimeout = null, _this.state = {
                    hovered: !1
                }, _this;
            }
            return function(subClass, superClass) {
                if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
            }(SedaScatterplot, _react.Component), _createClass(SedaScatterplot, [ {
                key: "componentDidMount",
                value: function() {
                    this._loadScatterplotData();
                }
            }, {
                key: "componentDidUpdate",
                value: function(prevProps) {
                    var _props = this.props, prefix = _props.prefix, xVar = _props.xVar, yVar = _props.yVar, zVar = _props.zVar, hovered = _props.hovered, stateFips = _props.stateFips;
                    this.isDataReady() ? (this.echart && !this.ready && (this.ready = !0, this.props.onReady && this.props.onReady(this.echart)), 
                    this.loaded || this._setLoaded(!0)) : this.loaded && this._setLoaded(!1), ("schools" !== prefix || prevProps.xVar === xVar && prevProps.yVar === yVar && prevProps.stateFips === stateFips) && prevProps.prefix === prefix && prevProps.xVar === xVar && prevProps.zVar === zVar && prevProps.yVar === yVar || this._loadScatterplotData(), 
                    this.props.freeze || (prevProps.hovered !== hovered && prevProps.hovered && this._toggleHighlight(prevProps.hovered, {
                        show: !1
                    }), prevProps.hovered !== hovered && hovered && !this.state.hovered && this._toggleHighlight(hovered, {
                        show: !0
                    }));
                }
            }, {
                key: "getData",
                value: function() {
                    return this.props.data && this.props.data[this.props.prefix] ? this.props.data[this.props.prefix] : {};
                }
            }, {
                key: "getDataSeries",
                value: function() {
                    var id = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "meta", options = this.getOption();
                    return options.series && options.series.length ? options.series.find(function(s) {
                        return s.id === id;
                    }) : null;
                }
            }, {
                key: "getOption",
                value: function() {
                    return this.echart ? this.echart.getOption() : {};
                }
            }, {
                key: "setOption",
                value: function() {
                    return this.echart && this.echart.apply(this, arguments);
                }
            }, {
                key: "getOptionOverrides",
                value: function() {
                    return this.scatterplot && this.scatterplot.getOptionOverrides();
                }
            }, {
                key: "isDataReady",
                value: function() {
                    var _props2 = this.props, xVar = _props2.xVar, yVar = _props2.yVar, zVar = _props2.zVar, prefix = _props2.prefix, data = this.props.data[prefix] || {};
                    return Boolean(data[xVar]) && Boolean(data[yVar]) && Boolean(!zVar || data[zVar]);
                }
            }, {
                key: "_setData",
                value: function(data, prefix) {
                    prefix = prefix || "unprefixed", this.props.onData && this.props.onData(data, prefix);
                }
            }, {
                key: "_setLoaded",
                value: function(loaded) {
                    this.loaded = loaded, this.props.onLoading && this.props.onLoading(!loaded);
                }
            }, {
                key: "_loadScatterplotData",
                value: function() {
                    var _props3 = this.props, xVar = _props3.xVar, yVar = _props3.yVar, zVar = _props3.zVar, prefix = _props3.prefix, stateFips = _props3.stateFips;
                    if ("schools" === prefix && !stateFips) return this._fetchSchoolPair(xVar, yVar);
                    var data = this.props.data[prefix] || {}, vars = [];
                    return zVar && (!data || !data[zVar]) && vars.push(zVar), xVar && (!data || !data[xVar]) && vars.push(xVar), 
                    yVar && (!data || !data[yVar]) && vars.push(yVar), 0 !== vars.length || "schools" === prefix ? this._fetchVariables(vars) : void 0;
                }
            }, {
                key: "_fetchVariables",
                value: function(vars) {
                    var _this2 = this, _props4 = this.props, prefix = _props4.prefix, endpoint = _props4.endpoint, metaVars = _props4.metaVars, stateFips = _props4.stateFips;
                    if (!endpoint) throw new Error("No endpoint specified for scatterplot");
                    var collectionVars = metaVars && metaVars[prefix] || [];
                    return (0, _utils.fetchScatterplotVars)(vars, prefix, endpoint, collectionVars, stateFips).then(function(data) {
                        return _this2._setData(data, prefix), data;
                    }).catch(function(err) {
                        console.error(err), _this2.props.onError && _this2.props.onError(err);
                    });
                }
            }, {
                key: "_fetchSchoolPair",
                value: function(xVar, yVar) {
                    var _this3 = this, endpoint = this.props.endpoint;
                    if (!endpoint) throw new Error("No endpoint specified for scatterplot");
                    return (0, _utils.fetchReducedPair)(endpoint, xVar, yVar).then(function(data) {
                        return _this3._setData(data, "schools"), data;
                    }).catch(function(err) {
                        console.error(err), _this3.props.onError && _this3.props.onError(err);
                    });
                }
            }, {
                key: "_getIndiciesForId",
                value: function(id) {
                    for (var series = this.echart.getOption().series, i = series.length - 1; i > -1; i--) if (series[i] && series[i].data) {
                        var dataIndex = getDataIndex(id, series[i].data);
                        if (dataIndex > -1) return {
                            seriesIndex: i,
                            dataIndex: dataIndex
                        };
                    }
                    return {
                        seriesIndex: -1,
                        dataIndex: -1
                    };
                }
            }, {
                key: "_toggleHighlight",
                value: function(hoveredId, _ref) {
                    var _ref$show = _ref.show, show = void 0 === _ref$show || _ref$show, _getIndiciesForId2 = this._getIndiciesForId(hoveredId), seriesIndex = _getIndiciesForId2.seriesIndex, dataIndex = _getIndiciesForId2.dataIndex;
                    seriesIndex > -1 && dataIndex > -1 ? this.echart && this.echart.dispatchAction({
                        type: show ? "highlight" : "downplay",
                        seriesIndex: seriesIndex,
                        dataIndex: dataIndex
                    }) : console.warn("no id to toggle highlight", hoveredId);
                }
            }, {
                key: "render",
                value: function() {
                    var _this4 = this, data = this.isDataReady() ? this.props.data[this.props.prefix ? this.props.prefix : "unprefixed"] : null;
                    return _react2.default.createElement(_Scatterplot2.default, {
                        ref: function(_ref2) {
                            return _this4.scatterplot = _ref2;
                        },
                        onReady: this._onReady,
                        onHover: this._onHover,
                        onMouseEnter: function() {
                            _this4.setState({
                                hovered: !0
                            });
                        },
                        onMouseLeave: function() {
                            _this4.setState({
                                hovered: !1
                            });
                        },
                        onMouseMove: this._onMouseMove,
                        onClick: this._onClick,
                        data: data,
                        xVar: this.props.xVar,
                        yVar: this.props.yVar,
                        zVar: this.props.zVar,
                        selected: this.props.selected,
                        highlighted: this.props.highlighted,
                        options: this.props.options,
                        notMerge: this.props.notMerge,
                        theme: this.props.theme,
                        loading: !this.isDataReady(),
                        freeze: this.props.freeze
                    });
                }
            } ]), SedaScatterplot;
        }();
        exports.default = SedaScatterplot;
    }, function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__(155);
    }, function(module, exports, __webpack_require__) {
        "use strict";
        var utils = __webpack_require__(11), bind = __webpack_require__(77), Axios = __webpack_require__(157), defaults = __webpack_require__(51);
        function createInstance(defaultConfig) {
            var context = new Axios(defaultConfig), instance = bind(Axios.prototype.request, context);
            return utils.extend(instance, Axios.prototype, context), utils.extend(instance, context), 
            instance;
        }
        var axios = createInstance(defaults);
        axios.Axios = Axios, axios.create = function(instanceConfig) {
            return createInstance(utils.merge(defaults, instanceConfig));
        }, axios.Cancel = __webpack_require__(81), axios.CancelToken = __webpack_require__(171), 
        axios.isCancel = __webpack_require__(80), axios.all = function(promises) {
            return Promise.all(promises);
        }, axios.spread = __webpack_require__(172), module.exports = axios, module.exports.default = axios;
    }, function(module, exports) {
        module.exports = function(obj) {
            return null != obj && null != obj.constructor && "function" == typeof obj.constructor.isBuffer && obj.constructor.isBuffer(obj);
        };
    }, function(module, exports, __webpack_require__) {
        "use strict";
        var defaults = __webpack_require__(51), utils = __webpack_require__(11), InterceptorManager = __webpack_require__(166), dispatchRequest = __webpack_require__(167);
        function Axios(instanceConfig) {
            this.defaults = instanceConfig, this.interceptors = {
                request: new InterceptorManager(),
                response: new InterceptorManager()
            };
        }
        Axios.prototype.request = function(config) {
            "string" == typeof config && (config = utils.merge({
                url: arguments[0]
            }, arguments[1])), (config = utils.merge(defaults, {
                method: "get"
            }, this.defaults, config)).method = config.method.toLowerCase();
            var chain = [ dispatchRequest, void 0 ], promise = Promise.resolve(config);
            for (this.interceptors.request.forEach(function(interceptor) {
                chain.unshift(interceptor.fulfilled, interceptor.rejected);
            }), this.interceptors.response.forEach(function(interceptor) {
                chain.push(interceptor.fulfilled, interceptor.rejected);
            }); chain.length; ) promise = promise.then(chain.shift(), chain.shift());
            return promise;
        }, utils.forEach([ "delete", "get", "head", "options" ], function(method) {
            Axios.prototype[method] = function(url, config) {
                return this.request(utils.merge(config || {}, {
                    method: method,
                    url: url
                }));
            };
        }), utils.forEach([ "post", "put", "patch" ], function(method) {
            Axios.prototype[method] = function(url, data, config) {
                return this.request(utils.merge(config || {}, {
                    method: method,
                    url: url,
                    data: data
                }));
            };
        }), module.exports = Axios;
    }, function(module, exports) {
        var cachedSetTimeout, cachedClearTimeout, process = module.exports = {};
        function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
        }
        function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) return setTimeout(fun, 0);
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) return cachedSetTimeout = setTimeout, 
            setTimeout(fun, 0);
            try {
                return cachedSetTimeout(fun, 0);
            } catch (e) {
                try {
                    return cachedSetTimeout.call(null, fun, 0);
                } catch (e) {
                    return cachedSetTimeout.call(this, fun, 0);
                }
            }
        }
        !function() {
            try {
                cachedSetTimeout = "function" == typeof setTimeout ? setTimeout : defaultSetTimout;
            } catch (e) {
                cachedSetTimeout = defaultSetTimout;
            }
            try {
                cachedClearTimeout = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout;
            } catch (e) {
                cachedClearTimeout = defaultClearTimeout;
            }
        }();
        var currentQueue, queue = [], draining = !1, queueIndex = -1;
        function cleanUpNextTick() {
            draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, 
            queue.length && drainQueue());
        }
        function drainQueue() {
            if (!draining) {
                var timeout = runTimeout(cleanUpNextTick);
                draining = !0;
                for (var len = queue.length; len; ) {
                    for (currentQueue = queue, queue = []; ++queueIndex < len; ) currentQueue && currentQueue[queueIndex].run();
                    queueIndex = -1, len = queue.length;
                }
                currentQueue = null, draining = !1, function(marker) {
                    if (cachedClearTimeout === clearTimeout) return clearTimeout(marker);
                    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) return cachedClearTimeout = clearTimeout, 
                    clearTimeout(marker);
                    try {
                        cachedClearTimeout(marker);
                    } catch (e) {
                        try {
                            return cachedClearTimeout.call(null, marker);
                        } catch (e) {
                            return cachedClearTimeout.call(this, marker);
                        }
                    }
                }(timeout);
            }
        }
        function Item(fun, array) {
            this.fun = fun, this.array = array;
        }
        function noop() {}
        process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) args[i - 1] = arguments[i];
            queue.push(new Item(fun, args)), 1 !== queue.length || draining || runTimeout(drainQueue);
        }, Item.prototype.run = function() {
            this.fun.apply(null, this.array);
        }, process.title = "browser", process.browser = !0, process.env = {}, process.argv = [], 
        process.version = "", process.versions = {}, process.on = noop, process.addListener = noop, 
        process.once = noop, process.off = noop, process.removeListener = noop, process.removeAllListeners = noop, 
        process.emit = noop, process.prependListener = noop, process.prependOnceListener = noop, 
        process.listeners = function(name) {
            return [];
        }, process.binding = function(name) {
            throw new Error("process.binding is not supported");
        }, process.cwd = function() {
            return "/";
        }, process.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
        }, process.umask = function() {
            return 0;
        };
    }, function(module, exports, __webpack_require__) {
        "use strict";
        var utils = __webpack_require__(11);
        module.exports = function(headers, normalizedName) {
            utils.forEach(headers, function(value, name) {
                name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase() && (headers[normalizedName] = value, 
                delete headers[name]);
            });
        };
    }, function(module, exports, __webpack_require__) {
        "use strict";
        var createError = __webpack_require__(79);
        module.exports = function(resolve, reject, response) {
            var validateStatus = response.config.validateStatus;
            response.status && validateStatus && !validateStatus(response.status) ? reject(createError("Request failed with status code " + response.status, response.config, null, response.request, response)) : resolve(response);
        };
    }, function(module, exports, __webpack_require__) {
        "use strict";
        module.exports = function(error, config, code, request, response) {
            return error.config = config, code && (error.code = code), error.request = request, 
            error.response = response, error;
        };
    }, function(module, exports, __webpack_require__) {
        "use strict";
        var utils = __webpack_require__(11);
        function encode(val) {
            return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
        }
        module.exports = function(url, params, paramsSerializer) {
            if (!params) return url;
            var serializedParams;
            if (paramsSerializer) serializedParams = paramsSerializer(params); else if (utils.isURLSearchParams(params)) serializedParams = params.toString(); else {
                var parts = [];
                utils.forEach(params, function(val, key) {
                    null !== val && void 0 !== val && (utils.isArray(val) ? key += "[]" : val = [ val ], 
                    utils.forEach(val, function(v) {
                        utils.isDate(v) ? v = v.toISOString() : utils.isObject(v) && (v = JSON.stringify(v)), 
                        parts.push(encode(key) + "=" + encode(v));
                    }));
                }), serializedParams = parts.join("&");
            }
            return serializedParams && (url += (-1 === url.indexOf("?") ? "?" : "&") + serializedParams), 
            url;
        };
    }, function(module, exports, __webpack_require__) {
        "use strict";
        var utils = __webpack_require__(11), ignoreDuplicateOf = [ "age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent" ];
        module.exports = function(headers) {
            var key, val, i, parsed = {};
            return headers ? (utils.forEach(headers.split("\n"), function(line) {
                if (i = line.indexOf(":"), key = utils.trim(line.substr(0, i)).toLowerCase(), val = utils.trim(line.substr(i + 1)), 
                key) {
                    if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) return;
                    parsed[key] = "set-cookie" === key ? (parsed[key] ? parsed[key] : []).concat([ val ]) : parsed[key] ? parsed[key] + ", " + val : val;
                }
            }), parsed) : parsed;
        };
    }, function(module, exports, __webpack_require__) {
        "use strict";
        var utils = __webpack_require__(11);
        module.exports = utils.isStandardBrowserEnv() ? function() {
            var originURL, msie = /(msie|trident)/i.test(navigator.userAgent), urlParsingNode = document.createElement("a");
            function resolveURL(url) {
                var href = url;
                return msie && (urlParsingNode.setAttribute("href", href), href = urlParsingNode.href), 
                urlParsingNode.setAttribute("href", href), {
                    href: urlParsingNode.href,
                    protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
                    host: urlParsingNode.host,
                    search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
                    hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
                    hostname: urlParsingNode.hostname,
                    port: urlParsingNode.port,
                    pathname: "/" === urlParsingNode.pathname.charAt(0) ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
                };
            }
            return originURL = resolveURL(window.location.href), function(requestURL) {
                var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
                return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
            };
        }() : function() {
            return !0;
        };
    }, function(module, exports, __webpack_require__) {
        "use strict";
        var utils = __webpack_require__(11);
        module.exports = utils.isStandardBrowserEnv() ? {
            write: function(name, value, expires, path, domain, secure) {
                var cookie = [];
                cookie.push(name + "=" + encodeURIComponent(value)), utils.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString()), 
                utils.isString(path) && cookie.push("path=" + path), utils.isString(domain) && cookie.push("domain=" + domain), 
                !0 === secure && cookie.push("secure"), document.cookie = cookie.join("; ");
            },
            read: function(name) {
                var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
                return match ? decodeURIComponent(match[3]) : null;
            },
            remove: function(name) {
                this.write(name, "", Date.now() - 864e5);
            }
        } : {
            write: function() {},
            read: function() {
                return null;
            },
            remove: function() {}
        };
    }, function(module, exports, __webpack_require__) {
        "use strict";
        var utils = __webpack_require__(11);
        function InterceptorManager() {
            this.handlers = [];
        }
        InterceptorManager.prototype.use = function(fulfilled, rejected) {
            return this.handlers.push({
                fulfilled: fulfilled,
                rejected: rejected
            }), this.handlers.length - 1;
        }, InterceptorManager.prototype.eject = function(id) {
            this.handlers[id] && (this.handlers[id] = null);
        }, InterceptorManager.prototype.forEach = function(fn) {
            utils.forEach(this.handlers, function(h) {
                null !== h && fn(h);
            });
        }, module.exports = InterceptorManager;
    }, function(module, exports, __webpack_require__) {
        "use strict";
        var utils = __webpack_require__(11), transformData = __webpack_require__(168), isCancel = __webpack_require__(80), defaults = __webpack_require__(51), isAbsoluteURL = __webpack_require__(169), combineURLs = __webpack_require__(170);
        function throwIfCancellationRequested(config) {
            config.cancelToken && config.cancelToken.throwIfRequested();
        }
        module.exports = function(config) {
            return throwIfCancellationRequested(config), config.baseURL && !isAbsoluteURL(config.url) && (config.url = combineURLs(config.baseURL, config.url)), 
            config.headers = config.headers || {}, config.data = transformData(config.data, config.headers, config.transformRequest), 
            config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers || {}), 
            utils.forEach([ "delete", "get", "head", "post", "put", "patch", "common" ], function(method) {
                delete config.headers[method];
            }), (config.adapter || defaults.adapter)(config).then(function(response) {
                return throwIfCancellationRequested(config), response.data = transformData(response.data, response.headers, config.transformResponse), 
                response;
            }, function(reason) {
                return isCancel(reason) || (throwIfCancellationRequested(config), reason && reason.response && (reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse))), 
                Promise.reject(reason);
            });
        };
    }, function(module, exports, __webpack_require__) {
        "use strict";
        var utils = __webpack_require__(11);
        module.exports = function(data, headers, fns) {
            return utils.forEach(fns, function(fn) {
                data = fn(data, headers);
            }), data;
        };
    }, function(module, exports, __webpack_require__) {
        "use strict";
        module.exports = function(url) {
            return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
        };
    }, function(module, exports, __webpack_require__) {
        "use strict";
        module.exports = function(baseURL, relativeURL) {
            return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
        };
    }, function(module, exports, __webpack_require__) {
        "use strict";
        var Cancel = __webpack_require__(81);
        function CancelToken(executor) {
            if ("function" != typeof executor) throw new TypeError("executor must be a function.");
            var resolvePromise;
            this.promise = new Promise(function(resolve) {
                resolvePromise = resolve;
            });
            var token = this;
            executor(function(message) {
                token.reason || (token.reason = new Cancel(message), resolvePromise(token.reason));
            });
        }
        CancelToken.prototype.throwIfRequested = function() {
            if (this.reason) throw this.reason;
        }, CancelToken.source = function() {
            var cancel;
            return {
                token: new CancelToken(function(c) {
                    cancel = c;
                }),
                cancel: cancel
            };
        }, module.exports = CancelToken;
    }, function(module, exports, __webpack_require__) {
        "use strict";
        module.exports = function(callback) {
            return function(arr) {
                return callback.apply(null, arr);
            };
        };
    }, function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
        Array.isArray || (Array.isArray = function(e) {
            return "[object Array]" === Object.prototype.toString.call(e);
        }), __WEBPACK_AMD_DEFINE_ARRAY__ = [], void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = function() {
            "use strict";
            var s, e, f = "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== f ? f : {}, n = !f.document && !!f.postMessage, o = n && /(\?|&)papaworker(=|&|$)/.test(f.location.search), a = !1, h = {}, u = 0, k = {
                parse: function(e, t) {
                    var r = (t = t || {}).dynamicTyping || !1;
                    if (z(r) && (t.dynamicTypingFunction = r, r = {}), t.dynamicTyping = r, t.transform = !!z(t.transform) && t.transform, 
                    t.worker && k.WORKERS_SUPPORTED) {
                        var i = function() {
                            if (!k.WORKERS_SUPPORTED) return !1;
                            if (!a && null === k.SCRIPT_PATH) throw new Error("Script path cannot be determined automatically when Papa Parse is loaded asynchronously. You need to set Papa.SCRIPT_PATH manually.");
                            var e = k.SCRIPT_PATH || s;
                            e += (-1 !== e.indexOf("?") ? "&" : "?") + "papaworker";
                            var t = new f.Worker(e);
                            return t.onmessage = m, t.id = u++, h[t.id] = t;
                        }();
                        return i.userStep = t.step, i.userChunk = t.chunk, i.userComplete = t.complete, 
                        i.userError = t.error, t.step = z(t.step), t.chunk = z(t.chunk), t.complete = z(t.complete), 
                        t.error = z(t.error), delete t.worker, void i.postMessage({
                            input: e,
                            config: t,
                            workerId: i.id
                        });
                    }
                    var n = null;
                    return k.NODE_STREAM_INPUT, "string" == typeof e ? n = t.download ? new c(t) : new _(t) : !0 === e.readable && z(e.read) && z(e.on) ? n = new g(t) : (f.File && e instanceof File || e instanceof Object) && (n = new p(t)), 
                    n.stream(e);
                },
                unparse: function(e, t) {
                    var i = !1, g = !0, m = ",", y = "\r\n", n = '"', r = !1;
                    "object" == typeof t && ("string" != typeof t.delimiter || k.BAD_DELIMITERS.filter(function(e) {
                        return -1 !== t.delimiter.indexOf(e);
                    }).length || (m = t.delimiter), ("boolean" == typeof t.quotes || Array.isArray(t.quotes)) && (i = t.quotes), 
                    "boolean" != typeof t.skipEmptyLines && "string" != typeof t.skipEmptyLines || (r = t.skipEmptyLines), 
                    "string" == typeof t.newline && (y = t.newline), "string" == typeof t.quoteChar && (n = t.quoteChar), 
                    "boolean" == typeof t.header && (g = t.header));
                    var s = new RegExp(M(n), "g");
                    if ("string" == typeof e && (e = JSON.parse(e)), Array.isArray(e)) {
                        if (!e.length || Array.isArray(e[0])) return o(null, e, r);
                        if ("object" == typeof e[0]) return o(a(e[0]), e, r);
                    } else if ("object" == typeof e) return "string" == typeof e.data && (e.data = JSON.parse(e.data)), 
                    Array.isArray(e.data) && (e.fields || (e.fields = e.meta && e.meta.fields), e.fields || (e.fields = Array.isArray(e.data[0]) ? e.fields : a(e.data[0])), 
                    Array.isArray(e.data[0]) || "object" == typeof e.data[0] || (e.data = [ e.data ])), 
                    o(e.fields || [], e.data || [], r);
                    throw "exception: Unable to serialize unrecognized input";
                    function a(e) {
                        if ("object" != typeof e) return [];
                        var t = [];
                        for (var r in e) t.push(r);
                        return t;
                    }
                    function o(e, t, r) {
                        var i = "";
                        "string" == typeof e && (e = JSON.parse(e)), "string" == typeof t && (t = JSON.parse(t));
                        var n = Array.isArray(e) && 0 < e.length, s = !Array.isArray(t[0]);
                        if (n && g) {
                            for (var a = 0; a < e.length; a++) 0 < a && (i += m), i += v(e[a], a);
                            0 < t.length && (i += y);
                        }
                        for (var o = 0; o < t.length; o++) {
                            var h = n ? e.length : t[o].length, u = !1, f = n ? 0 === Object.keys(t[o]).length : 0 === t[o].length;
                            if (r && !n && (u = "greedy" === r ? "" === t[o].join("").trim() : 1 === t[o].length && 0 === t[o][0].length), 
                            "greedy" === r && n) {
                                for (var d = [], l = 0; l < h; l++) {
                                    var c = s ? e[l] : l;
                                    d.push(t[o][c]);
                                }
                                u = "" === d.join("").trim();
                            }
                            if (!u) {
                                for (var p = 0; p < h; p++) {
                                    0 < p && !f && (i += m);
                                    var _ = n && s ? e[p] : p;
                                    i += v(t[o][_], p);
                                }
                                o < t.length - 1 && (!r || 0 < h && !f) && (i += y);
                            }
                        }
                        return i;
                    }
                    function v(e, t) {
                        if (null == e) return "";
                        if (e.constructor === Date) return JSON.stringify(e).slice(1, 25);
                        e = e.toString().replace(s, n + n);
                        var r = "boolean" == typeof i && i || Array.isArray(i) && i[t] || function(e, t) {
                            for (var r = 0; r < t.length; r++) if (-1 < e.indexOf(t[r])) return !0;
                            return !1;
                        }(e, k.BAD_DELIMITERS) || -1 < e.indexOf(m) || " " === e.charAt(0) || " " === e.charAt(e.length - 1);
                        return r ? n + e + n : e;
                    }
                }
            };
            if (k.RECORD_SEP = String.fromCharCode(30), k.UNIT_SEP = String.fromCharCode(31), 
            k.BYTE_ORDER_MARK = "\ufeff", k.BAD_DELIMITERS = [ "\r", "\n", '"', k.BYTE_ORDER_MARK ], 
            k.WORKERS_SUPPORTED = !n && !!f.Worker, k.SCRIPT_PATH = null, k.NODE_STREAM_INPUT = 1, 
            k.LocalChunkSize = 10485760, k.RemoteChunkSize = 5242880, k.DefaultDelimiter = ",", 
            k.Parser = v, k.ParserHandle = r, k.NetworkStreamer = c, k.FileStreamer = p, k.StringStreamer = _, 
            k.ReadableStreamStreamer = g, f.jQuery) {
                var d = f.jQuery;
                d.fn.parse = function(o) {
                    var r = o.config || {}, h = [];
                    return this.each(function(e) {
                        if ("INPUT" !== d(this).prop("tagName").toUpperCase() || "file" !== d(this).attr("type").toLowerCase() || !f.FileReader || !this.files || 0 === this.files.length) return !0;
                        for (var t = 0; t < this.files.length; t++) h.push({
                            file: this.files[t],
                            inputElem: this,
                            instanceConfig: d.extend({}, r)
                        });
                    }), e(), this;
                    function e() {
                        if (0 !== h.length) {
                            var e, t, r, i, n = h[0];
                            if (z(o.before)) {
                                var s = o.before(n.file, n.inputElem);
                                if ("object" == typeof s) {
                                    if ("abort" === s.action) return e = "AbortError", t = n.file, r = n.inputElem, 
                                    i = s.reason, void (z(o.error) && o.error({
                                        name: e
                                    }, t, r, i));
                                    if ("skip" === s.action) return void u();
                                    "object" == typeof s.config && (n.instanceConfig = d.extend(n.instanceConfig, s.config));
                                } else if ("skip" === s) return void u();
                            }
                            var a = n.instanceConfig.complete;
                            n.instanceConfig.complete = function(e) {
                                z(a) && a(e, n.file, n.inputElem), u();
                            }, k.parse(n.file, n.instanceConfig);
                        } else z(o.complete) && o.complete();
                    }
                    function u() {
                        h.splice(0, 1), e();
                    }
                };
            }
            function l(e) {
                this._handle = null, this._finished = !1, this._completed = !1, this._input = null, 
                this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, this._start = 0, 
                this._nextChunk = null, this.isFirstChunk = !0, this._completeResults = {
                    data: [],
                    errors: [],
                    meta: {}
                }, function(e) {
                    var t = E(e);
                    t.chunkSize = parseInt(t.chunkSize), e.step || e.chunk || (t.chunkSize = null), 
                    this._handle = new r(t), (this._handle.streamer = this)._config = t;
                }.call(this, e), this.parseChunk = function(e, t) {
                    if (this.isFirstChunk && z(this._config.beforeFirstChunk)) {
                        var r = this._config.beforeFirstChunk(e);
                        void 0 !== r && (e = r);
                    }
                    this.isFirstChunk = !1;
                    var i = this._partialLine + e;
                    this._partialLine = "";
                    var n = this._handle.parse(i, this._baseIndex, !this._finished);
                    if (!this._handle.paused() && !this._handle.aborted()) {
                        var s = n.meta.cursor;
                        this._finished || (this._partialLine = i.substring(s - this._baseIndex), this._baseIndex = s), 
                        n && n.data && (this._rowCount += n.data.length);
                        var a = this._finished || this._config.preview && this._rowCount >= this._config.preview;
                        if (o) f.postMessage({
                            results: n,
                            workerId: k.WORKER_ID,
                            finished: a
                        }); else if (z(this._config.chunk) && !t) {
                            if (this._config.chunk(n, this._handle), this._handle.paused() || this._handle.aborted()) return;
                            n = void 0, this._completeResults = void 0;
                        }
                        return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(n.data), 
                        this._completeResults.errors = this._completeResults.errors.concat(n.errors), this._completeResults.meta = n.meta), 
                        this._completed || !a || !z(this._config.complete) || n && n.meta.aborted || (this._config.complete(this._completeResults, this._input), 
                        this._completed = !0), a || n && n.meta.paused || this._nextChunk(), n;
                    }
                }, this._sendError = function(e) {
                    z(this._config.error) ? this._config.error(e) : o && this._config.error && f.postMessage({
                        workerId: k.WORKER_ID,
                        error: e,
                        finished: !1
                    });
                };
            }
            function c(e) {
                var i;
                (e = e || {}).chunkSize || (e.chunkSize = k.RemoteChunkSize), l.call(this, e), this._nextChunk = n ? function() {
                    this._readChunk(), this._chunkLoaded();
                } : function() {
                    this._readChunk();
                }, this.stream = function(e) {
                    this._input = e, this._nextChunk();
                }, this._readChunk = function() {
                    if (this._finished) this._chunkLoaded(); else {
                        if (i = new XMLHttpRequest(), this._config.withCredentials && (i.withCredentials = this._config.withCredentials), 
                        n || (i.onload = w(this._chunkLoaded, this), i.onerror = w(this._chunkError, this)), 
                        i.open("GET", this._input, !n), this._config.downloadRequestHeaders) {
                            var e = this._config.downloadRequestHeaders;
                            for (var t in e) i.setRequestHeader(t, e[t]);
                        }
                        if (this._config.chunkSize) {
                            var r = this._start + this._config.chunkSize - 1;
                            i.setRequestHeader("Range", "bytes=" + this._start + "-" + r), i.setRequestHeader("If-None-Match", "webkit-no-cache");
                        }
                        try {
                            i.send();
                        } catch (e) {
                            this._chunkError(e.message);
                        }
                        n && 0 === i.status ? this._chunkError() : this._start += this._config.chunkSize;
                    }
                }, this._chunkLoaded = function() {
                    4 === i.readyState && (i.status < 200 || 400 <= i.status ? this._chunkError() : (this._finished = !this._config.chunkSize || this._start > function(e) {
                        var t = e.getResponseHeader("Content-Range");
                        return null === t ? -1 : parseInt(t.substr(t.lastIndexOf("/") + 1));
                    }(i), this.parseChunk(i.responseText)));
                }, this._chunkError = function(e) {
                    var t = i.statusText || e;
                    this._sendError(new Error(t));
                };
            }
            function p(e) {
                var i, n;
                (e = e || {}).chunkSize || (e.chunkSize = k.LocalChunkSize), l.call(this, e);
                var s = "undefined" != typeof FileReader;
                this.stream = function(e) {
                    this._input = e, n = e.slice || e.webkitSlice || e.mozSlice, s ? ((i = new FileReader()).onload = w(this._chunkLoaded, this), 
                    i.onerror = w(this._chunkError, this)) : i = new FileReaderSync(), this._nextChunk();
                }, this._nextChunk = function() {
                    this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
                }, this._readChunk = function() {
                    var e = this._input;
                    if (this._config.chunkSize) {
                        var t = Math.min(this._start + this._config.chunkSize, this._input.size);
                        e = n.call(e, this._start, t);
                    }
                    var r = i.readAsText(e, this._config.encoding);
                    s || this._chunkLoaded({
                        target: {
                            result: r
                        }
                    });
                }, this._chunkLoaded = function(e) {
                    this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, 
                    this.parseChunk(e.target.result);
                }, this._chunkError = function() {
                    this._sendError(i.error);
                };
            }
            function _(e) {
                var r;
                l.call(this, e = e || {}), this.stream = function(e) {
                    return r = e, this._nextChunk();
                }, this._nextChunk = function() {
                    if (!this._finished) {
                        var e = this._config.chunkSize, t = e ? r.substr(0, e) : r;
                        return r = e ? r.substr(e) : "", this._finished = !r, this.parseChunk(t);
                    }
                };
            }
            function g(e) {
                l.call(this, e = e || {});
                var t = [], r = !0, i = !1;
                this.pause = function() {
                    l.prototype.pause.apply(this, arguments), this._input.pause();
                }, this.resume = function() {
                    l.prototype.resume.apply(this, arguments), this._input.resume();
                }, this.stream = function(e) {
                    this._input = e, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), 
                    this._input.on("error", this._streamError);
                }, this._checkIsFinished = function() {
                    i && 1 === t.length && (this._finished = !0);
                }, this._nextChunk = function() {
                    this._checkIsFinished(), t.length ? this.parseChunk(t.shift()) : r = !0;
                }, this._streamData = w(function(e) {
                    try {
                        t.push("string" == typeof e ? e : e.toString(this._config.encoding)), r && (r = !1, 
                        this._checkIsFinished(), this.parseChunk(t.shift()));
                    } catch (e) {
                        this._streamError(e);
                    }
                }, this), this._streamError = w(function(e) {
                    this._streamCleanUp(), this._sendError(e);
                }, this), this._streamEnd = w(function() {
                    this._streamCleanUp(), i = !0, this._streamData("");
                }, this), this._streamCleanUp = w(function() {
                    this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), 
                    this._input.removeListener("error", this._streamError);
                }, this);
            }
            function r(g) {
                var a, o, h, i = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i, n = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/, t = this, r = 0, s = 0, u = !1, e = !1, f = [], d = {
                    data: [],
                    errors: [],
                    meta: {}
                };
                if (z(g.step)) {
                    var l = g.step;
                    g.step = function(e) {
                        if (d = e, p()) c(); else {
                            if (c(), 0 === d.data.length) return;
                            r += e.data.length, g.preview && r > g.preview ? o.abort() : l(d, t);
                        }
                    };
                }
                function m(e) {
                    return "greedy" === g.skipEmptyLines ? "" === e.join("").trim() : 1 === e.length && 0 === e[0].length;
                }
                function c() {
                    if (d && h && (y("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + k.DefaultDelimiter + "'"), 
                    h = !1), g.skipEmptyLines) for (var e = 0; e < d.data.length; e++) m(d.data[e]) && d.data.splice(e--, 1);
                    return p() && function() {
                        if (d) {
                            for (var e = 0; p() && e < d.data.length; e++) for (var t = 0; t < d.data[e].length; t++) {
                                var r = d.data[e][t];
                                g.trimHeaders && (r = r.trim()), f.push(r);
                            }
                            d.data.splice(0, 1);
                        }
                    }(), function() {
                        if (!d || !g.header && !g.dynamicTyping && !g.transform) return d;
                        for (var e = 0; e < d.data.length; e++) {
                            var t, r = g.header ? {} : [];
                            for (t = 0; t < d.data[e].length; t++) {
                                var i = t, n = d.data[e][t];
                                g.header && (i = t >= f.length ? "__parsed_extra" : f[t]), g.transform && (n = g.transform(n, i)), 
                                n = _(i, n), "__parsed_extra" === i ? (r[i] = r[i] || [], r[i].push(n)) : r[i] = n;
                            }
                            d.data[e] = r, g.header && (t > f.length ? y("FieldMismatch", "TooManyFields", "Too many fields: expected " + f.length + " fields but parsed " + t, s + e) : t < f.length && y("FieldMismatch", "TooFewFields", "Too few fields: expected " + f.length + " fields but parsed " + t, s + e));
                        }
                        return g.header && d.meta && (d.meta.fields = f), s += d.data.length, d;
                    }();
                }
                function p() {
                    return g.header && 0 === f.length;
                }
                function _(e, t) {
                    return r = e, g.dynamicTypingFunction && void 0 === g.dynamicTyping[r] && (g.dynamicTyping[r] = g.dynamicTypingFunction(r)), 
                    !0 === (g.dynamicTyping[r] || g.dynamicTyping) ? "true" === t || "TRUE" === t || "false" !== t && "FALSE" !== t && (i.test(t) ? parseFloat(t) : n.test(t) ? new Date(t) : "" === t ? null : t) : t;
                    var r;
                }
                function y(e, t, r, i) {
                    d.errors.push({
                        type: e,
                        code: t,
                        message: r,
                        row: i
                    });
                }
                this.parse = function(e, t, r) {
                    var i = g.quoteChar || '"';
                    if (g.newline || (g.newline = function(e, t) {
                        e = e.substr(0, 1048576);
                        var r = new RegExp(M(t) + "([^]*?)" + M(t), "gm"), i = (e = e.replace(r, "")).split("\r"), n = e.split("\n"), s = 1 < n.length && n[0].length < i[0].length;
                        if (1 === i.length || s) return "\n";
                        for (var a = 0, o = 0; o < i.length; o++) "\n" === i[o][0] && a++;
                        return a >= i.length / 2 ? "\r\n" : "\r";
                    }(e, i)), h = !1, g.delimiter) z(g.delimiter) && (g.delimiter = g.delimiter(e), 
                    d.meta.delimiter = g.delimiter); else {
                        var n = function(e, t, r, i) {
                            for (var n, s, a, o = [ ",", "\t", "|", ";", k.RECORD_SEP, k.UNIT_SEP ], h = 0; h < o.length; h++) {
                                var u = o[h], f = 0, d = 0, l = 0;
                                a = void 0;
                                for (var c = new v({
                                    comments: i,
                                    delimiter: u,
                                    newline: t,
                                    preview: 10
                                }).parse(e), p = 0; p < c.data.length; p++) if (r && m(c.data[p])) l++; else {
                                    var _ = c.data[p].length;
                                    d += _, void 0 !== a ? 1 < _ && (f += Math.abs(_ - a), a = _) : a = 0;
                                }
                                0 < c.data.length && (d /= c.data.length - l), (void 0 === s || s < f) && 1.99 < d && (s = f, 
                                n = u);
                            }
                            return {
                                successful: !!(g.delimiter = n),
                                bestDelimiter: n
                            };
                        }(e, g.newline, g.skipEmptyLines, g.comments);
                        n.successful ? g.delimiter = n.bestDelimiter : (h = !0, g.delimiter = k.DefaultDelimiter), 
                        d.meta.delimiter = g.delimiter;
                    }
                    var s = E(g);
                    return g.preview && g.header && s.preview++, a = e, o = new v(s), d = o.parse(a, t, r), 
                    c(), u ? {
                        meta: {
                            paused: !0
                        }
                    } : d || {
                        meta: {
                            paused: !1
                        }
                    };
                }, this.paused = function() {
                    return u;
                }, this.pause = function() {
                    u = !0, o.abort(), a = a.substr(o.getCharIndex());
                }, this.resume = function() {
                    u = !1, t.streamer.parseChunk(a, !0);
                }, this.aborted = function() {
                    return e;
                }, this.abort = function() {
                    e = !0, o.abort(), d.meta.aborted = !0, z(g.complete) && g.complete(d), a = "";
                };
            }
            function M(e) {
                return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            }
            function v(e) {
                var S, O = (e = e || {}).delimiter, x = e.newline, T = e.comments, I = e.step, A = e.preview, D = e.fastMode, L = S = void 0 === e.quoteChar ? '"' : e.quoteChar;
                if (void 0 !== e.escapeChar && (L = e.escapeChar), ("string" != typeof O || -1 < k.BAD_DELIMITERS.indexOf(O)) && (O = ","), 
                T === O) throw "Comment character same as delimiter";
                !0 === T ? T = "#" : ("string" != typeof T || -1 < k.BAD_DELIMITERS.indexOf(T)) && (T = !1), 
                "\n" !== x && "\r" !== x && "\r\n" !== x && (x = "\n");
                var P = 0, F = !1;
                this.parse = function(i, t, r) {
                    if ("string" != typeof i) throw "Input must be a string";
                    var n = i.length, e = O.length, s = x.length, a = T.length, o = z(I), h = [], u = [], f = [], d = P = 0;
                    if (!i) return C();
                    if (D || !1 !== D && -1 === i.indexOf(S)) {
                        for (var l = i.split(x), c = 0; c < l.length; c++) {
                            if (f = l[c], P += f.length, c !== l.length - 1) P += x.length; else if (r) return C();
                            if (!T || f.substr(0, a) !== T) {
                                if (o) {
                                    if (h = [], k(f.split(O)), R(), F) return C();
                                } else k(f.split(O));
                                if (A && A <= c) return h = h.slice(0, A), C(!0);
                            }
                        }
                        return C();
                    }
                    for (var p, _ = i.indexOf(O, P), g = i.indexOf(x, P), m = new RegExp(M(L) + M(S), "g"); ;) if (i[P] !== S) if (T && 0 === f.length && i.substr(P, a) === T) {
                        if (-1 === g) return C();
                        P = g + s, g = i.indexOf(x, P), _ = i.indexOf(O, P);
                    } else if (-1 !== _ && (_ < g || -1 === g)) f.push(i.substring(P, _)), P = _ + e, 
                    _ = i.indexOf(O, P); else {
                        if (-1 === g) break;
                        if (f.push(i.substring(P, g)), w(g + s), o && (R(), F)) return C();
                        if (A && h.length >= A) return C(!0);
                    } else for (p = P, P++; ;) {
                        if (-1 === (p = i.indexOf(S, p + 1))) return r || u.push({
                            type: "Quotes",
                            code: "MissingQuotes",
                            message: "Quoted field unterminated",
                            row: h.length,
                            index: P
                        }), E();
                        if (p === n - 1) return E(i.substring(P, p).replace(m, S));
                        if (S !== L || i[p + 1] !== L) {
                            if (S === L || 0 === p || i[p - 1] !== L) {
                                var y = b(-1 === g ? _ : Math.min(_, g));
                                if (i[p + 1 + y] === O) {
                                    f.push(i.substring(P, p).replace(m, S)), P = p + 1 + y + e, _ = i.indexOf(O, P), 
                                    g = i.indexOf(x, P);
                                    break;
                                }
                                var v = b(g);
                                if (i.substr(p + 1 + v, s) === x) {
                                    if (f.push(i.substring(P, p).replace(m, S)), w(p + 1 + v + s), _ = i.indexOf(O, P), 
                                    o && (R(), F)) return C();
                                    if (A && h.length >= A) return C(!0);
                                    break;
                                }
                                u.push({
                                    type: "Quotes",
                                    code: "InvalidQuotes",
                                    message: "Trailing quote on quoted field is malformed",
                                    row: h.length,
                                    index: P
                                }), p++;
                            }
                        } else p++;
                    }
                    return E();
                    function k(e) {
                        h.push(e), d = P;
                    }
                    function b(e) {
                        var t = 0;
                        if (-1 !== e) {
                            var r = i.substring(p + 1, e);
                            r && "" === r.trim() && (t = r.length);
                        }
                        return t;
                    }
                    function E(e) {
                        return r || (void 0 === e && (e = i.substr(P)), f.push(e), P = n, k(f), o && R()), 
                        C();
                    }
                    function w(e) {
                        P = e, k(f), f = [], g = i.indexOf(x, P);
                    }
                    function C(e) {
                        return {
                            data: h,
                            errors: u,
                            meta: {
                                delimiter: O,
                                linebreak: x,
                                aborted: F,
                                truncated: !!e,
                                cursor: d + (t || 0)
                            }
                        };
                    }
                    function R() {
                        I(C()), h = [], u = [];
                    }
                }, this.abort = function() {
                    F = !0;
                }, this.getCharIndex = function() {
                    return P;
                };
            }
            function m(e) {
                var t = e.data, r = h[t.workerId], i = !1;
                if (t.error) r.userError(t.error, t.file); else if (t.results && t.results.data) {
                    var n = {
                        abort: function() {
                            i = !0, y(t.workerId, {
                                data: [],
                                errors: [],
                                meta: {
                                    aborted: !0
                                }
                            });
                        },
                        pause: b,
                        resume: b
                    };
                    if (z(r.userStep)) {
                        for (var s = 0; s < t.results.data.length && (r.userStep({
                            data: [ t.results.data[s] ],
                            errors: t.results.errors,
                            meta: t.results.meta
                        }, n), !i); s++) ;
                        delete t.results;
                    } else z(r.userChunk) && (r.userChunk(t.results, n, t.file), delete t.results);
                }
                t.finished && !i && y(t.workerId, t.results);
            }
            function y(e, t) {
                var r = h[e];
                z(r.userComplete) && r.userComplete(t), r.terminate(), delete h[e];
            }
            function b() {
                throw "Not implemented.";
            }
            function E(e) {
                if ("object" != typeof e || null === e) return e;
                var t = Array.isArray(e) ? [] : {};
                for (var r in e) t[r] = E(e[r]);
                return t;
            }
            function w(e, t) {
                return function() {
                    e.apply(t, arguments);
                };
            }
            function z(e) {
                return "function" == typeof e;
            }
            return o ? f.onmessage = function(e) {
                var t = e.data;
                if (void 0 === k.WORKER_ID && t && (k.WORKER_ID = t.workerId), "string" == typeof t.input) f.postMessage({
                    workerId: k.WORKER_ID,
                    results: k.parse(t.input, t.config),
                    finished: !0
                }); else if (f.File && t.input instanceof File || t.input instanceof Object) {
                    var r = k.parse(t.input, t.config);
                    r && f.postMessage({
                        workerId: k.WORKER_ID,
                        results: r,
                        finished: !0
                    });
                }
            } : k.WORKERS_SUPPORTED && (e = document.getElementsByTagName("script"), s = e.length ? e[e.length - 1].src : "", 
            document.body ? document.addEventListener("DOMContentLoaded", function() {
                a = !0;
            }, !0) : a = !0), (c.prototype = Object.create(l.prototype)).constructor = c, (p.prototype = Object.create(l.prototype)).constructor = p, 
            (_.prototype = Object.create(_.prototype)).constructor = _, (g.prototype = Object.create(l.prototype)).constructor = g, 
            k;
        }) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
    }, function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.getScatterplotOptions = void 0;
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _lodash2 = function(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }(__webpack_require__(82));
        var gridOptions = {
            top: "24",
            right: "24",
            bottom: "24",
            left: "24"
        }, xAxisOptions = {
            type: "value",
            interval: 1,
            nameTextStyle: {
                fontSize: 14,
                fontWeight: "bold"
            },
            nameLocation: "center",
            nameGap: 16,
            splitLine: {
                show: !1
            },
            axisLine: {
                show: !1
            },
            axisTick: {
                show: !1
            }
        }, yAxisOptions = {
            type: "value",
            splitLine: {
                show: !0,
                lineStyle: {
                    type: "dashed",
                    color: [ "rgba(0,0,0,0.1)" ]
                }
            },
            axisTick: {
                show: !1
            },
            axisLine: {
                show: !1
            }
        }, visualMapOptions = {
            dimension: 1,
            calculable: !1,
            show: !1
        }, getAxisOptions = function(axisName) {
            var overrides = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return (0, _lodash2.default)({}, "x" === axisName ? xAxisOptions : yAxisOptions, overrides);
        };
        exports.getScatterplotOptions = function() {
            var overrides = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            return _extends({}, overrides, {
                grid: function() {
                    var overrides = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return (0, _lodash2.default)({}, gridOptions, overrides);
                }(overrides.grid),
                xAxis: getAxisOptions("x", overrides.xAxis),
                yAxis: getAxisOptions("y", overrides.yAxis),
                visualMap: function() {
                    return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []).map(function(vm) {
                        return (0, _lodash2.default)({}, visualMapOptions, vm);
                    });
                }(overrides.visualMap)
            });
        };
    }, function(module, exports, __webpack_require__) {
        (function(global, module) {
            var LARGE_ARRAY_SIZE = 200, HASH_UNDEFINED = "__lodash_hash_undefined__", COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2, MAX_SAFE_INTEGER = 9007199254740991, argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", reIsHostCtor = /^\[object .+?Constructor\]$/, reIsUint = /^(?:0|[1-9]\d*)$/, typedArrayTags = {};
            typedArrayTags["[object Float32Array]"] = typedArrayTags["[object Float64Array]"] = typedArrayTags["[object Int8Array]"] = typedArrayTags["[object Int16Array]"] = typedArrayTags["[object Int32Array]"] = typedArrayTags["[object Uint8Array]"] = typedArrayTags["[object Uint8ClampedArray]"] = typedArrayTags["[object Uint16Array]"] = typedArrayTags["[object Uint32Array]"] = !0, 
            typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags["[object WeakMap]"] = !1;
            var freeGlobal = "object" == typeof global && global && global.Object === Object && global, freeSelf = "object" == typeof self && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), freeExports = "object" == typeof exports && exports && !exports.nodeType && exports, freeModule = freeExports && "object" == typeof module && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports, freeProcess = moduleExports && freeGlobal.process, nodeUtil = function() {
                try {
                    return freeProcess && freeProcess.binding && freeProcess.binding("util");
                } catch (e) {}
            }(), nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
            function arraySome(array, predicate) {
                for (var index = -1, length = null == array ? 0 : array.length; ++index < length; ) if (predicate(array[index], index, array)) return !0;
                return !1;
            }
            function cacheHas(cache, key) {
                return cache.has(key);
            }
            function mapToArray(map) {
                var index = -1, result = Array(map.size);
                return map.forEach(function(value, key) {
                    result[++index] = [ key, value ];
                }), result;
            }
            function setToArray(set) {
                var index = -1, result = Array(set.size);
                return set.forEach(function(value) {
                    result[++index] = value;
                }), result;
            }
            var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype, coreJsData = root["__core-js_shared__"], funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, maskSrcKey = function() {
                var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
                return uid ? "Symbol(src)_1." + uid : "";
            }(), nativeObjectToString = objectProto.toString, reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Buffer = moduleExports ? root.Buffer : void 0, Symbol = root.Symbol, Uint8Array = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol ? Symbol.toStringTag : void 0, nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0, nativeKeys = function(func, transform) {
                return function(arg) {
                    return func(transform(arg));
                };
            }(Object.keys, Object), DataView = getNative(root, "DataView"), Map = getNative(root, "Map"), Promise = getNative(root, "Promise"), Set = getNative(root, "Set"), WeakMap = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create"), dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap), symbolProto = Symbol ? Symbol.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
            function Hash(entries) {
                var index = -1, length = null == entries ? 0 : entries.length;
                for (this.clear(); ++index < length; ) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                }
            }
            function ListCache(entries) {
                var index = -1, length = null == entries ? 0 : entries.length;
                for (this.clear(); ++index < length; ) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                }
            }
            function MapCache(entries) {
                var index = -1, length = null == entries ? 0 : entries.length;
                for (this.clear(); ++index < length; ) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                }
            }
            function SetCache(values) {
                var index = -1, length = null == values ? 0 : values.length;
                for (this.__data__ = new MapCache(); ++index < length; ) this.add(values[index]);
            }
            function Stack(entries) {
                var data = this.__data__ = new ListCache(entries);
                this.size = data.size;
            }
            function arrayLikeKeys(value, inherited) {
                var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? function(n, iteratee) {
                    for (var index = -1, result = Array(n); ++index < n; ) result[index] = iteratee(index);
                    return result;
                }(value.length, String) : [], length = result.length;
                for (var key in value) !inherited && !hasOwnProperty.call(value, key) || skipIndexes && ("length" == key || isBuff && ("offset" == key || "parent" == key) || isType && ("buffer" == key || "byteLength" == key || "byteOffset" == key) || isIndex(key, length)) || result.push(key);
                return result;
            }
            function assocIndexOf(array, key) {
                for (var length = array.length; length--; ) if (eq(array[length][0], key)) return length;
                return -1;
            }
            function baseGetTag(value) {
                return null == value ? void 0 === value ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(value) ? function(value) {
                    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
                    try {
                        value[symToStringTag] = void 0;
                        var unmasked = !0;
                    } catch (e) {}
                    var result = nativeObjectToString.call(value);
                    unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]);
                    return result;
                }(value) : function(value) {
                    return nativeObjectToString.call(value);
                }(value);
            }
            function baseIsArguments(value) {
                return isObjectLike(value) && baseGetTag(value) == argsTag;
            }
            function baseIsEqual(value, other, bitmask, customizer, stack) {
                return value === other || (null == value || null == other || !isObjectLike(value) && !isObjectLike(other) ? value != value && other != other : function(object, other, bitmask, customizer, equalFunc, stack) {
                    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other), objIsObj = (objTag = objTag == argsTag ? objectTag : objTag) == objectTag, othIsObj = (othTag = othTag == argsTag ? objectTag : othTag) == objectTag, isSameTag = objTag == othTag;
                    if (isSameTag && isBuffer(object)) {
                        if (!isBuffer(other)) return !1;
                        objIsArr = !0, objIsObj = !1;
                    }
                    if (isSameTag && !objIsObj) return stack || (stack = new Stack()), objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : function(object, other, tag, bitmask, customizer, equalFunc, stack) {
                        switch (tag) {
                          case dataViewTag:
                            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) return !1;
                            object = object.buffer, other = other.buffer;

                          case arrayBufferTag:
                            return !(object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other)));

                          case boolTag:
                          case dateTag:
                          case numberTag:
                            return eq(+object, +other);

                          case errorTag:
                            return object.name == other.name && object.message == other.message;

                          case regexpTag:
                          case stringTag:
                            return object == other + "";

                          case mapTag:
                            var convert = mapToArray;

                          case setTag:
                            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                            if (convert || (convert = setToArray), object.size != other.size && !isPartial) return !1;
                            var stacked = stack.get(object);
                            if (stacked) return stacked == other;
                            bitmask |= COMPARE_UNORDERED_FLAG, stack.set(object, other);
                            var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                            return stack.delete(object), result;

                          case symbolTag:
                            if (symbolValueOf) return symbolValueOf.call(object) == symbolValueOf.call(other);
                        }
                        return !1;
                    }(object, other, objTag, bitmask, customizer, equalFunc, stack);
                    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                        if (objIsWrapped || othIsWrapped) {
                            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                            return stack || (stack = new Stack()), equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
                        }
                    }
                    if (!isSameTag) return !1;
                    return stack || (stack = new Stack()), function(object, other, bitmask, customizer, equalFunc, stack) {
                        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othLength = getAllKeys(other).length;
                        if (objLength != othLength && !isPartial) return !1;
                        for (var index = objLength; index--; ) {
                            var key = objProps[index];
                            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) return !1;
                        }
                        var stacked = stack.get(object);
                        if (stacked && stack.get(other)) return stacked == other;
                        var result = !0;
                        stack.set(object, other), stack.set(other, object);
                        for (var skipCtor = isPartial; ++index < objLength; ) {
                            key = objProps[index];
                            var objValue = object[key], othValue = other[key];
                            if (customizer) var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                            if (!(void 0 === compared ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                                result = !1;
                                break;
                            }
                            skipCtor || (skipCtor = "constructor" == key);
                        }
                        if (result && !skipCtor) {
                            var objCtor = object.constructor, othCtor = other.constructor;
                            objCtor != othCtor && "constructor" in object && "constructor" in other && !("function" == typeof objCtor && objCtor instanceof objCtor && "function" == typeof othCtor && othCtor instanceof othCtor) && (result = !1);
                        }
                        return stack.delete(object), stack.delete(other), result;
                    }(object, other, bitmask, customizer, equalFunc, stack);
                }(value, other, bitmask, customizer, baseIsEqual, stack));
            }
            function baseIsNative(value) {
                return !(!isObject(value) || function(func) {
                    return !!maskSrcKey && maskSrcKey in func;
                }(value)) && (isFunction(value) ? reIsNative : reIsHostCtor).test(toSource(value));
            }
            function baseKeys(object) {
                if (!function(value) {
                    var Ctor = value && value.constructor, proto = "function" == typeof Ctor && Ctor.prototype || objectProto;
                    return value === proto;
                }(object)) return nativeKeys(object);
                var result = [];
                for (var key in Object(object)) hasOwnProperty.call(object, key) && "constructor" != key && result.push(key);
                return result;
            }
            function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
                if (arrLength != othLength && !(isPartial && othLength > arrLength)) return !1;
                var stacked = stack.get(array);
                if (stacked && stack.get(other)) return stacked == other;
                var index = -1, result = !0, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
                for (stack.set(array, other), stack.set(other, array); ++index < arrLength; ) {
                    var arrValue = array[index], othValue = other[index];
                    if (customizer) var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
                    if (void 0 !== compared) {
                        if (compared) continue;
                        result = !1;
                        break;
                    }
                    if (seen) {
                        if (!arraySome(other, function(othValue, othIndex) {
                            if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) return seen.push(othIndex);
                        })) {
                            result = !1;
                            break;
                        }
                    } else if (arrValue !== othValue && !equalFunc(arrValue, othValue, bitmask, customizer, stack)) {
                        result = !1;
                        break;
                    }
                }
                return stack.delete(array), stack.delete(other), result;
            }
            function getAllKeys(object) {
                return function(object, keysFunc, symbolsFunc) {
                    var result = keysFunc(object);
                    return isArray(object) ? result : function(array, values) {
                        for (var index = -1, length = values.length, offset = array.length; ++index < length; ) array[offset + index] = values[index];
                        return array;
                    }(result, symbolsFunc(object));
                }(object, keys, getSymbols);
            }
            function getMapData(map, key) {
                var data = map.__data__;
                return function(value) {
                    var type = typeof value;
                    return "string" == type || "number" == type || "symbol" == type || "boolean" == type ? "__proto__" !== value : null === value;
                }(key) ? data["string" == typeof key ? "string" : "hash"] : data.map;
            }
            function getNative(object, key) {
                var value = function(object, key) {
                    return null == object ? void 0 : object[key];
                }(object, key);
                return baseIsNative(value) ? value : void 0;
            }
            Hash.prototype.clear = function() {
                this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
            }, Hash.prototype.delete = function(key) {
                var result = this.has(key) && delete this.__data__[key];
                return this.size -= result ? 1 : 0, result;
            }, Hash.prototype.get = function(key) {
                var data = this.__data__;
                if (nativeCreate) {
                    var result = data[key];
                    return result === HASH_UNDEFINED ? void 0 : result;
                }
                return hasOwnProperty.call(data, key) ? data[key] : void 0;
            }, Hash.prototype.has = function(key) {
                var data = this.__data__;
                return nativeCreate ? void 0 !== data[key] : hasOwnProperty.call(data, key);
            }, Hash.prototype.set = function(key, value) {
                var data = this.__data__;
                return this.size += this.has(key) ? 0 : 1, data[key] = nativeCreate && void 0 === value ? HASH_UNDEFINED : value, 
                this;
            }, ListCache.prototype.clear = function() {
                this.__data__ = [], this.size = 0;
            }, ListCache.prototype.delete = function(key) {
                var data = this.__data__, index = assocIndexOf(data, key);
                return !(index < 0 || (index == data.length - 1 ? data.pop() : splice.call(data, index, 1), 
                --this.size, 0));
            }, ListCache.prototype.get = function(key) {
                var data = this.__data__, index = assocIndexOf(data, key);
                return index < 0 ? void 0 : data[index][1];
            }, ListCache.prototype.has = function(key) {
                return assocIndexOf(this.__data__, key) > -1;
            }, ListCache.prototype.set = function(key, value) {
                var data = this.__data__, index = assocIndexOf(data, key);
                return index < 0 ? (++this.size, data.push([ key, value ])) : data[index][1] = value, 
                this;
            }, MapCache.prototype.clear = function() {
                this.size = 0, this.__data__ = {
                    hash: new Hash(),
                    map: new (Map || ListCache)(),
                    string: new Hash()
                };
            }, MapCache.prototype.delete = function(key) {
                var result = getMapData(this, key).delete(key);
                return this.size -= result ? 1 : 0, result;
            }, MapCache.prototype.get = function(key) {
                return getMapData(this, key).get(key);
            }, MapCache.prototype.has = function(key) {
                return getMapData(this, key).has(key);
            }, MapCache.prototype.set = function(key, value) {
                var data = getMapData(this, key), size = data.size;
                return data.set(key, value), this.size += data.size == size ? 0 : 1, this;
            }, SetCache.prototype.add = SetCache.prototype.push = function(value) {
                return this.__data__.set(value, HASH_UNDEFINED), this;
            }, SetCache.prototype.has = function(value) {
                return this.__data__.has(value);
            }, Stack.prototype.clear = function() {
                this.__data__ = new ListCache(), this.size = 0;
            }, Stack.prototype.delete = function(key) {
                var data = this.__data__, result = data.delete(key);
                return this.size = data.size, result;
            }, Stack.prototype.get = function(key) {
                return this.__data__.get(key);
            }, Stack.prototype.has = function(key) {
                return this.__data__.has(key);
            }, Stack.prototype.set = function(key, value) {
                var data = this.__data__;
                if (data instanceof ListCache) {
                    var pairs = data.__data__;
                    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) return pairs.push([ key, value ]), 
                    this.size = ++data.size, this;
                    data = this.__data__ = new MapCache(pairs);
                }
                return data.set(key, value), this.size = data.size, this;
            };
            var getSymbols = nativeGetSymbols ? function(object) {
                return null == object ? [] : (object = Object(object), function(array, predicate) {
                    for (var index = -1, length = null == array ? 0 : array.length, resIndex = 0, result = []; ++index < length; ) {
                        var value = array[index];
                        predicate(value, index, array) && (result[resIndex++] = value);
                    }
                    return result;
                }(nativeGetSymbols(object), function(symbol) {
                    return propertyIsEnumerable.call(object, symbol);
                }));
            } : function() {
                return [];
            }, getTag = baseGetTag;
            function isIndex(value, length) {
                return !!(length = null == length ? MAX_SAFE_INTEGER : length) && ("number" == typeof value || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
            }
            function toSource(func) {
                if (null != func) {
                    try {
                        return funcToString.call(func);
                    } catch (e) {}
                    try {
                        return func + "";
                    } catch (e) {}
                }
                return "";
            }
            function eq(value, other) {
                return value === other || value != value && other != other;
            }
            (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && "[object Promise]" != getTag(Promise.resolve()) || Set && getTag(new Set()) != setTag || WeakMap && "[object WeakMap]" != getTag(new WeakMap())) && (getTag = function(value) {
                var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
                if (ctorString) switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;

                  case mapCtorString:
                    return mapTag;

                  case promiseCtorString:
                    return "[object Promise]";

                  case setCtorString:
                    return setTag;

                  case weakMapCtorString:
                    return "[object WeakMap]";
                }
                return result;
            });
            var isArguments = baseIsArguments(function() {
                return arguments;
            }()) ? baseIsArguments : function(value) {
                return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
            }, isArray = Array.isArray;
            var isBuffer = nativeIsBuffer || function() {
                return !1;
            };
            function isFunction(value) {
                if (!isObject(value)) return !1;
                var tag = baseGetTag(value);
                return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
            }
            function isLength(value) {
                return "number" == typeof value && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
            }
            function isObject(value) {
                var type = typeof value;
                return null != value && ("object" == type || "function" == type);
            }
            function isObjectLike(value) {
                return null != value && "object" == typeof value;
            }
            var isTypedArray = nodeIsTypedArray ? function(func) {
                return function(value) {
                    return func(value);
                };
            }(nodeIsTypedArray) : function(value) {
                return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
            };
            function keys(object) {
                return function(value) {
                    return null != value && isLength(value.length) && !isFunction(value);
                }(object) ? arrayLikeKeys(object) : baseKeys(object);
            }
            module.exports = function(value, other) {
                return baseIsEqual(value, other);
            };
        }).call(this, __webpack_require__(52), __webpack_require__(83)(module));
    }, function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = void 0;
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _react = __webpack_require__(49), _react2 = _interopRequireDefault(_react), _propTypes2 = _interopRequireDefault(__webpack_require__(177)), _fastDeepEqual2 = _interopRequireDefault(__webpack_require__(180)), _sizeSensor = __webpack_require__(181), _utils = __webpack_require__(187);
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        var EchartsReactCore = function(_Component) {
            function EchartsReactCore(props) {
                !function(instance, Constructor) {
                    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                }(this, EchartsReactCore);
                var _this = function(self, call) {
                    if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !call || "object" != typeof call && "function" != typeof call ? self : call;
                }(this, (EchartsReactCore.__proto__ || Object.getPrototypeOf(EchartsReactCore)).call(this, props));
                return _this.getEchartsInstance = function() {
                    return _this.echartsLib.getInstanceByDom(_this.echartsElement) || _this.echartsLib.init(_this.echartsElement, _this.props.theme, _this.props.opts);
                }, _this.dispose = function() {
                    if (_this.echartsElement) {
                        try {
                            (0, _sizeSensor.clear)(_this.echartsElement);
                        } catch (e) {
                            console.warn(e);
                        }
                        _this.echartsLib.dispose(_this.echartsElement);
                    }
                }, _this.rerender = function() {
                    var _this$props = _this.props, onEvents = _this$props.onEvents, onChartReady = _this$props.onChartReady, echartObj = _this.renderEchartDom();
                    _this.bindEvents(echartObj, onEvents || {}), "function" == typeof onChartReady && _this.props.onChartReady(echartObj), 
                    _this.echartsElement && (0, _sizeSensor.bind)(_this.echartsElement, function() {
                        try {
                            echartObj.resize();
                        } catch (e) {
                            console.warn(e);
                        }
                    });
                }, _this.bindEvents = function(instance, events) {
                    var _bindEvent = function(eventName, func) {
                        "string" == typeof eventName && "function" == typeof func && instance.on(eventName, function(param) {
                            func(param, instance);
                        });
                    };
                    for (var eventName in events) Object.prototype.hasOwnProperty.call(events, eventName) && _bindEvent(eventName, events[eventName]);
                }, _this.renderEchartDom = function() {
                    var echartObj = _this.getEchartsInstance();
                    return echartObj.setOption(_this.props.option, _this.props.notMerge || !1, _this.props.lazyUpdate || !1), 
                    _this.props.showLoading ? echartObj.showLoading(_this.props.loadingOption || null) : echartObj.hideLoading(), 
                    echartObj;
                }, _this.echartsLib = props.echarts, _this.echartsElement = null, _this;
            }
            return function(subClass, superClass) {
                if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
            }(EchartsReactCore, _react.Component), _createClass(EchartsReactCore, [ {
                key: "componentDidMount",
                value: function() {
                    this.rerender();
                }
            }, {
                key: "componentDidUpdate",
                value: function(prevProps) {
                    if (prevProps.theme !== this.props.theme || !(0, _fastDeepEqual2.default)(prevProps.opts, this.props.opts) || !(0, 
                    _fastDeepEqual2.default)(prevProps.onEvents, this.props.onEvents)) return this.dispose(), 
                    void this.rerender();
                    var pickKeys = [ "option", "notMerge", "lazyUpdate", "showLoading", "loadingOption" ];
                    if (!(0, _fastDeepEqual2.default)((0, _utils.pick)(this.props, pickKeys), (0, _utils.pick)(prevProps, pickKeys)) && ("function" != typeof this.props.shouldSetOption || this.props.shouldSetOption(prevProps, this.props))) {
                        var echartObj = this.renderEchartDom();
                        if (!(0, _fastDeepEqual2.default)(prevProps.style, this.props.style) || !(0, _fastDeepEqual2.default)(prevProps.className, this.props.className)) try {
                            echartObj.resize();
                        } catch (e) {
                            console.warn(e);
                        }
                    }
                }
            }, {
                key: "componentWillUnmount",
                value: function() {
                    this.dispose();
                }
            }, {
                key: "render",
                value: function() {
                    var _this2 = this, _props = this.props, style = _props.style, className = _props.className, newStyle = _extends({
                        height: 300
                    }, style);
                    return _react2.default.createElement("div", {
                        ref: function(e) {
                            _this2.echartsElement = e;
                        },
                        style: newStyle,
                        className: "echarts-for-react " + className
                    });
                }
            } ]), EchartsReactCore;
        }();
        exports.default = EchartsReactCore, EchartsReactCore.propTypes = {
            option: _propTypes2.default.object.isRequired,
            echarts: _propTypes2.default.object,
            notMerge: _propTypes2.default.bool,
            lazyUpdate: _propTypes2.default.bool,
            style: _propTypes2.default.object,
            className: _propTypes2.default.string,
            theme: _propTypes2.default.string,
            onChartReady: _propTypes2.default.func,
            showLoading: _propTypes2.default.bool,
            loadingOption: _propTypes2.default.object,
            onEvents: _propTypes2.default.object,
            opts: _propTypes2.default.shape({
                devicePixelRatio: _propTypes2.default.number,
                renderer: _propTypes2.default.oneOf([ "canvas", "svg" ]),
                width: _propTypes2.default.oneOfType([ _propTypes2.default.number, _propTypes2.default.oneOf([ null, void 0, "auto" ]) ]),
                height: _propTypes2.default.oneOfType([ _propTypes2.default.number, _propTypes2.default.oneOf([ null, void 0, "auto" ]) ])
            }),
            shouldSetOption: _propTypes2.default.func
        }, EchartsReactCore.defaultProps = {
            echarts: {},
            notMerge: !1,
            lazyUpdate: !1,
            style: {},
            className: "",
            theme: null,
            onChartReady: function() {},
            showLoading: !1,
            loadingOption: null,
            onEvents: {},
            opts: {},
            shouldSetOption: function() {
                return !0;
            }
        };
    }, function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__(178)();
    }, function(module, exports, __webpack_require__) {
        "use strict";
        var ReactPropTypesSecret = __webpack_require__(179);
        function emptyFunction() {}
        function emptyFunctionWithReset() {}
        emptyFunctionWithReset.resetWarningCache = emptyFunction, module.exports = function() {
            function shim(props, propName, componentName, location, propFullName, secret) {
                if (secret !== ReactPropTypesSecret) {
                    var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
                    throw err.name = "Invariant Violation", err;
                }
            }
            function getShim() {
                return shim;
            }
            shim.isRequired = shim;
            var ReactPropTypes = {
                array: shim,
                bool: shim,
                func: shim,
                number: shim,
                object: shim,
                string: shim,
                symbol: shim,
                any: shim,
                arrayOf: getShim,
                element: shim,
                elementType: shim,
                instanceOf: getShim,
                node: shim,
                objectOf: getShim,
                oneOf: getShim,
                oneOfType: getShim,
                shape: getShim,
                exact: getShim,
                checkPropTypes: emptyFunctionWithReset,
                resetWarningCache: emptyFunction
            };
            return ReactPropTypes.PropTypes = ReactPropTypes, ReactPropTypes;
        };
    }, function(module, exports, __webpack_require__) {
        "use strict";
        module.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    }, function(module, exports, __webpack_require__) {
        "use strict";
        var isArray = Array.isArray, keyList = Object.keys, hasProp = Object.prototype.hasOwnProperty;
        module.exports = function equal(a, b) {
            if (a === b) return !0;
            if (a && b && "object" == typeof a && "object" == typeof b) {
                var i, length, key, arrA = isArray(a), arrB = isArray(b);
                if (arrA && arrB) {
                    if ((length = a.length) != b.length) return !1;
                    for (i = length; 0 != i--; ) if (!equal(a[i], b[i])) return !1;
                    return !0;
                }
                if (arrA != arrB) return !1;
                var dateA = a instanceof Date, dateB = b instanceof Date;
                if (dateA != dateB) return !1;
                if (dateA && dateB) return a.getTime() == b.getTime();
                var regexpA = a instanceof RegExp, regexpB = b instanceof RegExp;
                if (regexpA != regexpB) return !1;
                if (regexpA && regexpB) return a.toString() == b.toString();
                var keys = keyList(a);
                if ((length = keys.length) !== keyList(b).length) return !1;
                for (i = length; 0 != i--; ) if (!hasProp.call(b, keys[i])) return !1;
                for (i = length; 0 != i--; ) if (!equal(a[key = keys[i]], b[key])) return !1;
                return !0;
            }
            return a != a && b != b;
        };
    }, function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.clear = exports.bind = void 0;
        var _sensorPool = __webpack_require__(182);
        exports.bind = function(element, cb) {
            var sensor = (0, _sensorPool.getSensor)(element);
            return sensor.bind(cb), function() {
                sensor.unbind(cb);
            };
        }, exports.clear = function(element) {
            var sensor = (0, _sensorPool.getSensor)(element);
            (0, _sensorPool.removeSensor)(sensor);
        };
    }, function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.removeSensor = exports.getSensor = void 0;
        var _id2 = function(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }(__webpack_require__(183)), _sensors = __webpack_require__(184), _constant = __webpack_require__(85);
        var Sensors = {};
        exports.getSensor = function(element) {
            var sensorId = element.getAttribute(_constant.SizeSensorId);
            if (sensorId && Sensors[sensorId]) return Sensors[sensorId];
            var newId = (0, _id2.default)();
            element.setAttribute(_constant.SizeSensorId, newId);
            var sensor = (0, _sensors.createSensor)(element);
            return Sensors[newId] = sensor, sensor;
        }, exports.removeSensor = function(sensor) {
            var sensorId = sensor.element.getAttribute(_constant.SizeSensorId);
            sensor.element.removeAttribute(_constant.SizeSensorId), sensor.destroy(), sensorId && Sensors[sensorId] && delete Sensors[sensorId];
        };
    }, function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var id = 1;
        exports.default = function() {
            return "" + id++;
        }, module.exports = exports.default;
    }, function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.createSensor = void 0;
        var _object = __webpack_require__(185), _resizeObserver = __webpack_require__(186);
        exports.createSensor = "undefined" != typeof ResizeObserver ? _resizeObserver.createSensor : _object.createSensor;
    }, function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.createSensor = void 0;
        var _debounce2 = function(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }(__webpack_require__(84)), _constant = __webpack_require__(85);
        exports.createSensor = function(element) {
            var sensor = void 0, listeners = [], resizeListener = (0, _debounce2.default)(function() {
                listeners.forEach(function(listener) {
                    listener(element);
                });
            }), destroy = function() {
                sensor && sensor.parentNode && (sensor.contentDocument && sensor.contentDocument.defaultView.removeEventListener("resize", resizeListener), 
                sensor.parentNode.removeChild(sensor), sensor = void 0, listeners = []);
            };
            return {
                element: element,
                bind: function(cb) {
                    sensor || (sensor = function() {
                        "static" === getComputedStyle(element).position && (element.style.position = "relative");
                        var obj = document.createElement("object");
                        return obj.onload = function() {
                            obj.contentDocument.defaultView.addEventListener("resize", resizeListener), resizeListener();
                        }, obj.setAttribute("style", _constant.SensorStyle), obj.setAttribute("class", _constant.SensorClassName), 
                        obj.type = "text/html", element.appendChild(obj), obj.data = "about:blank", obj;
                    }()), -1 === listeners.indexOf(cb) && listeners.push(cb);
                },
                destroy: destroy,
                unbind: function(cb) {
                    var idx = listeners.indexOf(cb);
                    -1 !== idx && listeners.splice(idx, 1), 0 === listeners.length && sensor && destroy();
                }
            };
        };
    }, function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.createSensor = void 0;
        var _debounce2 = function(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }(__webpack_require__(84));
        exports.createSensor = function(element) {
            var sensor = void 0, listeners = [], resizeListener = (0, _debounce2.default)(function() {
                listeners.forEach(function(listener) {
                    listener(element);
                });
            }), destroy = function() {
                sensor.disconnect(), listeners = [], sensor = void 0;
            };
            return {
                element: element,
                bind: function(cb) {
                    sensor || (sensor = function() {
                        var sensor = new ResizeObserver(resizeListener);
                        return sensor.observe(element), resizeListener(), sensor;
                    }()), -1 === listeners.indexOf(cb) && listeners.push(cb);
                },
                destroy: destroy,
                unbind: function(cb) {
                    var idx = listeners.indexOf(cb);
                    -1 !== idx && listeners.splice(idx, 1), 0 === listeners.length && sensor && destroy();
                }
            };
        };
    }, function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        exports.pick = function(obj, keys) {
            var r = {};
            return keys.forEach(function(key) {
                r[key] = obj[key];
            }), r;
        };
    }, function(module, exports, __webpack_require__) {
        var util = __webpack_require__(0), vec2 = __webpack_require__(6), Draggable = __webpack_require__(189), Eventful = __webpack_require__(23), eventTool = __webpack_require__(15), GestureMgr = __webpack_require__(191), SILENT = "silent";
        function stopEvent(event) {
            eventTool.stop(this.event);
        }
        function EmptyProxy() {}
        EmptyProxy.prototype.dispose = function() {};
        var handlerNames = [ "click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu" ], Handler = function(storage, painter, proxy, painterRoot) {
            Eventful.call(this), this.storage = storage, this.painter = painter, this.painterRoot = painterRoot, 
            proxy = proxy || new EmptyProxy(), this.proxy = null, this._hovered = {}, this._lastTouchMoment, 
            this._lastX, this._lastY, this._gestureMgr, Draggable.call(this), this.setHandlerProxy(proxy);
        };
        function isHover(displayable, x, y) {
            if (displayable[displayable.rectHover ? "rectContain" : "contain"](x, y)) {
                for (var isSilent, el = displayable; el; ) {
                    if (el.clipPath && !el.clipPath.contain(x, y)) return !1;
                    el.silent && (isSilent = !0), el = el.parent;
                }
                return !isSilent || SILENT;
            }
            return !1;
        }
        Handler.prototype = {
            constructor: Handler,
            setHandlerProxy: function(proxy) {
                this.proxy && this.proxy.dispose(), proxy && (util.each(handlerNames, function(name) {
                    proxy.on && proxy.on(name, this[name], this);
                }, this), proxy.handler = this), this.proxy = proxy;
            },
            mousemove: function(event) {
                var x = event.zrX, y = event.zrY, lastHovered = this._hovered, lastHoveredTarget = lastHovered.target;
                lastHoveredTarget && !lastHoveredTarget.__zr && (lastHoveredTarget = (lastHovered = this.findHover(lastHovered.x, lastHovered.y)).target);
                var hovered = this._hovered = this.findHover(x, y), hoveredTarget = hovered.target, proxy = this.proxy;
                proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : "default"), 
                lastHoveredTarget && hoveredTarget !== lastHoveredTarget && this.dispatchToElement(lastHovered, "mouseout", event), 
                this.dispatchToElement(hovered, "mousemove", event), hoveredTarget && hoveredTarget !== lastHoveredTarget && this.dispatchToElement(hovered, "mouseover", event);
            },
            mouseout: function(event) {
                this.dispatchToElement(this._hovered, "mouseout", event);
                var innerDom, element = event.toElement || event.relatedTarget;
                do {
                    element = element && element.parentNode;
                } while (element && 9 !== element.nodeType && !(innerDom = element === this.painterRoot));
                !innerDom && this.trigger("globalout", {
                    event: event
                });
            },
            resize: function(event) {
                this._hovered = {};
            },
            dispatch: function(eventName, eventArgs) {
                var handler = this[eventName];
                handler && handler.call(this, eventArgs);
            },
            dispose: function() {
                this.proxy.dispose(), this.storage = this.proxy = this.painter = null;
            },
            setCursorStyle: function(cursorStyle) {
                var proxy = this.proxy;
                proxy.setCursor && proxy.setCursor(cursorStyle);
            },
            dispatchToElement: function(targetInfo, eventName, event) {
                var el = (targetInfo = targetInfo || {}).target;
                if (!el || !el.silent) {
                    for (var eventHandler = "on" + eventName, eventPacket = function(eveType, targetInfo, event) {
                        return {
                            type: eveType,
                            event: event,
                            target: targetInfo.target,
                            topTarget: targetInfo.topTarget,
                            cancelBubble: !1,
                            offsetX: event.zrX,
                            offsetY: event.zrY,
                            gestureEvent: event.gestureEvent,
                            pinchX: event.pinchX,
                            pinchY: event.pinchY,
                            pinchScale: event.pinchScale,
                            wheelDelta: event.zrDelta,
                            zrByTouch: event.zrByTouch,
                            which: event.which,
                            stop: stopEvent
                        };
                    }(eventName, targetInfo, event); el && (el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket)), 
                    el.trigger(eventName, eventPacket), el = el.parent, !eventPacket.cancelBubble); ) ;
                    eventPacket.cancelBubble || (this.trigger(eventName, eventPacket), this.painter && this.painter.eachOtherLayer(function(layer) {
                        "function" == typeof layer[eventHandler] && layer[eventHandler].call(layer, eventPacket), 
                        layer.trigger && layer.trigger(eventName, eventPacket);
                    }));
                }
            },
            findHover: function(x, y, exclude) {
                for (var list = this.storage.getDisplayList(), out = {
                    x: x,
                    y: y
                }, i = list.length - 1; i >= 0; i--) {
                    var hoverCheckResult;
                    if (list[i] !== exclude && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y)) && (!out.topTarget && (out.topTarget = list[i]), 
                    hoverCheckResult !== SILENT)) {
                        out.target = list[i];
                        break;
                    }
                }
                return out;
            },
            processGesture: function(event, stage) {
                this._gestureMgr || (this._gestureMgr = new GestureMgr());
                var gestureMgr = this._gestureMgr;
                "start" === stage && gestureMgr.clear();
                var gestureInfo = gestureMgr.recognize(event, this.findHover(event.zrX, event.zrY, null).target, this.proxy.dom);
                if ("end" === stage && gestureMgr.clear(), gestureInfo) {
                    var type = gestureInfo.type;
                    event.gestureEvent = type, this.dispatchToElement({
                        target: gestureInfo.target
                    }, type, gestureInfo.event);
                }
            }
        }, util.each([ "click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu" ], function(name) {
            Handler.prototype[name] = function(event) {
                var hovered = this.findHover(event.zrX, event.zrY), hoveredTarget = hovered.target;
                if ("mousedown" === name) this._downEl = hoveredTarget, this._downPoint = [ event.zrX, event.zrY ], 
                this._upEl = hoveredTarget; else if ("mouseup" === name) this._upEl = hoveredTarget; else if ("click" === name) {
                    if (this._downEl !== this._upEl || !this._downPoint || vec2.dist(this._downPoint, [ event.zrX, event.zrY ]) > 4) return;
                    this._downPoint = null;
                }
                this.dispatchToElement(hovered, name, event);
            };
        }), util.mixin(Handler, Eventful), util.mixin(Handler, Draggable);
        var _default = Handler;
        module.exports = _default;
    }, function(module, exports) {
        function Draggable() {
            this.on("mousedown", this._dragStart, this), this.on("mousemove", this._drag, this), 
            this.on("mouseup", this._dragEnd, this), this.on("globalout", this._dragEnd, this);
        }
        function param(target, e) {
            return {
                target: target,
                topTarget: e && e.topTarget
            };
        }
        Draggable.prototype = {
            constructor: Draggable,
            _dragStart: function(e) {
                var draggingTarget = e.target;
                draggingTarget && draggingTarget.draggable && (this._draggingTarget = draggingTarget, 
                draggingTarget.dragging = !0, this._x = e.offsetX, this._y = e.offsetY, this.dispatchToElement(param(draggingTarget, e), "dragstart", e.event));
            },
            _drag: function(e) {
                var draggingTarget = this._draggingTarget;
                if (draggingTarget) {
                    var x = e.offsetX, y = e.offsetY, dx = x - this._x, dy = y - this._y;
                    this._x = x, this._y = y, draggingTarget.drift(dx, dy, e), this.dispatchToElement(param(draggingTarget, e), "drag", e.event);
                    var dropTarget = this.findHover(x, y, draggingTarget).target, lastDropTarget = this._dropTarget;
                    this._dropTarget = dropTarget, draggingTarget !== dropTarget && (lastDropTarget && dropTarget !== lastDropTarget && this.dispatchToElement(param(lastDropTarget, e), "dragleave", e.event), 
                    dropTarget && dropTarget !== lastDropTarget && this.dispatchToElement(param(dropTarget, e), "dragenter", e.event));
                }
            },
            _dragEnd: function(e) {
                var draggingTarget = this._draggingTarget;
                draggingTarget && (draggingTarget.dragging = !1), this.dispatchToElement(param(draggingTarget, e), "dragend", e.event), 
                this._dropTarget && this.dispatchToElement(param(this._dropTarget, e), "drop", e.event), 
                this._draggingTarget = null, this._dropTarget = null;
            }
        };
        var _default = Draggable;
        module.exports = _default;
    }, function(module, exports) {
        var LN2 = Math.log(2);
        function determinant(rows, rank, rowStart, rowMask, colMask, detCache) {
            var cacheKey = rowMask + "-" + colMask, fullRank = rows.length;
            if (detCache.hasOwnProperty(cacheKey)) return detCache[cacheKey];
            if (1 === rank) {
                var colStart = Math.round(Math.log((1 << fullRank) - 1 & ~colMask) / LN2);
                return rows[rowStart][colStart];
            }
            for (var subRowMask = rowMask | 1 << rowStart, subRowStart = rowStart + 1; rowMask & 1 << subRowStart; ) subRowStart++;
            for (var sum = 0, j = 0, colLocalIdx = 0; j < fullRank; j++) {
                var colTag = 1 << j;
                colTag & colMask || (sum += (colLocalIdx % 2 ? -1 : 1) * rows[rowStart][j] * determinant(rows, rank - 1, subRowStart, subRowMask, colMask | colTag, detCache), 
                colLocalIdx++);
            }
            return detCache[cacheKey] = sum, sum;
        }
        exports.buildTransformer = function(src, dest) {
            var mA = [ [ src[0], src[1], 1, 0, 0, 0, -dest[0] * src[0], -dest[0] * src[1] ], [ 0, 0, 0, src[0], src[1], 1, -dest[1] * src[0], -dest[1] * src[1] ], [ src[2], src[3], 1, 0, 0, 0, -dest[2] * src[2], -dest[2] * src[3] ], [ 0, 0, 0, src[2], src[3], 1, -dest[3] * src[2], -dest[3] * src[3] ], [ src[4], src[5], 1, 0, 0, 0, -dest[4] * src[4], -dest[4] * src[5] ], [ 0, 0, 0, src[4], src[5], 1, -dest[5] * src[4], -dest[5] * src[5] ], [ src[6], src[7], 1, 0, 0, 0, -dest[6] * src[6], -dest[6] * src[7] ], [ 0, 0, 0, src[6], src[7], 1, -dest[7] * src[6], -dest[7] * src[7] ] ], detCache = {}, det = determinant(mA, 8, 0, 0, 0, detCache);
            if (0 !== det) {
                for (var vh = [], i = 0; i < 8; i++) for (var j = 0; j < 8; j++) null == vh[j] && (vh[j] = 0), 
                vh[j] += ((i + j) % 2 ? -1 : 1) * determinant(mA, 7, 0 === i ? 1 : 0, 1 << i, 1 << j, detCache) / det * dest[i];
                return function(out, srcPointX, srcPointY) {
                    var pk = srcPointX * vh[6] + srcPointY * vh[7] + 1;
                    out[0] = (srcPointX * vh[0] + srcPointY * vh[1] + vh[2]) / pk, out[1] = (srcPointX * vh[3] + srcPointY * vh[4] + vh[5]) / pk;
                };
            }
        };
    }, function(module, exports, __webpack_require__) {
        var eventUtil = __webpack_require__(15), GestureMgr = function() {
            this._track = [];
        };
        function dist(pointPair) {
            var dx = pointPair[1][0] - pointPair[0][0], dy = pointPair[1][1] - pointPair[0][1];
            return Math.sqrt(dx * dx + dy * dy);
        }
        GestureMgr.prototype = {
            constructor: GestureMgr,
            recognize: function(event, target, root) {
                return this._doTrack(event, target, root), this._recognize(event);
            },
            clear: function() {
                return this._track.length = 0, this;
            },
            _doTrack: function(event, target, root) {
                var touches = event.touches;
                if (touches) {
                    for (var trackItem = {
                        points: [],
                        touches: [],
                        target: target,
                        event: event
                    }, i = 0, len = touches.length; i < len; i++) {
                        var touch = touches[i], pos = eventUtil.clientToLocal(root, touch, {});
                        trackItem.points.push([ pos.zrX, pos.zrY ]), trackItem.touches.push(touch);
                    }
                    this._track.push(trackItem);
                }
            },
            _recognize: function(event) {
                for (var eventName in recognizers) if (recognizers.hasOwnProperty(eventName)) {
                    var gestureInfo = recognizers[eventName](this._track, event);
                    if (gestureInfo) return gestureInfo;
                }
            }
        };
        var recognizers = {
            pinch: function(track, event) {
                var trackLen = track.length;
                if (trackLen) {
                    var pinchEnd = (track[trackLen - 1] || {}).points, pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;
                    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
                        var pinchScale = dist(pinchEnd) / dist(pinchPre);
                        !isFinite(pinchScale) && (pinchScale = 1), event.pinchScale = pinchScale;
                        var pinchCenter = function(pointPair) {
                            return [ (pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2 ];
                        }(pinchEnd);
                        return event.pinchX = pinchCenter[0], event.pinchY = pinchCenter[1], {
                            type: "pinch",
                            target: track[0].target,
                            event: event
                        };
                    }
                }
            }
        }, _default = GestureMgr;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var util = __webpack_require__(0), env = __webpack_require__(7), Group = __webpack_require__(27), timsort = __webpack_require__(53);
        function shapeCompareFunc(a, b) {
            return a.zlevel === b.zlevel ? a.z === b.z ? a.z2 - b.z2 : a.z - b.z : a.zlevel - b.zlevel;
        }
        var Storage = function() {
            this._roots = [], this._displayList = [], this._displayListLen = 0;
        };
        Storage.prototype = {
            constructor: Storage,
            traverse: function(cb, context) {
                for (var i = 0; i < this._roots.length; i++) this._roots[i].traverse(cb, context);
            },
            getDisplayList: function(update, includeIgnore) {
                return includeIgnore = includeIgnore || !1, update && this.updateDisplayList(includeIgnore), 
                this._displayList;
            },
            updateDisplayList: function(includeIgnore) {
                this._displayListLen = 0;
                for (var roots = this._roots, displayList = this._displayList, i = 0, len = roots.length; i < len; i++) this._updateAndAddDisplayable(roots[i], null, includeIgnore);
                displayList.length = this._displayListLen, env.canvasSupported && timsort(displayList, shapeCompareFunc);
            },
            _updateAndAddDisplayable: function(el, clipPaths, includeIgnore) {
                if (!el.ignore || includeIgnore) {
                    el.beforeUpdate(), el.__dirty && el.update(), el.afterUpdate();
                    var userSetClipPath = el.clipPath;
                    if (userSetClipPath) {
                        clipPaths = clipPaths ? clipPaths.slice() : [];
                        for (var currentClipPath = userSetClipPath, parentClipPath = el; currentClipPath; ) currentClipPath.parent = parentClipPath, 
                        currentClipPath.updateTransform(), clipPaths.push(currentClipPath), parentClipPath = currentClipPath, 
                        currentClipPath = currentClipPath.clipPath;
                    }
                    if (el.isGroup) {
                        for (var children = el._children, i = 0; i < children.length; i++) {
                            var child = children[i];
                            el.__dirty && (child.__dirty = !0), this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
                        }
                        el.__dirty = !1;
                    } else el.__clipPaths = clipPaths, this._displayList[this._displayListLen++] = el;
                }
            },
            addRoot: function(el) {
                el.__storage !== this && (el instanceof Group && el.addChildrenToStorage(this), 
                this.addToStorage(el), this._roots.push(el));
            },
            delRoot: function(el) {
                if (null == el) {
                    for (var i = 0; i < this._roots.length; i++) {
                        var root = this._roots[i];
                        root instanceof Group && root.delChildrenFromStorage(this);
                    }
                    return this._roots = [], this._displayList = [], void (this._displayListLen = 0);
                }
                if (el instanceof Array) {
                    i = 0;
                    for (var l = el.length; i < l; i++) this.delRoot(el[i]);
                } else {
                    var idx = util.indexOf(this._roots, el);
                    idx >= 0 && (this.delFromStorage(el), this._roots.splice(idx, 1), el instanceof Group && el.delChildrenFromStorage(this));
                }
            },
            addToStorage: function(el) {
                return el && (el.__storage = this, el.dirty(!1)), this;
            },
            delFromStorage: function(el) {
                return el && (el.__storage = null), this;
            },
            dispose: function() {
                this._renderList = this._roots = null;
            },
            displayableSortFunc: shapeCompareFunc
        };
        var _default = Storage;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var Animator = __webpack_require__(90), log = __webpack_require__(92), _util = __webpack_require__(0), isString = _util.isString, isFunction = _util.isFunction, isObject = _util.isObject, isArrayLike = _util.isArrayLike, indexOf = _util.indexOf, Animatable = function() {
            this.animators = [];
        };
        function animateTo(animatable, target, time, delay, easing, callback, forceAnimate, reverse) {
            isString(delay) ? (callback = easing, easing = delay, delay = 0) : isFunction(easing) ? (callback = easing, 
            easing = "linear", delay = 0) : isFunction(delay) ? (callback = delay, delay = 0) : isFunction(time) ? (callback = time, 
            time = 500) : time || (time = 500), animatable.stopAnimation(), function animateToShallow(animatable, path, source, target, time, delay, reverse) {
                var objShallow = {};
                var propertyCount = 0;
                for (var name in target) target.hasOwnProperty(name) && (null != source[name] ? isObject(target[name]) && !isArrayLike(target[name]) ? animateToShallow(animatable, path ? path + "." + name : name, source[name], target[name], time, delay, reverse) : (reverse ? (objShallow[name] = source[name], 
                setAttrByPath(animatable, path, name, target[name])) : objShallow[name] = target[name], 
                propertyCount++) : null == target[name] || reverse || setAttrByPath(animatable, path, name, target[name]));
                propertyCount > 0 && animatable.animate(path, !1).when(null == time ? 500 : time, objShallow).delay(delay || 0);
            }(animatable, "", animatable, target, time, delay, reverse);
            var animators = animatable.animators.slice(), count = animators.length;
            function done() {
                --count || callback && callback();
            }
            count || callback && callback();
            for (var i = 0; i < animators.length; i++) animators[i].done(done).start(easing, forceAnimate);
        }
        function setAttrByPath(el, path, name, value) {
            if (path) {
                var props = {};
                props[path] = {}, props[path][name] = value, el.attr(props);
            } else el.attr(name, value);
        }
        Animatable.prototype = {
            constructor: Animatable,
            animate: function(path, loop) {
                var target, animatingShape = !1, el = this, zr = this.__zr;
                if (path) {
                    var pathSplitted = path.split("."), prop = el;
                    animatingShape = "shape" === pathSplitted[0];
                    for (var i = 0, l = pathSplitted.length; i < l; i++) prop && (prop = prop[pathSplitted[i]]);
                    prop && (target = prop);
                } else target = el;
                if (target) {
                    var animators = el.animators, animator = new Animator(target, loop);
                    return animator.during(function(target) {
                        el.dirty(animatingShape);
                    }).done(function() {
                        animators.splice(indexOf(animators, animator), 1);
                    }), animators.push(animator), zr && zr.animation.addAnimator(animator), animator;
                }
                log('Property "' + path + '" is not existed in element ' + el.id);
            },
            stopAnimation: function(forwardToLast) {
                for (var animators = this.animators, len = animators.length, i = 0; i < len; i++) animators[i].stop(forwardToLast);
                return animators.length = 0, this;
            },
            animateTo: function(target, time, delay, easing, callback, forceAnimate) {
                animateTo(this, target, time, delay, easing, callback, forceAnimate);
            },
            animateFrom: function(target, time, delay, easing, callback, forceAnimate) {
                animateTo(this, target, time, delay, easing, callback, forceAnimate, !0);
            }
        };
        var _default = Animatable;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var easingFuncs = __webpack_require__(195);
        function Clip(options) {
            this._target = options.target, this._life = options.life || 1e3, this._delay = options.delay || 0, 
            this._initialized = !1, this.loop = null != options.loop && options.loop, this.gap = options.gap || 0, 
            this.easing = options.easing || "Linear", this.onframe = options.onframe, this.ondestroy = options.ondestroy, 
            this.onrestart = options.onrestart, this._pausedTime = 0, this._paused = !1;
        }
        Clip.prototype = {
            constructor: Clip,
            step: function(globalTime, deltaTime) {
                if (this._initialized || (this._startTime = globalTime + this._delay, this._initialized = !0), 
                this._paused) this._pausedTime += deltaTime; else {
                    var percent = (globalTime - this._startTime - this._pausedTime) / this._life;
                    if (!(percent < 0)) {
                        percent = Math.min(percent, 1);
                        var easing = this.easing, easingFunc = "string" == typeof easing ? easingFuncs[easing] : easing, schedule = "function" == typeof easingFunc ? easingFunc(percent) : percent;
                        return this.fire("frame", schedule), 1 === percent ? this.loop ? (this.restart(globalTime), 
                        "restart") : (this._needsRemove = !0, "destroy") : null;
                    }
                }
            },
            restart: function(globalTime) {
                var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;
                this._startTime = globalTime - remainder + this.gap, this._pausedTime = 0, this._needsRemove = !1;
            },
            fire: function(eventType, arg) {
                this[eventType = "on" + eventType] && this[eventType](this._target, arg);
            },
            pause: function() {
                this._paused = !0;
            },
            resume: function() {
                this._paused = !1;
            }
        };
        var _default = Clip;
        module.exports = _default;
    }, function(module, exports) {
        var easing = {
            linear: function(k) {
                return k;
            },
            quadraticIn: function(k) {
                return k * k;
            },
            quadraticOut: function(k) {
                return k * (2 - k);
            },
            quadraticInOut: function(k) {
                return (k *= 2) < 1 ? .5 * k * k : -.5 * (--k * (k - 2) - 1);
            },
            cubicIn: function(k) {
                return k * k * k;
            },
            cubicOut: function(k) {
                return --k * k * k + 1;
            },
            cubicInOut: function(k) {
                return (k *= 2) < 1 ? .5 * k * k * k : .5 * ((k -= 2) * k * k + 2);
            },
            quarticIn: function(k) {
                return k * k * k * k;
            },
            quarticOut: function(k) {
                return 1 - --k * k * k * k;
            },
            quarticInOut: function(k) {
                return (k *= 2) < 1 ? .5 * k * k * k * k : -.5 * ((k -= 2) * k * k * k - 2);
            },
            quinticIn: function(k) {
                return k * k * k * k * k;
            },
            quinticOut: function(k) {
                return --k * k * k * k * k + 1;
            },
            quinticInOut: function(k) {
                return (k *= 2) < 1 ? .5 * k * k * k * k * k : .5 * ((k -= 2) * k * k * k * k + 2);
            },
            sinusoidalIn: function(k) {
                return 1 - Math.cos(k * Math.PI / 2);
            },
            sinusoidalOut: function(k) {
                return Math.sin(k * Math.PI / 2);
            },
            sinusoidalInOut: function(k) {
                return .5 * (1 - Math.cos(Math.PI * k));
            },
            exponentialIn: function(k) {
                return 0 === k ? 0 : Math.pow(1024, k - 1);
            },
            exponentialOut: function(k) {
                return 1 === k ? 1 : 1 - Math.pow(2, -10 * k);
            },
            exponentialInOut: function(k) {
                return 0 === k ? 0 : 1 === k ? 1 : (k *= 2) < 1 ? .5 * Math.pow(1024, k - 1) : .5 * (2 - Math.pow(2, -10 * (k - 1)));
            },
            circularIn: function(k) {
                return 1 - Math.sqrt(1 - k * k);
            },
            circularOut: function(k) {
                return Math.sqrt(1 - --k * k);
            },
            circularInOut: function(k) {
                return (k *= 2) < 1 ? -.5 * (Math.sqrt(1 - k * k) - 1) : .5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
            },
            elasticIn: function(k) {
                var s, a = .1;
                return 0 === k ? 0 : 1 === k ? 1 : (!a || a < 1 ? (a = 1, s = .1) : s = .4 * Math.asin(1 / a) / (2 * Math.PI), 
                -a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / .4));
            },
            elasticOut: function(k) {
                var s, a = .1;
                return 0 === k ? 0 : 1 === k ? 1 : (!a || a < 1 ? (a = 1, s = .1) : s = .4 * Math.asin(1 / a) / (2 * Math.PI), 
                a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / .4) + 1);
            },
            elasticInOut: function(k) {
                var s, a = .1;
                return 0 === k ? 0 : 1 === k ? 1 : (!a || a < 1 ? (a = 1, s = .1) : s = .4 * Math.asin(1 / a) / (2 * Math.PI), 
                (k *= 2) < 1 ? a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / .4) * -.5 : a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / .4) * .5 + 1);
            },
            backIn: function(k) {
                var s = 1.70158;
                return k * k * ((s + 1) * k - s);
            },
            backOut: function(k) {
                var s = 1.70158;
                return --k * k * ((s + 1) * k + s) + 1;
            },
            backInOut: function(k) {
                var s = 2.5949095;
                return (k *= 2) < 1 ? k * k * ((s + 1) * k - s) * .5 : .5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
            },
            bounceIn: function(k) {
                return 1 - easing.bounceOut(1 - k);
            },
            bounceOut: function(k) {
                return k < 1 / 2.75 ? 7.5625 * k * k : k < 2 / 2.75 ? 7.5625 * (k -= 1.5 / 2.75) * k + .75 : k < 2.5 / 2.75 ? 7.5625 * (k -= 2.25 / 2.75) * k + .9375 : 7.5625 * (k -= 2.625 / 2.75) * k + .984375;
            },
            bounceInOut: function(k) {
                return k < .5 ? .5 * easing.bounceIn(2 * k) : .5 * easing.bounceOut(2 * k - 1) + .5;
            }
        }, _default = easing;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var devicePixelRatio = __webpack_require__(35).devicePixelRatio, util = __webpack_require__(0), log = __webpack_require__(92), BoundingRect = __webpack_require__(12), timsort = __webpack_require__(53), Layer = __webpack_require__(197), requestAnimationFrame = __webpack_require__(95), Image = __webpack_require__(55), env = __webpack_require__(7);
        function parseInt10(val) {
            return parseInt(val, 10);
        }
        var tmpRect = new BoundingRect(0, 0, 0, 0), viewRect = new BoundingRect(0, 0, 0, 0);
        var Painter = function(root, storage, opts) {
            this.type = "canvas";
            var singleCanvas = !root.nodeName || "CANVAS" === root.nodeName.toUpperCase();
            this._opts = opts = util.extend({}, opts || {}), this.dpr = opts.devicePixelRatio || devicePixelRatio, 
            this._singleCanvas = singleCanvas, this.root = root;
            var rootStyle = root.style;
            rootStyle && (rootStyle["-webkit-tap-highlight-color"] = "transparent", rootStyle["-webkit-user-select"] = rootStyle["user-select"] = rootStyle["-webkit-touch-callout"] = "none", 
            root.innerHTML = ""), this.storage = storage;
            var zlevelList = this._zlevelList = [], layers = this._layers = {};
            if (this._layerConfig = {}, this._needsManuallyCompositing = !1, singleCanvas) {
                var width = root.width, height = root.height;
                null != opts.width && (width = opts.width), null != opts.height && (height = opts.height), 
                this.dpr = opts.devicePixelRatio || 1, root.width = width * this.dpr, root.height = height * this.dpr, 
                this._width = width, this._height = height;
                var mainLayer = new Layer(root, this, this.dpr);
                mainLayer.__builtin__ = !0, mainLayer.initContext(), layers[314159] = mainLayer, 
                mainLayer.zlevel = 314159, zlevelList.push(314159), this._domRoot = root;
            } else {
                this._width = this._getSize(0), this._height = this._getSize(1);
                var domRoot = this._domRoot = function(width, height) {
                    var domRoot = document.createElement("div");
                    return domRoot.style.cssText = [ "position:relative", "overflow:hidden", "width:" + width + "px", "height:" + height + "px", "padding:0", "margin:0", "border-width:0" ].join(";") + ";", 
                    domRoot;
                }(this._width, this._height);
                root.appendChild(domRoot);
            }
            this._hoverlayer = null, this._hoverElements = [];
        };
        Painter.prototype = {
            constructor: Painter,
            getType: function() {
                return "canvas";
            },
            isSingleCanvas: function() {
                return this._singleCanvas;
            },
            getViewportRoot: function() {
                return this._domRoot;
            },
            getViewportRootOffset: function() {
                var viewportRoot = this.getViewportRoot();
                if (viewportRoot) return {
                    offsetLeft: viewportRoot.offsetLeft || 0,
                    offsetTop: viewportRoot.offsetTop || 0
                };
            },
            refresh: function(paintAll) {
                var list = this.storage.getDisplayList(!0), zlevelList = this._zlevelList;
                this._redrawId = Math.random(), this._paintList(list, paintAll, this._redrawId);
                for (var i = 0; i < zlevelList.length; i++) {
                    var z = zlevelList[i], layer = this._layers[z];
                    if (!layer.__builtin__ && layer.refresh) {
                        var clearColor = 0 === i ? this._backgroundColor : null;
                        layer.refresh(clearColor);
                    }
                }
                return this.refreshHover(), this;
            },
            addHover: function(el, hoverStyle) {
                if (!el.__hoverMir) {
                    var elMirror = new el.constructor({
                        style: el.style,
                        shape: el.shape,
                        z: el.z,
                        z2: el.z2,
                        silent: el.silent
                    });
                    return elMirror.__from = el, el.__hoverMir = elMirror, hoverStyle && elMirror.setStyle(hoverStyle), 
                    this._hoverElements.push(elMirror), elMirror;
                }
            },
            removeHover: function(el) {
                var elMirror = el.__hoverMir, hoverElements = this._hoverElements, idx = util.indexOf(hoverElements, elMirror);
                idx >= 0 && hoverElements.splice(idx, 1), el.__hoverMir = null;
            },
            clearHover: function(el) {
                for (var hoverElements = this._hoverElements, i = 0; i < hoverElements.length; i++) {
                    var from = hoverElements[i].__from;
                    from && (from.__hoverMir = null);
                }
                hoverElements.length = 0;
            },
            refreshHover: function() {
                var hoverElements = this._hoverElements, len = hoverElements.length, hoverLayer = this._hoverlayer;
                if (hoverLayer && hoverLayer.clear(), len) {
                    timsort(hoverElements, this.storage.displayableSortFunc), hoverLayer || (hoverLayer = this._hoverlayer = this.getLayer(1e5));
                    var scope = {};
                    hoverLayer.ctx.save();
                    for (var i = 0; i < len; ) {
                        var el = hoverElements[i], originalEl = el.__from;
                        originalEl && originalEl.__zr ? (i++, originalEl.invisible || (el.transform = originalEl.transform, 
                        el.invTransform = originalEl.invTransform, el.__clipPaths = originalEl.__clipPaths, 
                        this._doPaintEl(el, hoverLayer, !0, scope))) : (hoverElements.splice(i, 1), originalEl.__hoverMir = null, 
                        len--);
                    }
                    hoverLayer.ctx.restore();
                }
            },
            getHoverLayer: function() {
                return this.getLayer(1e5);
            },
            _paintList: function(list, paintAll, redrawId) {
                if (this._redrawId === redrawId) {
                    paintAll = paintAll || !1, this._updateLayerStatus(list);
                    var finished = this._doPaintList(list, paintAll);
                    if (this._needsManuallyCompositing && this._compositeManually(), !finished) {
                        var self = this;
                        requestAnimationFrame(function() {
                            self._paintList(list, paintAll, redrawId);
                        });
                    }
                }
            },
            _compositeManually: function() {
                var ctx = this.getLayer(314159).ctx, width = this._domRoot.width, height = this._domRoot.height;
                ctx.clearRect(0, 0, width, height), this.eachBuiltinLayer(function(layer) {
                    layer.virtual && ctx.drawImage(layer.dom, 0, 0, width, height);
                });
            },
            _doPaintList: function(list, paintAll) {
                for (var layerList = [], zi = 0; zi < this._zlevelList.length; zi++) {
                    var zlevel = this._zlevelList[zi];
                    (layer = this._layers[zlevel]).__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll) && layerList.push(layer);
                }
                for (var finished = !0, k = 0; k < layerList.length; k++) {
                    var layer, ctx = (layer = layerList[k]).ctx, scope = {};
                    ctx.save();
                    var start = paintAll ? layer.__startIndex : layer.__drawIndex, useTimer = !paintAll && layer.incremental && Date.now, startTime = useTimer && Date.now(), clearColor = layer.zlevel === this._zlevelList[0] ? this._backgroundColor : null;
                    if (layer.__startIndex === layer.__endIndex) layer.clear(!1, clearColor); else if (start === layer.__startIndex) {
                        var firstEl = list[start];
                        firstEl.incremental && firstEl.notClear && !paintAll || layer.clear(!1, clearColor);
                    }
                    -1 === start && (console.error("For some unknown reason. drawIndex is -1"), start = layer.__startIndex);
                    for (var i = start; i < layer.__endIndex; i++) {
                        var el = list[i];
                        if (this._doPaintEl(el, layer, paintAll, scope), el.__dirty = el.__dirtyText = !1, 
                        useTimer) if (Date.now() - startTime > 15) break;
                    }
                    layer.__drawIndex = i, layer.__drawIndex < layer.__endIndex && (finished = !1), 
                    scope.prevElClipPaths && ctx.restore(), ctx.restore();
                }
                return env.wxa && util.each(this._layers, function(layer) {
                    layer && layer.ctx && layer.ctx.draw && layer.ctx.draw();
                }), finished;
            },
            _doPaintEl: function(el, currentLayer, forcePaint, scope) {
                var ctx = currentLayer.ctx, m = el.transform;
                if ((currentLayer.__dirty || forcePaint) && !el.invisible && 0 !== el.style.opacity && (!m || m[0] || m[3]) && (!el.culling || !function(el, width, height) {
                    return tmpRect.copy(el.getBoundingRect()), el.transform && tmpRect.applyTransform(el.transform), 
                    viewRect.width = width, viewRect.height = height, !tmpRect.intersect(viewRect);
                }(el, this._width, this._height))) {
                    var clipPaths = el.__clipPaths, prevElClipPaths = scope.prevElClipPaths;
                    prevElClipPaths && !function(clipPaths, prevClipPaths) {
                        if (clipPaths === prevClipPaths) return !1;
                        if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) return !0;
                        for (var i = 0; i < clipPaths.length; i++) if (clipPaths[i] !== prevClipPaths[i]) return !0;
                        return !1;
                    }(clipPaths, prevElClipPaths) || (prevElClipPaths && (ctx.restore(), scope.prevElClipPaths = null, 
                    scope.prevEl = null), clipPaths && (ctx.save(), function(clipPaths, ctx) {
                        for (var i = 0; i < clipPaths.length; i++) {
                            var clipPath = clipPaths[i];
                            clipPath.setTransform(ctx), ctx.beginPath(), clipPath.buildPath(ctx, clipPath.shape), 
                            ctx.clip(), clipPath.restoreTransform(ctx);
                        }
                    }(clipPaths, ctx), scope.prevElClipPaths = clipPaths)), el.beforeBrush && el.beforeBrush(ctx), 
                    el.brush(ctx, scope.prevEl || null), scope.prevEl = el, el.afterBrush && el.afterBrush(ctx);
                }
            },
            getLayer: function(zlevel, virtual) {
                this._singleCanvas && !this._needsManuallyCompositing && (zlevel = 314159);
                var layer = this._layers[zlevel];
                return layer || ((layer = new Layer("zr_" + zlevel, this, this.dpr)).zlevel = zlevel, 
                layer.__builtin__ = !0, this._layerConfig[zlevel] && util.merge(layer, this._layerConfig[zlevel], !0), 
                virtual && (layer.virtual = virtual), this.insertLayer(zlevel, layer), layer.initContext()), 
                layer;
            },
            insertLayer: function(zlevel, layer) {
                var layersMap = this._layers, zlevelList = this._zlevelList, len = zlevelList.length, prevLayer = null, i = -1, domRoot = this._domRoot;
                if (layersMap[zlevel]) log("ZLevel " + zlevel + " has been used already"); else if (function(layer) {
                    return !!layer && (!!layer.__builtin__ || "function" == typeof layer.resize && "function" == typeof layer.refresh);
                }(layer)) {
                    if (len > 0 && zlevel > zlevelList[0]) {
                        for (i = 0; i < len - 1 && !(zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel); i++) ;
                        prevLayer = layersMap[zlevelList[i]];
                    }
                    if (zlevelList.splice(i + 1, 0, zlevel), layersMap[zlevel] = layer, !layer.virtual) if (prevLayer) {
                        var prevDom = prevLayer.dom;
                        prevDom.nextSibling ? domRoot.insertBefore(layer.dom, prevDom.nextSibling) : domRoot.appendChild(layer.dom);
                    } else domRoot.firstChild ? domRoot.insertBefore(layer.dom, domRoot.firstChild) : domRoot.appendChild(layer.dom);
                } else log("Layer of zlevel " + zlevel + " is not valid");
            },
            eachLayer: function(cb, context) {
                var z, i, zlevelList = this._zlevelList;
                for (i = 0; i < zlevelList.length; i++) z = zlevelList[i], cb.call(context, this._layers[z], z);
            },
            eachBuiltinLayer: function(cb, context) {
                var layer, z, i, zlevelList = this._zlevelList;
                for (i = 0; i < zlevelList.length; i++) z = zlevelList[i], (layer = this._layers[z]).__builtin__ && cb.call(context, layer, z);
            },
            eachOtherLayer: function(cb, context) {
                var layer, z, i, zlevelList = this._zlevelList;
                for (i = 0; i < zlevelList.length; i++) z = zlevelList[i], (layer = this._layers[z]).__builtin__ || cb.call(context, layer, z);
            },
            getLayers: function() {
                return this._layers;
            },
            _updateLayerStatus: function(list) {
                function updatePrevLayer(idx) {
                    prevLayer && (prevLayer.__endIndex !== idx && (prevLayer.__dirty = !0), prevLayer.__endIndex = idx);
                }
                if (this.eachBuiltinLayer(function(layer, z) {
                    layer.__dirty = layer.__used = !1;
                }), this._singleCanvas) for (var i = 1; i < list.length; i++) {
                    if ((el = list[i]).zlevel !== list[i - 1].zlevel || el.incremental) {
                        this._needsManuallyCompositing = !0;
                        break;
                    }
                }
                var prevLayer = null, incrementalLayerCount = 0;
                for (i = 0; i < list.length; i++) {
                    var el, layer, zlevel = (el = list[i]).zlevel;
                    el.incremental ? ((layer = this.getLayer(zlevel + .001, this._needsManuallyCompositing)).incremental = !0, 
                    incrementalLayerCount = 1) : layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? .01 : 0), this._needsManuallyCompositing), 
                    layer.__builtin__ || log("ZLevel " + zlevel + " has been used by unkown layer " + layer.id), 
                    layer !== prevLayer && (layer.__used = !0, layer.__startIndex !== i && (layer.__dirty = !0), 
                    layer.__startIndex = i, layer.incremental ? layer.__drawIndex = -1 : layer.__drawIndex = i, 
                    updatePrevLayer(i), prevLayer = layer), el.__dirty && (layer.__dirty = !0, layer.incremental && layer.__drawIndex < 0 && (layer.__drawIndex = i));
                }
                updatePrevLayer(i), this.eachBuiltinLayer(function(layer, z) {
                    !layer.__used && layer.getElementCount() > 0 && (layer.__dirty = !0, layer.__startIndex = layer.__endIndex = layer.__drawIndex = 0), 
                    layer.__dirty && layer.__drawIndex < 0 && (layer.__drawIndex = layer.__startIndex);
                });
            },
            clear: function() {
                return this.eachBuiltinLayer(this._clearLayer), this;
            },
            _clearLayer: function(layer) {
                layer.clear();
            },
            setBackgroundColor: function(backgroundColor) {
                this._backgroundColor = backgroundColor;
            },
            configLayer: function(zlevel, config) {
                if (config) {
                    var layerConfig = this._layerConfig;
                    layerConfig[zlevel] ? util.merge(layerConfig[zlevel], config, !0) : layerConfig[zlevel] = config;
                    for (var i = 0; i < this._zlevelList.length; i++) {
                        var _zlevel = this._zlevelList[i];
                        if (_zlevel === zlevel || _zlevel === zlevel + .01) {
                            var layer = this._layers[_zlevel];
                            util.merge(layer, layerConfig[zlevel], !0);
                        }
                    }
                }
            },
            delLayer: function(zlevel) {
                var layers = this._layers, zlevelList = this._zlevelList, layer = layers[zlevel];
                layer && (layer.dom.parentNode.removeChild(layer.dom), delete layers[zlevel], zlevelList.splice(util.indexOf(zlevelList, zlevel), 1));
            },
            resize: function(width, height) {
                if (this._domRoot.style) {
                    var domRoot = this._domRoot;
                    domRoot.style.display = "none";
                    var opts = this._opts;
                    if (null != width && (opts.width = width), null != height && (opts.height = height), 
                    width = this._getSize(0), height = this._getSize(1), domRoot.style.display = "", 
                    this._width !== width || height !== this._height) {
                        for (var id in domRoot.style.width = width + "px", domRoot.style.height = height + "px", 
                        this._layers) this._layers.hasOwnProperty(id) && this._layers[id].resize(width, height);
                        util.each(this._progressiveLayers, function(layer) {
                            layer.resize(width, height);
                        }), this.refresh(!0);
                    }
                    this._width = width, this._height = height;
                } else {
                    if (null == width || null == height) return;
                    this._width = width, this._height = height, this.getLayer(314159).resize(width, height);
                }
                return this;
            },
            clearLayer: function(zlevel) {
                var layer = this._layers[zlevel];
                layer && layer.clear();
            },
            dispose: function() {
                this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null;
            },
            getRenderedCanvas: function(opts) {
                if (opts = opts || {}, this._singleCanvas && !this._compositeManually) return this._layers[314159].dom;
                var imageLayer = new Layer("image", this, opts.pixelRatio || this.dpr);
                if (imageLayer.initContext(), imageLayer.clear(!1, opts.backgroundColor || this._backgroundColor), 
                opts.pixelRatio <= this.dpr) {
                    this.refresh();
                    var width = imageLayer.dom.width, height = imageLayer.dom.height, ctx = imageLayer.ctx;
                    this.eachLayer(function(layer) {
                        layer.__builtin__ ? ctx.drawImage(layer.dom, 0, 0, width, height) : layer.renderToCanvas && (imageLayer.ctx.save(), 
                        layer.renderToCanvas(imageLayer.ctx), imageLayer.ctx.restore());
                    });
                } else for (var scope = {}, displayList = this.storage.getDisplayList(!0), i = 0; i < displayList.length; i++) {
                    var el = displayList[i];
                    this._doPaintEl(el, imageLayer, !0, scope);
                }
                return imageLayer.dom;
            },
            getWidth: function() {
                return this._width;
            },
            getHeight: function() {
                return this._height;
            },
            _getSize: function(whIdx) {
                var opts = this._opts, wh = [ "width", "height" ][whIdx], cwh = [ "clientWidth", "clientHeight" ][whIdx], plt = [ "paddingLeft", "paddingTop" ][whIdx], prb = [ "paddingRight", "paddingBottom" ][whIdx];
                if (null != opts[wh] && "auto" !== opts[wh]) return parseFloat(opts[wh]);
                var root = this.root, stl = document.defaultView.getComputedStyle(root);
                return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
            },
            pathToImage: function(path, dpr) {
                dpr = dpr || this.dpr;
                var canvas = document.createElement("canvas"), ctx = canvas.getContext("2d"), rect = path.getBoundingRect(), style = path.style, shadowBlurSize = style.shadowBlur * dpr, shadowOffsetX = style.shadowOffsetX * dpr, shadowOffsetY = style.shadowOffsetY * dpr, lineWidth = style.hasStroke() ? style.lineWidth : 0, leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize), rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize), topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize), bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize), width = rect.width + leftMargin + rightMargin, height = rect.height + topMargin + bottomMargin;
                canvas.width = width * dpr, canvas.height = height * dpr, ctx.scale(dpr, dpr), ctx.clearRect(0, 0, width, height), 
                ctx.dpr = dpr;
                var pathTransform = {
                    position: path.position,
                    rotation: path.rotation,
                    scale: path.scale
                };
                path.position = [ leftMargin - rect.x, topMargin - rect.y ], path.rotation = 0, 
                path.scale = [ 1, 1 ], path.updateTransform(), path && path.brush(ctx);
                var imgShape = new Image({
                    style: {
                        x: 0,
                        y: 0,
                        image: canvas
                    }
                });
                return null != pathTransform.position && (imgShape.position = path.position = pathTransform.position), 
                null != pathTransform.rotation && (imgShape.rotation = path.rotation = pathTransform.rotation), 
                null != pathTransform.scale && (imgShape.scale = path.scale = pathTransform.scale), 
                imgShape;
            }
        };
        var _default = Painter;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var util = __webpack_require__(0), devicePixelRatio = __webpack_require__(35).devicePixelRatio, Style = __webpack_require__(54), Pattern = __webpack_require__(94);
        function returnFalse() {
            return !1;
        }
        function createDom(id, painter, dpr) {
            var newDom = util.createCanvas(), width = painter.getWidth(), height = painter.getHeight(), newDomStyle = newDom.style;
            return newDomStyle && (newDomStyle.position = "absolute", newDomStyle.left = 0, 
            newDomStyle.top = 0, newDomStyle.width = width + "px", newDomStyle.height = height + "px", 
            newDom.setAttribute("data-zr-dom-id", id)), newDom.width = width * dpr, newDom.height = height * dpr, 
            newDom;
        }
        var Layer = function(id, painter, dpr) {
            var dom;
            dpr = dpr || devicePixelRatio, "string" == typeof id ? dom = createDom(id, painter, dpr) : util.isObject(id) && (id = (dom = id).id), 
            this.id = id, this.dom = dom;
            var domStyle = dom.style;
            domStyle && (dom.onselectstart = returnFalse, domStyle["-webkit-user-select"] = "none", 
            domStyle["user-select"] = "none", domStyle["-webkit-touch-callout"] = "none", domStyle["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)", 
            domStyle.padding = 0, domStyle.margin = 0, domStyle["border-width"] = 0), this.domBack = null, 
            this.ctxBack = null, this.painter = painter, this.config = null, this.clearColor = 0, 
            this.motionBlur = !1, this.lastFrameAlpha = .7, this.dpr = dpr;
        };
        Layer.prototype = {
            constructor: Layer,
            __dirty: !0,
            __used: !1,
            __drawIndex: 0,
            __startIndex: 0,
            __endIndex: 0,
            incremental: !1,
            getElementCount: function() {
                return this.__endIndex - this.__startIndex;
            },
            initContext: function() {
                this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr;
            },
            createBackBuffer: function() {
                var dpr = this.dpr;
                this.domBack = createDom("back-" + this.id, this.painter, dpr), this.ctxBack = this.domBack.getContext("2d"), 
                1 !== dpr && this.ctxBack.scale(dpr, dpr);
            },
            resize: function(width, height) {
                var dpr = this.dpr, dom = this.dom, domStyle = dom.style, domBack = this.domBack;
                domStyle && (domStyle.width = width + "px", domStyle.height = height + "px"), dom.width = width * dpr, 
                dom.height = height * dpr, domBack && (domBack.width = width * dpr, domBack.height = height * dpr, 
                1 !== dpr && this.ctxBack.scale(dpr, dpr));
            },
            clear: function(clearAll, clearColor) {
                var clearColorGradientOrPattern, dom = this.dom, ctx = this.ctx, width = dom.width, height = dom.height, haveMotionBLur = (clearColor = clearColor || this.clearColor, 
                this.motionBlur && !clearAll), lastFrameAlpha = this.lastFrameAlpha, dpr = this.dpr;
                (haveMotionBLur && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", 
                this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr)), ctx.clearRect(0, 0, width, height), 
                clearColor && "transparent" !== clearColor) && (clearColor.colorStops ? (clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {
                    x: 0,
                    y: 0,
                    width: width,
                    height: height
                }), clearColor.__canvasGradient = clearColorGradientOrPattern) : clearColor.image && (clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx)), 
                ctx.save(), ctx.fillStyle = clearColorGradientOrPattern || clearColor, ctx.fillRect(0, 0, width, height), 
                ctx.restore());
                if (haveMotionBLur) {
                    var domBack = this.domBack;
                    ctx.save(), ctx.globalAlpha = lastFrameAlpha, ctx.drawImage(domBack, 0, 0, width, height), 
                    ctx.restore();
                }
            }
        };
        var _default = Layer;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var textHelper = __webpack_require__(96), BoundingRect = __webpack_require__(12), WILL_BE_RESTORED = __webpack_require__(36).WILL_BE_RESTORED, tmpRect = new BoundingRect(), RectText = function() {};
        RectText.prototype = {
            constructor: RectText,
            drawRectText: function(ctx, rect) {
                var style = this.style;
                rect = style.textRect || rect, this.__dirty && textHelper.normalizeTextStyle(style, !0);
                var text = style.text;
                if (null != text && (text += ""), textHelper.needDrawText(text, style)) {
                    ctx.save();
                    var transform = this.transform;
                    style.transformText ? this.setTransform(ctx) : transform && (tmpRect.copy(rect), 
                    tmpRect.applyTransform(transform), rect = tmpRect), textHelper.renderText(this, ctx, text, style, rect, WILL_BE_RESTORED), 
                    ctx.restore();
                }
            }
        };
        var _default = RectText;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var util = __webpack_require__(0), Dispatcher = __webpack_require__(15).Dispatcher, requestAnimationFrame = __webpack_require__(95), Animator = __webpack_require__(90), Animation = function(options) {
            options = options || {}, this.stage = options.stage || {}, this.onframe = options.onframe || function() {}, 
            this._clips = [], this._running = !1, this._time, this._pausedTime, this._pauseStart, 
            this._paused = !1, Dispatcher.call(this);
        };
        Animation.prototype = {
            constructor: Animation,
            addClip: function(clip) {
                this._clips.push(clip);
            },
            addAnimator: function(animator) {
                animator.animation = this;
                for (var clips = animator.getClips(), i = 0; i < clips.length; i++) this.addClip(clips[i]);
            },
            removeClip: function(clip) {
                var idx = util.indexOf(this._clips, clip);
                idx >= 0 && this._clips.splice(idx, 1);
            },
            removeAnimator: function(animator) {
                for (var clips = animator.getClips(), i = 0; i < clips.length; i++) this.removeClip(clips[i]);
                animator.animation = null;
            },
            _update: function() {
                for (var time = new Date().getTime() - this._pausedTime, delta = time - this._time, clips = this._clips, len = clips.length, deferredEvents = [], deferredClips = [], i = 0; i < len; i++) {
                    var clip = clips[i], e = clip.step(time, delta);
                    e && (deferredEvents.push(e), deferredClips.push(clip));
                }
                for (i = 0; i < len; ) clips[i]._needsRemove ? (clips[i] = clips[len - 1], clips.pop(), 
                len--) : i++;
                len = deferredEvents.length;
                for (i = 0; i < len; i++) deferredClips[i].fire(deferredEvents[i]);
                this._time = time, this.onframe(delta), this.trigger("frame", delta), this.stage.update && this.stage.update();
            },
            _startLoop: function() {
                var self = this;
                this._running = !0, requestAnimationFrame(function step() {
                    self._running && (requestAnimationFrame(step), !self._paused && self._update());
                });
            },
            start: function() {
                this._time = new Date().getTime(), this._pausedTime = 0, this._startLoop();
            },
            stop: function() {
                this._running = !1;
            },
            pause: function() {
                this._paused || (this._pauseStart = new Date().getTime(), this._paused = !0);
            },
            resume: function() {
                this._paused && (this._pausedTime += new Date().getTime() - this._pauseStart, this._paused = !1);
            },
            clear: function() {
                this._clips = [];
            },
            isFinished: function() {
                return !this._clips.length;
            },
            animate: function(target, options) {
                var animator = new Animator(target, (options = options || {}).loop, options.getter, options.setter);
                return this.addAnimator(animator), animator;
            }
        }, util.mixin(Animation, Dispatcher);
        var _default = Animation;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var _event = __webpack_require__(15), addEventListener = _event.addEventListener, removeEventListener = _event.removeEventListener, normalizeEvent = _event.normalizeEvent, zrUtil = __webpack_require__(0), Eventful = __webpack_require__(23), env = __webpack_require__(7), mouseHandlerNames = [ "click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu" ], touchHandlerNames = [ "touchstart", "touchend", "touchmove" ], pointerEventNames = {
            pointerdown: 1,
            pointerup: 1,
            pointermove: 1,
            pointerout: 1
        }, pointerHandlerNames = zrUtil.map(mouseHandlerNames, function(name) {
            var nm = name.replace("mouse", "pointer");
            return pointerEventNames[nm] ? nm : name;
        });
        function eventNameFix(name) {
            return "mousewheel" === name && env.browser.firefox ? "DOMMouseScroll" : name;
        }
        function setTouchTimer(instance) {
            instance._touching = !0, clearTimeout(instance._touchTimer), instance._touchTimer = setTimeout(function() {
                instance._touching = !1;
            }, 700);
        }
        var domHandlers = {
            mousemove: function(event) {
                event = normalizeEvent(this.dom, event), this.trigger("mousemove", event);
            },
            mouseout: function(event) {
                var element = (event = normalizeEvent(this.dom, event)).toElement || event.relatedTarget;
                if (element !== this.dom) for (;element && 9 !== element.nodeType; ) {
                    if (element === this.dom) return;
                    element = element.parentNode;
                }
                this.trigger("mouseout", event);
            },
            touchstart: function(event) {
                (event = normalizeEvent(this.dom, event)).zrByTouch = !0, this._lastTouchMoment = new Date(), 
                this.handler.processGesture(this, event, "start"), domHandlers.mousemove.call(this, event), 
                domHandlers.mousedown.call(this, event), setTouchTimer(this);
            },
            touchmove: function(event) {
                (event = normalizeEvent(this.dom, event)).zrByTouch = !0, this.handler.processGesture(this, event, "change"), 
                domHandlers.mousemove.call(this, event), setTouchTimer(this);
            },
            touchend: function(event) {
                (event = normalizeEvent(this.dom, event)).zrByTouch = !0, this.handler.processGesture(this, event, "end"), 
                domHandlers.mouseup.call(this, event), +new Date() - this._lastTouchMoment < 300 && domHandlers.click.call(this, event), 
                setTouchTimer(this);
            },
            pointerdown: function(event) {
                domHandlers.mousedown.call(this, event);
            },
            pointermove: function(event) {
                isPointerFromTouch(event) || domHandlers.mousemove.call(this, event);
            },
            pointerup: function(event) {
                domHandlers.mouseup.call(this, event);
            },
            pointerout: function(event) {
                isPointerFromTouch(event) || domHandlers.mouseout.call(this, event);
            }
        };
        function isPointerFromTouch(event) {
            var pointerType = event.pointerType;
            return "pen" === pointerType || "touch" === pointerType;
        }
        function HandlerDomProxy(dom) {
            function mountHandlers(handlerNames, instance) {
                zrUtil.each(handlerNames, function(name) {
                    addEventListener(dom, eventNameFix(name), instance._handlers[name]);
                }, instance);
            }
            Eventful.call(this), this.dom = dom, this._touching = !1, this._touchTimer, this._handlers = {}, 
            function(instance) {
                zrUtil.each(touchHandlerNames, function(name) {
                    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);
                }), zrUtil.each(pointerHandlerNames, function(name) {
                    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);
                }), zrUtil.each(mouseHandlerNames, function(name) {
                    instance._handlers[name] = function(fn, instance) {
                        return function() {
                            if (!instance._touching) return fn.apply(instance, arguments);
                        };
                    }(domHandlers[name], instance);
                });
            }(this), env.pointerEventsSupported ? mountHandlers(pointerHandlerNames, this) : (env.touchEventsSupported && mountHandlers(touchHandlerNames, this), 
            mountHandlers(mouseHandlerNames, this));
        }
        zrUtil.each([ "click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu" ], function(name) {
            domHandlers[name] = function(event) {
                event = normalizeEvent(this.dom, event), this.trigger(name, event);
            };
        });
        var handlerDomProxyProto = HandlerDomProxy.prototype;
        handlerDomProxyProto.dispose = function() {
            for (var handlerNames = mouseHandlerNames.concat(touchHandlerNames), i = 0; i < handlerNames.length; i++) {
                var name = handlerNames[i];
                removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);
            }
        }, handlerDomProxyProto.setCursor = function(cursorStyle) {
            this.dom.style && (this.dom.style.cursor = cursorStyle || "default");
        }, zrUtil.mixin(HandlerDomProxy, Eventful);
        var _default = HandlerDomProxy;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var getLineStyle = __webpack_require__(57)([ [ "lineWidth", "width" ], [ "stroke", "color" ], [ "opacity" ], [ "shadowBlur" ], [ "shadowOffsetX" ], [ "shadowOffsetY" ], [ "shadowColor" ] ]), _default = {
            getLineStyle: function(excludes) {
                var style = getLineStyle(this, excludes);
                return style.lineDash = this.getLineDash(style.lineWidth), style;
            },
            getLineDash: function(lineWidth) {
                null == lineWidth && (lineWidth = 1);
                var lineType = this.get("type"), dotSize = Math.max(lineWidth, 2), dashSize = 4 * lineWidth;
                return "solid" !== lineType && null != lineType && ("dashed" === lineType ? [ dashSize, dashSize ] : [ dotSize, dotSize ]);
            }
        };
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var getAreaStyle = __webpack_require__(57)([ [ "fill", "color" ], [ "shadowBlur" ], [ "shadowOffsetX" ], [ "shadowOffsetY" ], [ "opacity" ], [ "shadowColor" ] ]), _default = {
            getAreaStyle: function(excludes, includes) {
                return getAreaStyle(this, excludes, includes);
            }
        };
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var textContain = __webpack_require__(21), graphicUtil = __webpack_require__(2), PATH_COLOR = [ "textStyle", "color" ], _default = {
            getTextColor: function(isEmphasis) {
                var ecModel = this.ecModel;
                return this.getShallow("color") || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);
            },
            getFont: function() {
                return graphicUtil.getFont({
                    fontStyle: this.getShallow("fontStyle"),
                    fontWeight: this.getShallow("fontWeight"),
                    fontSize: this.getShallow("fontSize"),
                    fontFamily: this.getShallow("fontFamily")
                }, this.ecModel);
            },
            getTextRect: function(text) {
                return textContain.getBoundingRect(text, this.getFont(), this.getShallow("align"), this.getShallow("verticalAlign") || this.getShallow("baseline"), this.getShallow("padding"), this.getShallow("lineHeight"), this.getShallow("rich"), this.getShallow("truncateText"));
            }
        };
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var PathProxy = __webpack_require__(38), line = __webpack_require__(101), cubic = __webpack_require__(205), quadratic = __webpack_require__(102), arc = __webpack_require__(206), normalizeRadian = __webpack_require__(103).normalizeRadian, curve = __webpack_require__(22), windingLine = __webpack_require__(104), CMD = PathProxy.CMD, PI2 = 2 * Math.PI, EPSILON = 1e-4;
        var roots = [ -1, -1, -1 ], extrema = [ -1, -1 ];
        function swapExtrema() {
            var tmp = extrema[0];
            extrema[0] = extrema[1], extrema[1] = tmp;
        }
        function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
            if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) return 0;
            var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);
            if (0 === nRoots) return 0;
            for (var y0_, y1_, w = 0, nExtrema = -1, i = 0; i < nRoots; i++) {
                var t = roots[i], unit = 0 === t || 1 === t ? .5 : 1;
                curve.cubicAt(x0, x1, x2, x3, t) < x || (nExtrema < 0 && (nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema), 
                extrema[1] < extrema[0] && nExtrema > 1 && swapExtrema(), y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]), 
                nExtrema > 1 && (y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]))), 2 === nExtrema ? t < extrema[0] ? w += y0_ < y0 ? unit : -unit : t < extrema[1] ? w += y1_ < y0_ ? unit : -unit : w += y3 < y1_ ? unit : -unit : t < extrema[0] ? w += y0_ < y0 ? unit : -unit : w += y3 < y0_ ? unit : -unit);
            }
            return w;
        }
        function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
            if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) return 0;
            var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);
            if (0 === nRoots) return 0;
            var t = curve.quadraticExtremum(y0, y1, y2);
            if (t >= 0 && t <= 1) {
                for (var w = 0, y_ = curve.quadraticAt(y0, y1, y2, t), i = 0; i < nRoots; i++) {
                    var unit = 0 === roots[i] || 1 === roots[i] ? .5 : 1;
                    curve.quadraticAt(x0, x1, x2, roots[i]) < x || (roots[i] < t ? w += y_ < y0 ? unit : -unit : w += y2 < y_ ? unit : -unit);
                }
                return w;
            }
            unit = 0 === roots[0] || 1 === roots[0] ? .5 : 1;
            return curve.quadraticAt(x0, x1, x2, roots[0]) < x ? 0 : y2 < y0 ? unit : -unit;
        }
        function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
            if ((y -= cy) > r || y < -r) return 0;
            var tmp = Math.sqrt(r * r - y * y);
            roots[0] = -tmp, roots[1] = tmp;
            var diff = Math.abs(startAngle - endAngle);
            if (diff < 1e-4) return 0;
            if (diff % PI2 < 1e-4) {
                startAngle = 0, endAngle = PI2;
                var dir = anticlockwise ? 1 : -1;
                return x >= roots[0] + cx && x <= roots[1] + cx ? dir : 0;
            }
            if (anticlockwise) {
                tmp = startAngle;
                startAngle = normalizeRadian(endAngle), endAngle = normalizeRadian(tmp);
            } else startAngle = normalizeRadian(startAngle), endAngle = normalizeRadian(endAngle);
            startAngle > endAngle && (endAngle += PI2);
            for (var w = 0, i = 0; i < 2; i++) {
                var x_ = roots[i];
                if (x_ + cx > x) {
                    var angle = Math.atan2(y, x_);
                    dir = anticlockwise ? 1 : -1;
                    angle < 0 && (angle = PI2 + angle), (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) && (angle > Math.PI / 2 && angle < 1.5 * Math.PI && (dir = -dir), 
                    w += dir);
                }
            }
            return w;
        }
        function containPath(data, lineWidth, isStroke, x, y) {
            for (var w = 0, xi = 0, yi = 0, x0 = 0, y0 = 0, i = 0; i < data.length; ) {
                var cmd = data[i++];
                switch (cmd === CMD.M && i > 1 && (isStroke || (w += windingLine(xi, yi, x0, y0, x, y))), 
                1 === i && (x0 = xi = data[i], y0 = yi = data[i + 1]), cmd) {
                  case CMD.M:
                    xi = x0 = data[i++], yi = y0 = data[i++];
                    break;

                  case CMD.L:
                    if (isStroke) {
                        if (line.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) return !0;
                    } else w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
                    xi = data[i++], yi = data[i++];
                    break;

                  case CMD.C:
                    if (isStroke) {
                        if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) return !0;
                    } else w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
                    xi = data[i++], yi = data[i++];
                    break;

                  case CMD.Q:
                    if (isStroke) {
                        if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) return !0;
                    } else w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
                    xi = data[i++], yi = data[i++];
                    break;

                  case CMD.A:
                    var cx = data[i++], cy = data[i++], rx = data[i++], ry = data[i++], theta = data[i++], dTheta = data[i++];
                    i += 1;
                    var anticlockwise = 1 - data[i++], x1 = Math.cos(theta) * rx + cx, y1 = Math.sin(theta) * ry + cy;
                    i > 1 ? w += windingLine(xi, yi, x1, y1, x, y) : (x0 = x1, y0 = y1);
                    var _x = (x - cx) * ry / rx + cx;
                    if (isStroke) {
                        if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) return !0;
                    } else w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);
                    xi = Math.cos(theta + dTheta) * rx + cx, yi = Math.sin(theta + dTheta) * ry + cy;
                    break;

                  case CMD.R:
                    x0 = xi = data[i++], y0 = yi = data[i++];
                    x1 = x0 + data[i++], y1 = y0 + data[i++];
                    if (isStroke) {
                        if (line.containStroke(x0, y0, x1, y0, lineWidth, x, y) || line.containStroke(x1, y0, x1, y1, lineWidth, x, y) || line.containStroke(x1, y1, x0, y1, lineWidth, x, y) || line.containStroke(x0, y1, x0, y0, lineWidth, x, y)) return !0;
                    } else w += windingLine(x1, y0, x1, y1, x, y), w += windingLine(x0, y1, x0, y0, x, y);
                    break;

                  case CMD.Z:
                    if (isStroke) {
                        if (line.containStroke(xi, yi, x0, y0, lineWidth, x, y)) return !0;
                    } else w += windingLine(xi, yi, x0, y0, x, y);
                    xi = x0, yi = y0;
                }
            }
            return isStroke || function(a, b) {
                return Math.abs(a - b) < EPSILON;
            }(yi, y0) || (w += windingLine(xi, yi, x0, y0, x, y) || 0), 0 !== w;
        }
        exports.contain = function(pathData, x, y) {
            return containPath(pathData, 0, !1, x, y);
        }, exports.containStroke = function(pathData, lineWidth, x, y) {
            return containPath(pathData, lineWidth, !0, x, y);
        };
    }, function(module, exports, __webpack_require__) {
        var curve = __webpack_require__(22);
        exports.containStroke = function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
            if (0 === lineWidth) return !1;
            var _l = lineWidth;
            return !(y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) && curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null) <= _l / 2;
        };
    }, function(module, exports, __webpack_require__) {
        var normalizeRadian = __webpack_require__(103).normalizeRadian, PI2 = 2 * Math.PI;
        exports.containStroke = function(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
            if (0 === lineWidth) return !1;
            var _l = lineWidth;
            x -= cx, y -= cy;
            var d = Math.sqrt(x * x + y * y);
            if (d - _l > r || d + _l < r) return !1;
            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) return !0;
            if (anticlockwise) {
                var tmp = startAngle;
                startAngle = normalizeRadian(endAngle), endAngle = normalizeRadian(tmp);
            } else startAngle = normalizeRadian(startAngle), endAngle = normalizeRadian(endAngle);
            startAngle > endAngle && (endAngle += PI2);
            var angle = Math.atan2(y, x);
            return angle < 0 && (angle += PI2), angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;
        };
    }, function(module, exports, __webpack_require__) {
        var PathProxy = __webpack_require__(38), v2ApplyTransform = __webpack_require__(6).applyTransform, CMD = PathProxy.CMD, points = [ [], [], [] ], mathSqrt = Math.sqrt, mathAtan2 = Math.atan2;
        module.exports = function(path, m) {
            var cmd, nPoint, i, j, k, data = path.data, M = CMD.M, C = CMD.C, L = CMD.L, R = CMD.R, A = CMD.A, Q = CMD.Q;
            for (i = 0, j = 0; i < data.length; ) {
                switch (cmd = data[i++], j = i, nPoint = 0, cmd) {
                  case M:
                  case L:
                    nPoint = 1;
                    break;

                  case C:
                    nPoint = 3;
                    break;

                  case Q:
                    nPoint = 2;
                    break;

                  case A:
                    var x = m[4], y = m[5], sx = mathSqrt(m[0] * m[0] + m[1] * m[1]), sy = mathSqrt(m[2] * m[2] + m[3] * m[3]), angle = mathAtan2(-m[1] / sy, m[0] / sx);
                    data[i] *= sx, data[i++] += x, data[i] *= sy, data[i++] += y, data[i++] *= sx, data[i++] *= sy, 
                    data[i++] += angle, data[i++] += angle, j = i += 2;
                    break;

                  case R:
                    p[0] = data[i++], p[1] = data[i++], v2ApplyTransform(p, p, m), data[j++] = p[0], 
                    data[j++] = p[1], p[0] += data[i++], p[1] += data[i++], v2ApplyTransform(p, p, m), 
                    data[j++] = p[0], data[j++] = p[1];
                }
                for (k = 0; k < nPoint; k++) {
                    var p;
                    (p = points[k])[0] = data[i++], p[1] = data[i++], v2ApplyTransform(p, p, m), data[j++] = p[0], 
                    data[j++] = p[1];
                }
            }
        };
    }, function(module, exports, __webpack_require__) {
        var Path = __webpack_require__(8), fixClipWithShadow = __webpack_require__(106), _default = Path.extend({
            type: "sector",
            shape: {
                cx: 0,
                cy: 0,
                r0: 0,
                r: 0,
                startAngle: 0,
                endAngle: 2 * Math.PI,
                clockwise: !0
            },
            brush: fixClipWithShadow(Path.prototype.brush),
            buildPath: function(ctx, shape) {
                var x = shape.cx, y = shape.cy, r0 = Math.max(shape.r0 || 0, 0), r = Math.max(shape.r, 0), startAngle = shape.startAngle, endAngle = shape.endAngle, clockwise = shape.clockwise, unitX = Math.cos(startAngle), unitY = Math.sin(startAngle);
                ctx.moveTo(unitX * r0 + x, unitY * r0 + y), ctx.lineTo(unitX * r + x, unitY * r + y), 
                ctx.arc(x, y, r, startAngle, endAngle, !clockwise), ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y), 
                0 !== r0 && ctx.arc(x, y, r0, endAngle, startAngle, clockwise), ctx.closePath();
            }
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var _default = __webpack_require__(8).extend({
            type: "ring",
            shape: {
                cx: 0,
                cy: 0,
                r: 0,
                r0: 0
            },
            buildPath: function(ctx, shape) {
                var x = shape.cx, y = shape.cy, PI2 = 2 * Math.PI;
                ctx.moveTo(x + shape.r, y), ctx.arc(x, y, shape.r, 0, PI2, !1), ctx.moveTo(x + shape.r0, y), 
                ctx.arc(x, y, shape.r0, 0, PI2, !0);
            }
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var v2Distance = __webpack_require__(6).distance;
        function interpolate(p0, p1, p2, p3, t, t2, t3) {
            var v0 = .5 * (p2 - p0), v1 = .5 * (p3 - p1);
            return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
        }
        module.exports = function(points, isLoop) {
            for (var len = points.length, ret = [], distance = 0, i = 1; i < len; i++) distance += v2Distance(points[i - 1], points[i]);
            var segs = distance / 2;
            for (segs = segs < len ? len : segs, i = 0; i < segs; i++) {
                var p0, p2, p3, pos = i / (segs - 1) * (isLoop ? len : len - 1), idx = Math.floor(pos), w = pos - idx, p1 = points[idx % len];
                isLoop ? (p0 = points[(idx - 1 + len) % len], p2 = points[(idx + 1) % len], p3 = points[(idx + 2) % len]) : (p0 = points[0 === idx ? idx : idx - 1], 
                p2 = points[idx > len - 2 ? len - 1 : idx + 1], p3 = points[idx > len - 3 ? len - 1 : idx + 2]);
                var w2 = w * w, w3 = w * w2;
                ret.push([ interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3) ]);
            }
            return ret;
        };
    }, function(module, exports, __webpack_require__) {
        var _vector = __webpack_require__(6), v2Min = _vector.min, v2Max = _vector.max, v2Scale = _vector.scale, v2Distance = _vector.distance, v2Add = _vector.add, v2Clone = _vector.clone, v2Sub = _vector.sub;
        module.exports = function(points, smooth, isLoop, constraint) {
            var prevPoint, nextPoint, min, max, cps = [], v = [], v1 = [], v2 = [];
            if (constraint) {
                min = [ 1 / 0, 1 / 0 ], max = [ -1 / 0, -1 / 0 ];
                for (var i = 0, len = points.length; i < len; i++) v2Min(min, min, points[i]), v2Max(max, max, points[i]);
                v2Min(min, min, constraint[0]), v2Max(max, max, constraint[1]);
            }
            for (i = 0, len = points.length; i < len; i++) {
                var point = points[i];
                if (isLoop) prevPoint = points[i ? i - 1 : len - 1], nextPoint = points[(i + 1) % len]; else {
                    if (0 === i || i === len - 1) {
                        cps.push(v2Clone(points[i]));
                        continue;
                    }
                    prevPoint = points[i - 1], nextPoint = points[i + 1];
                }
                v2Sub(v, nextPoint, prevPoint), v2Scale(v, v, smooth);
                var d0 = v2Distance(point, prevPoint), d1 = v2Distance(point, nextPoint), sum = d0 + d1;
                0 !== sum && (d0 /= sum, d1 /= sum), v2Scale(v1, v, -d0), v2Scale(v2, v, d1);
                var cp0 = v2Add([], point, v1), cp1 = v2Add([], point, v2);
                constraint && (v2Max(cp0, cp0, min), v2Min(cp0, cp0, max), v2Max(cp1, cp1, min), 
                v2Min(cp1, cp1, max)), cps.push(cp0), cps.push(cp1);
            }
            return isLoop && cps.push(cps.shift()), cps;
        };
    }, function(module, exports, __webpack_require__) {
        var Path = __webpack_require__(8), vec2 = __webpack_require__(6), _curve = __webpack_require__(22), quadraticSubdivide = _curve.quadraticSubdivide, cubicSubdivide = _curve.cubicSubdivide, quadraticAt = _curve.quadraticAt, cubicAt = _curve.cubicAt, quadraticDerivativeAt = _curve.quadraticDerivativeAt, cubicDerivativeAt = _curve.cubicDerivativeAt, out = [];
        function someVectorAt(shape, t, isTangent) {
            var cpx2 = shape.cpx2, cpy2 = shape.cpy2;
            return null === cpx2 || null === cpy2 ? [ (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t) ] : [ (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t) ];
        }
        var _default = Path.extend({
            type: "bezier-curve",
            shape: {
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 0,
                cpx1: 0,
                cpy1: 0,
                percent: 1
            },
            style: {
                stroke: "#000",
                fill: null
            },
            buildPath: function(ctx, shape) {
                var x1 = shape.x1, y1 = shape.y1, x2 = shape.x2, y2 = shape.y2, cpx1 = shape.cpx1, cpy1 = shape.cpy1, cpx2 = shape.cpx2, cpy2 = shape.cpy2, percent = shape.percent;
                0 !== percent && (ctx.moveTo(x1, y1), null == cpx2 || null == cpy2 ? (percent < 1 && (quadraticSubdivide(x1, cpx1, x2, percent, out), 
                cpx1 = out[1], x2 = out[2], quadraticSubdivide(y1, cpy1, y2, percent, out), cpy1 = out[1], 
                y2 = out[2]), ctx.quadraticCurveTo(cpx1, cpy1, x2, y2)) : (percent < 1 && (cubicSubdivide(x1, cpx1, cpx2, x2, percent, out), 
                cpx1 = out[1], cpx2 = out[2], x2 = out[3], cubicSubdivide(y1, cpy1, cpy2, y2, percent, out), 
                cpy1 = out[1], cpy2 = out[2], y2 = out[3]), ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2)));
            },
            pointAt: function(t) {
                return someVectorAt(this.shape, t, !1);
            },
            tangentAt: function(t) {
                var p = someVectorAt(this.shape, t, !0);
                return vec2.normalize(p, p);
            }
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var _default = __webpack_require__(8).extend({
            type: "arc",
            shape: {
                cx: 0,
                cy: 0,
                r: 0,
                startAngle: 0,
                endAngle: 2 * Math.PI,
                clockwise: !0
            },
            style: {
                stroke: "#000",
                fill: null
            },
            buildPath: function(ctx, shape) {
                var x = shape.cx, y = shape.cy, r = Math.max(shape.r, 0), startAngle = shape.startAngle, endAngle = shape.endAngle, clockwise = shape.clockwise, unitX = Math.cos(startAngle), unitY = Math.sin(startAngle);
                ctx.moveTo(unitX * r + x, unitY * r + y), ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
            }
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var Path = __webpack_require__(8), _default = Path.extend({
            type: "compound",
            shape: {
                paths: null
            },
            _updatePathDirty: function() {
                for (var dirtyPath = this.__dirtyPath, paths = this.shape.paths, i = 0; i < paths.length; i++) dirtyPath = dirtyPath || paths[i].__dirtyPath;
                this.__dirtyPath = dirtyPath, this.__dirty = this.__dirty || dirtyPath;
            },
            beforeBrush: function() {
                this._updatePathDirty();
                for (var paths = this.shape.paths || [], scale = this.getGlobalScale(), i = 0; i < paths.length; i++) paths[i].path || paths[i].createPathProxy(), 
                paths[i].path.setScale(scale[0], scale[1], paths[i].segmentIgnoreThreshold);
            },
            buildPath: function(ctx, shape) {
                for (var paths = shape.paths || [], i = 0; i < paths.length; i++) paths[i].buildPath(ctx, paths[i].shape, !0);
            },
            afterBrush: function() {
                for (var paths = this.shape.paths || [], i = 0; i < paths.length; i++) paths[i].__dirtyPath = !1;
            },
            getBoundingRect: function() {
                return this._updatePathDirty(), Path.prototype.getBoundingRect.call(this);
            }
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), Gradient = __webpack_require__(61), RadialGradient = function(x, y, r, colorStops, globalCoord) {
            this.x = null == x ? .5 : x, this.y = null == y ? .5 : y, this.r = null == r ? .5 : r, 
            this.type = "radial", this.global = globalCoord || !1, Gradient.call(this, colorStops);
        };
        RadialGradient.prototype = {
            constructor: RadialGradient
        }, zrUtil.inherits(RadialGradient, Gradient);
        var _default = RadialGradient;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var getItemStyle = __webpack_require__(57)([ [ "fill", "color" ], [ "stroke", "borderColor" ], [ "lineWidth", "borderWidth" ], [ "opacity" ], [ "shadowBlur" ], [ "shadowOffsetX" ], [ "shadowOffsetY" ], [ "shadowColor" ], [ "textPosition" ], [ "textAlign" ] ]), _default = {
            getItemStyle: function(excludes, includes) {
                var style = getItemStyle(this, excludes, includes), lineDash = this.getBorderLineDash();
                return lineDash && (style.lineDash = lineDash), style;
            },
            getBorderLineDash: function() {
                var lineType = this.get("borderType");
                return "solid" === lineType || null == lineType ? null : "dashed" === lineType ? [ 5, 5 ] : [ 1, 1 ];
            }
        };
        module.exports = _default;
    }, function(module, exports) {
        module.exports = {
            getBoxLayoutParams: function() {
                return {
                    left: this.get("left"),
                    top: this.get("top"),
                    right: this.get("right"),
                    bottom: this.get("bottom"),
                    width: this.get("width"),
                    height: this.get("height")
                };
            }
        };
    }, function(module, exports) {
        var platform = "";
        "undefined" != typeof navigator && (platform = navigator.platform || "");
        var _default = {
            color: [ "#c23531", "#2f4554", "#61a0a8", "#d48265", "#91c7ae", "#749f83", "#ca8622", "#bda29a", "#6e7074", "#546570", "#c4ccd3" ],
            gradientColor: [ "#f6efa6", "#d88273", "#bf444c" ],
            textStyle: {
                fontFamily: platform.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
                fontSize: 12,
                fontStyle: "normal",
                fontWeight: "normal"
            },
            blendMode: null,
            animation: "auto",
            animationDuration: 1e3,
            animationDurationUpdate: 300,
            animationEasing: "exponentialOut",
            animationEasingUpdate: "cubicOut",
            animationThreshold: 2e3,
            progressiveThreshold: 3e3,
            progressive: 400,
            hoverLayerThreshold: 3e3,
            useUTC: !1
        };
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), modelUtil = __webpack_require__(3), ComponentModel = __webpack_require__(13), each = zrUtil.each, clone = zrUtil.clone, map = zrUtil.map, merge = zrUtil.merge, QUERY_REG = /^(min|max)?(.+)$/;
        function OptionManager(api) {
            this._api = api, this._timelineOptions = [], this._mediaList = [], this._mediaDefault, 
            this._currentMediaIndices = [], this._optionBackup, this._newBaseOption;
        }
        function applyMediaQuery(query, ecWidth, ecHeight) {
            var realMap = {
                width: ecWidth,
                height: ecHeight,
                aspectratio: ecWidth / ecHeight
            }, applicatable = !0;
            return zrUtil.each(query, function(value, attr) {
                var matched = attr.match(QUERY_REG);
                if (matched && matched[1] && matched[2]) {
                    var operator = matched[1], realAttr = matched[2].toLowerCase();
                    (function(real, expect, operator) {
                        return "min" === operator ? real >= expect : "max" === operator ? real <= expect : real === expect;
                    })(realMap[realAttr], value, operator) || (applicatable = !1);
                }
            }), applicatable;
        }
        OptionManager.prototype = {
            constructor: OptionManager,
            setOption: function(rawOption, optionPreprocessorFuncs) {
                rawOption && zrUtil.each(modelUtil.normalizeToArray(rawOption.series), function(series) {
                    series && series.data && zrUtil.isTypedArray(series.data) && zrUtil.setAsPrimitive(series.data);
                }), rawOption = clone(rawOption);
                var oldOptionBackup = this._optionBackup, newParsedOption = function(rawOption, optionPreprocessorFuncs, isNew) {
                    var mediaDefault, baseOption, timelineOptions = [], mediaList = [], timelineOpt = rawOption.timeline;
                    rawOption.baseOption && (baseOption = rawOption.baseOption);
                    (timelineOpt || rawOption.options) && (baseOption = baseOption || {}, timelineOptions = (rawOption.options || []).slice());
                    if (rawOption.media) {
                        baseOption = baseOption || {};
                        var media = rawOption.media;
                        each(media, function(singleMedia) {
                            singleMedia && singleMedia.option && (singleMedia.query ? mediaList.push(singleMedia) : mediaDefault || (mediaDefault = singleMedia));
                        });
                    }
                    baseOption || (baseOption = rawOption);
                    baseOption.timeline || (baseOption.timeline = timelineOpt);
                    return each([ baseOption ].concat(timelineOptions).concat(zrUtil.map(mediaList, function(media) {
                        return media.option;
                    })), function(option) {
                        each(optionPreprocessorFuncs, function(preProcess) {
                            preProcess(option, isNew);
                        });
                    }), {
                        baseOption: baseOption,
                        timelineOptions: timelineOptions,
                        mediaDefault: mediaDefault,
                        mediaList: mediaList
                    };
                }.call(this, rawOption, optionPreprocessorFuncs, !oldOptionBackup);
                this._newBaseOption = newParsedOption.baseOption, oldOptionBackup ? (!function(oldOption, newOption) {
                    each(newOption = newOption || {}, function(newCptOpt, mainType) {
                        if (null != newCptOpt) {
                            var oldCptOpt = oldOption[mainType];
                            if (ComponentModel.hasClass(mainType)) {
                                newCptOpt = modelUtil.normalizeToArray(newCptOpt), oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);
                                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);
                                oldOption[mainType] = map(mapResult, function(item) {
                                    return item.option && item.exist ? merge(item.exist, item.option, !0) : item.exist || item.option;
                                });
                            } else oldOption[mainType] = merge(oldCptOpt, newCptOpt, !0);
                        }
                    });
                }(oldOptionBackup.baseOption, newParsedOption.baseOption), newParsedOption.timelineOptions.length && (oldOptionBackup.timelineOptions = newParsedOption.timelineOptions), 
                newParsedOption.mediaList.length && (oldOptionBackup.mediaList = newParsedOption.mediaList), 
                newParsedOption.mediaDefault && (oldOptionBackup.mediaDefault = newParsedOption.mediaDefault)) : this._optionBackup = newParsedOption;
            },
            mountOption: function(isRecreate) {
                var optionBackup = this._optionBackup;
                return this._timelineOptions = map(optionBackup.timelineOptions, clone), this._mediaList = map(optionBackup.mediaList, clone), 
                this._mediaDefault = clone(optionBackup.mediaDefault), this._currentMediaIndices = [], 
                clone(isRecreate ? optionBackup.baseOption : this._newBaseOption);
            },
            getTimelineOption: function(ecModel) {
                var option, timelineOptions = this._timelineOptions;
                if (timelineOptions.length) {
                    var timelineModel = ecModel.getComponent("timeline");
                    timelineModel && (option = clone(timelineOptions[timelineModel.getCurrentIndex()], !0));
                }
                return option;
            },
            getMediaOption: function(ecModel) {
                var ecWidth = this._api.getWidth(), ecHeight = this._api.getHeight(), mediaList = this._mediaList, mediaDefault = this._mediaDefault, indices = [], result = [];
                if (!mediaList.length && !mediaDefault) return result;
                for (var i = 0, len = mediaList.length; i < len; i++) applyMediaQuery(mediaList[i].query, ecWidth, ecHeight) && indices.push(i);
                return !indices.length && mediaDefault && (indices = [ -1 ]), indices.length && !function(indices1, indices2) {
                    return indices1.join(",") === indices2.join(",");
                }(indices, this._currentMediaIndices) && (result = map(indices, function(index) {
                    return clone(-1 === index ? mediaDefault.option : mediaList[index].option);
                })), this._currentMediaIndices = indices, result;
            }
        };
        var _default = OptionManager;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var _util = __webpack_require__(0), each = _util.each, isArray = _util.isArray, isObject = _util.isObject, compatStyle = __webpack_require__(221), normalizeToArray = __webpack_require__(3).normalizeToArray;
        function compatLayoutProperties(option) {
            each(LAYOUT_PROPERTIES, function(prop) {
                prop[0] in option && !(prop[1] in option) && (option[prop[1]] = option[prop[0]]);
            });
        }
        var LAYOUT_PROPERTIES = [ [ "x", "left" ], [ "y", "top" ], [ "x2", "right" ], [ "y2", "bottom" ] ], COMPATITABLE_COMPONENTS = [ "grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline" ];
        module.exports = function(option, isTheme) {
            compatStyle(option, isTheme), option.series = normalizeToArray(option.series), each(option.series, function(seriesOpt) {
                if (isObject(seriesOpt)) {
                    var seriesType = seriesOpt.type;
                    if ("pie" !== seriesType && "gauge" !== seriesType || null != seriesOpt.clockWise && (seriesOpt.clockwise = seriesOpt.clockWise), 
                    "gauge" === seriesType) {
                        var pointerColor = function(opt, path) {
                            path = path.split(",");
                            for (var obj = opt, i = 0; i < path.length && null != (obj = obj && obj[path[i]]); i++) ;
                            return obj;
                        }(seriesOpt, "pointer.color");
                        null != pointerColor && function(opt, path, val, overwrite) {
                            path = path.split(",");
                            for (var key, obj = opt, i = 0; i < path.length - 1; i++) null == obj[key = path[i]] && (obj[key] = {}), 
                            obj = obj[key];
                            (overwrite || null == obj[path[i]]) && (obj[path[i]] = val);
                        }(seriesOpt, "itemStyle.color", pointerColor);
                    }
                    compatLayoutProperties(seriesOpt);
                }
            }), option.dataRange && (option.visualMap = option.dataRange), each(COMPATITABLE_COMPONENTS, function(componentName) {
                var options = option[componentName];
                options && (isArray(options) || (options = [ options ]), each(options, function(option) {
                    compatLayoutProperties(option);
                }));
            });
        };
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), modelUtil = __webpack_require__(3), each = zrUtil.each, isObject = zrUtil.isObject, POSSIBLE_STYLES = [ "areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine" ];
        function compatEC2ItemStyle(opt) {
            var itemStyleOpt = opt && opt.itemStyle;
            if (itemStyleOpt) for (var i = 0, len = POSSIBLE_STYLES.length; i < len; i++) {
                var styleName = POSSIBLE_STYLES[i], normalItemStyleOpt = itemStyleOpt.normal, emphasisItemStyleOpt = itemStyleOpt.emphasis;
                normalItemStyleOpt && normalItemStyleOpt[styleName] && (opt[styleName] = opt[styleName] || {}, 
                opt[styleName].normal ? zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]) : opt[styleName].normal = normalItemStyleOpt[styleName], 
                normalItemStyleOpt[styleName] = null), emphasisItemStyleOpt && emphasisItemStyleOpt[styleName] && (opt[styleName] = opt[styleName] || {}, 
                opt[styleName].emphasis ? zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]) : opt[styleName].emphasis = emphasisItemStyleOpt[styleName], 
                emphasisItemStyleOpt[styleName] = null);
            }
        }
        function convertNormalEmphasis(opt, optType, useExtend) {
            if (opt && opt[optType] && (opt[optType].normal || opt[optType].emphasis)) {
                var normalOpt = opt[optType].normal, emphasisOpt = opt[optType].emphasis;
                normalOpt && (useExtend ? (opt[optType].normal = opt[optType].emphasis = null, zrUtil.defaults(opt[optType], normalOpt)) : opt[optType] = normalOpt), 
                emphasisOpt && (opt.emphasis = opt.emphasis || {}, opt.emphasis[optType] = emphasisOpt);
            }
        }
        function removeEC3NormalStatus(opt) {
            convertNormalEmphasis(opt, "itemStyle"), convertNormalEmphasis(opt, "lineStyle"), 
            convertNormalEmphasis(opt, "areaStyle"), convertNormalEmphasis(opt, "label"), convertNormalEmphasis(opt, "labelLine"), 
            convertNormalEmphasis(opt, "upperLabel"), convertNormalEmphasis(opt, "edgeLabel");
        }
        function compatTextStyle(opt, propName) {
            var labelOptSingle = isObject(opt) && opt[propName], textStyle = isObject(labelOptSingle) && labelOptSingle.textStyle;
            if (textStyle) for (var i = 0, len = modelUtil.TEXT_STYLE_OPTIONS.length; i < len; i++) {
                propName = modelUtil.TEXT_STYLE_OPTIONS[i];
                textStyle.hasOwnProperty(propName) && (labelOptSingle[propName] = textStyle[propName]);
            }
        }
        function compatEC3CommonStyles(opt) {
            opt && (removeEC3NormalStatus(opt), compatTextStyle(opt, "label"), opt.emphasis && compatTextStyle(opt.emphasis, "label"));
        }
        function toArr(o) {
            return zrUtil.isArray(o) ? o : o ? [ o ] : [];
        }
        function toObj(o) {
            return (zrUtil.isArray(o) ? o[0] : o) || {};
        }
        module.exports = function(option, isTheme) {
            each(toArr(option.series), function(seriesOpt) {
                isObject(seriesOpt) && function(seriesOpt) {
                    if (isObject(seriesOpt)) {
                        compatEC2ItemStyle(seriesOpt), removeEC3NormalStatus(seriesOpt), compatTextStyle(seriesOpt, "label"), 
                        compatTextStyle(seriesOpt, "upperLabel"), compatTextStyle(seriesOpt, "edgeLabel"), 
                        seriesOpt.emphasis && (compatTextStyle(seriesOpt.emphasis, "label"), compatTextStyle(seriesOpt.emphasis, "upperLabel"), 
                        compatTextStyle(seriesOpt.emphasis, "edgeLabel")), (markPoint = seriesOpt.markPoint) && (compatEC2ItemStyle(markPoint), 
                        compatEC3CommonStyles(markPoint)), (markLine = seriesOpt.markLine) && (compatEC2ItemStyle(markLine), 
                        compatEC3CommonStyles(markLine));
                        var markArea = seriesOpt.markArea;
                        markArea && compatEC3CommonStyles(markArea);
                        var markPoint, markLine, data = seriesOpt.data;
                        if ("graph" === seriesOpt.type) {
                            data = data || seriesOpt.nodes;
                            var edgeData = seriesOpt.links || seriesOpt.edges;
                            if (edgeData && !zrUtil.isTypedArray(edgeData)) for (var i = 0; i < edgeData.length; i++) compatEC3CommonStyles(edgeData[i]);
                            zrUtil.each(seriesOpt.categories, function(opt) {
                                removeEC3NormalStatus(opt);
                            });
                        }
                        if (data && !zrUtil.isTypedArray(data)) for (i = 0; i < data.length; i++) compatEC3CommonStyles(data[i]);
                        if ((markPoint = seriesOpt.markPoint) && markPoint.data) {
                            var mpData = markPoint.data;
                            for (i = 0; i < mpData.length; i++) compatEC3CommonStyles(mpData[i]);
                        }
                        if ((markLine = seriesOpt.markLine) && markLine.data) {
                            var mlData = markLine.data;
                            for (i = 0; i < mlData.length; i++) zrUtil.isArray(mlData[i]) ? (compatEC3CommonStyles(mlData[i][0]), 
                            compatEC3CommonStyles(mlData[i][1])) : compatEC3CommonStyles(mlData[i]);
                        }
                        "gauge" === seriesOpt.type ? (compatTextStyle(seriesOpt, "axisLabel"), compatTextStyle(seriesOpt, "title"), 
                        compatTextStyle(seriesOpt, "detail")) : "treemap" === seriesOpt.type ? (convertNormalEmphasis(seriesOpt.breadcrumb, "itemStyle"), 
                        zrUtil.each(seriesOpt.levels, function(opt) {
                            removeEC3NormalStatus(opt);
                        })) : "tree" === seriesOpt.type && removeEC3NormalStatus(seriesOpt.leaves);
                    }
                }(seriesOpt);
            });
            var axes = [ "xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar" ];
            isTheme && axes.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), each(axes, function(axisName) {
                each(toArr(option[axisName]), function(axisOpt) {
                    axisOpt && (compatTextStyle(axisOpt, "axisLabel"), compatTextStyle(axisOpt.axisPointer, "label"));
                });
            }), each(toArr(option.parallel), function(parallelOpt) {
                var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;
                compatTextStyle(parallelAxisDefault, "axisLabel"), compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, "label");
            }), each(toArr(option.calendar), function(calendarOpt) {
                convertNormalEmphasis(calendarOpt, "itemStyle"), compatTextStyle(calendarOpt, "dayLabel"), 
                compatTextStyle(calendarOpt, "monthLabel"), compatTextStyle(calendarOpt, "yearLabel");
            }), each(toArr(option.radar), function(radarOpt) {
                compatTextStyle(radarOpt, "name");
            }), each(toArr(option.geo), function(geoOpt) {
                isObject(geoOpt) && (compatEC3CommonStyles(geoOpt), each(toArr(geoOpt.regions), function(regionObj) {
                    compatEC3CommonStyles(regionObj);
                }));
            }), each(toArr(option.timeline), function(timelineOpt) {
                compatEC3CommonStyles(timelineOpt), convertNormalEmphasis(timelineOpt, "label"), 
                convertNormalEmphasis(timelineOpt, "itemStyle"), convertNormalEmphasis(timelineOpt, "controlStyle", !0);
                var data = timelineOpt.data;
                zrUtil.isArray(data) && zrUtil.each(data, function(item) {
                    zrUtil.isObject(item) && (convertNormalEmphasis(item, "label"), convertNormalEmphasis(item, "itemStyle"));
                });
            }), each(toArr(option.toolbox), function(toolboxOpt) {
                convertNormalEmphasis(toolboxOpt, "iconStyle"), each(toolboxOpt.feature, function(featureOpt) {
                    convertNormalEmphasis(featureOpt, "iconStyle");
                });
            }), compatTextStyle(toObj(option.axisPointer), "label"), compatTextStyle(toObj(option.tooltip).axisPointer, "label");
        };
    }, function(module, exports, __webpack_require__) {
        var _util = __webpack_require__(0), createHashMap = _util.createHashMap, each = _util.each;
        function calculateStack(stackInfoList) {
            each(stackInfoList, function(targetStackInfo, idxInStack) {
                var resultVal = [], resultNaN = [ NaN, NaN ], dims = [ targetStackInfo.stackResultDimension, targetStackInfo.stackedOverDimension ], targetData = targetStackInfo.data, isStackedByIndex = targetStackInfo.isStackedByIndex, newData = targetData.map(dims, function(v0, v1, dataIndex) {
                    var byValue, stackedDataRawIndex, sum = targetData.get(targetStackInfo.stackedDimension, dataIndex);
                    if (isNaN(sum)) return resultNaN;
                    isStackedByIndex ? stackedDataRawIndex = targetData.getRawIndex(dataIndex) : byValue = targetData.get(targetStackInfo.stackedByDimension, dataIndex);
                    for (var stackedOver = NaN, j = idxInStack - 1; j >= 0; j--) {
                        var stackInfo = stackInfoList[j];
                        if (isStackedByIndex || (stackedDataRawIndex = stackInfo.data.rawIndexOf(stackInfo.stackedByDimension, byValue)), 
                        stackedDataRawIndex >= 0) {
                            var val = stackInfo.data.getByRawIndex(stackInfo.stackResultDimension, stackedDataRawIndex);
                            if (sum >= 0 && val > 0 || sum <= 0 && val < 0) {
                                sum += val, stackedOver = val;
                                break;
                            }
                        }
                    }
                    return resultVal[0] = sum, resultVal[1] = stackedOver, resultVal;
                });
                targetData.hostModel.setData(newData), targetStackInfo.data = newData;
            });
        }
        module.exports = function(ecModel) {
            var stackInfoMap = createHashMap();
            ecModel.eachSeries(function(seriesModel) {
                var stack = seriesModel.get("stack");
                if (stack) {
                    var stackInfoList = stackInfoMap.get(stack) || stackInfoMap.set(stack, []), data = seriesModel.getData(), stackInfo = {
                        stackResultDimension: data.getCalculationInfo("stackResultDimension"),
                        stackedOverDimension: data.getCalculationInfo("stackedOverDimension"),
                        stackedDimension: data.getCalculationInfo("stackedDimension"),
                        stackedByDimension: data.getCalculationInfo("stackedByDimension"),
                        isStackedByIndex: data.getCalculationInfo("isStackedByIndex"),
                        data: data,
                        seriesModel: seriesModel
                    };
                    if (!stackInfo.stackedDimension || !stackInfo.isStackedByIndex && !stackInfo.stackedByDimension) return;
                    stackInfoList.length && data.setCalculationInfo("stackedOnSeries", stackInfoList[stackInfoList.length - 1].seriesModel), 
                    stackInfoList.push(stackInfo);
                }
            }), stackInfoMap.each(calculateStack);
        };
    }, function(module, exports, __webpack_require__) {
        var Gradient = __webpack_require__(61), _default = {
            createOnAllSeries: !0,
            performRawSeries: !0,
            reset: function(seriesModel, ecModel) {
                var data = seriesModel.getData(), colorAccessPath = (seriesModel.visualColorAccessPath || "itemStyle.color").split("."), color = seriesModel.get(colorAccessPath) || seriesModel.getColorFromPalette(seriesModel.name, null, ecModel.getSeriesCount());
                if (data.setVisual("color", color), !ecModel.isSeriesFiltered(seriesModel)) {
                    "function" != typeof color || color instanceof Gradient || data.each(function(idx) {
                        data.setItemVisual(idx, "color", color(seriesModel.getDataParams(idx)));
                    });
                    return {
                        dataEach: data.hasItemOption ? function(data, idx) {
                            var color = data.getItemModel(idx).get(colorAccessPath, !0);
                            null != color && data.setItemVisual(idx, "color", color);
                        } : null
                    };
                }
            }
        };
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), lang = __webpack_require__(225), retrieveRawValue = __webpack_require__(30).retrieveRawValue;
        module.exports = function(dom, ecModel) {
            var ariaModel = ecModel.getModel("aria");
            if (ariaModel.get("show")) if (ariaModel.get("description")) dom.setAttribute("aria-label", ariaModel.get("description")); else {
                var seriesCnt = 0;
                ecModel.eachSeries(function(seriesModel, idx) {
                    ++seriesCnt;
                }, this);
                var ariaLabel, maxDataCnt = ariaModel.get("data.maxCount") || 10, maxSeriesCnt = ariaModel.get("series.maxCount") || 10, displaySeriesCnt = Math.min(seriesCnt, maxSeriesCnt);
                if (!(seriesCnt < 1)) {
                    var title = function() {
                        var title = ecModel.getModel("title").option;
                        return title && title.length && (title = title[0]), title && title.text;
                    }();
                    ariaLabel = title ? replace(getConfig("general.withTitle"), {
                        title: title
                    }) : getConfig("general.withoutTitle");
                    var seriesLabels = [];
                    ariaLabel += replace(getConfig(seriesCnt > 1 ? "series.multiple.prefix" : "series.single.prefix"), {
                        seriesCount: seriesCnt
                    }), ecModel.eachSeries(function(seriesModel, idx) {
                        if (idx < displaySeriesCnt) {
                            var seriesLabel, seriesName = seriesModel.get("name"), seriesTpl = "series." + (seriesCnt > 1 ? "multiple" : "single") + ".";
                            seriesLabel = replace(seriesLabel = getConfig(seriesName ? seriesTpl + "withName" : seriesTpl + "withoutName"), {
                                seriesId: seriesModel.seriesIndex,
                                seriesName: seriesModel.get("name"),
                                seriesType: function(type) {
                                    return lang.series.typeNames[type] || "自定义图";
                                }(seriesModel.subType)
                            });
                            var data = seriesModel.getData();
                            window.data = data, data.count() > maxDataCnt ? seriesLabel += replace(getConfig("data.partialData"), {
                                displayCnt: maxDataCnt
                            }) : seriesLabel += getConfig("data.allData");
                            for (var dataLabels = [], i = 0; i < data.count(); i++) if (i < maxDataCnt) {
                                var name = data.getName(i), value = retrieveRawValue(data, i);
                                dataLabels.push(replace(getConfig(name ? "data.withName" : "data.withoutName"), {
                                    name: name,
                                    value: value
                                }));
                            }
                            seriesLabel += dataLabels.join(getConfig("data.separator.middle")) + getConfig("data.separator.end"), 
                            seriesLabels.push(seriesLabel);
                        }
                    }), ariaLabel += seriesLabels.join(getConfig("series.multiple.separator.middle")) + getConfig("series.multiple.separator.end"), 
                    dom.setAttribute("aria-label", ariaLabel);
                }
            }
            function replace(str, keyValues) {
                if ("string" != typeof str) return str;
                var result = str;
                return zrUtil.each(keyValues, function(value, key) {
                    result = result.replace(new RegExp("\\{\\s*" + key + "\\s*\\}", "g"), value);
                }), result;
            }
            function getConfig(path) {
                var userConfig = ariaModel.get(path);
                if (null == userConfig) {
                    for (var pathArr = path.split("."), result = lang.aria, i = 0; i < pathArr.length; ++i) result = result[pathArr[i]];
                    return result;
                }
                return userConfig;
            }
        };
    }, function(module, exports) {
        module.exports = {
            toolbox: {
                brush: {
                    title: {
                        rect: "矩形选择",
                        polygon: "圈选",
                        lineX: "横向选择",
                        lineY: "纵向选择",
                        keep: "保持选择",
                        clear: "清除选择"
                    }
                },
                dataView: {
                    title: "数据视图",
                    lang: [ "数据视图", "关闭", "刷新" ]
                },
                dataZoom: {
                    title: {
                        zoom: "区域缩放",
                        back: "区域缩放还原"
                    }
                },
                magicType: {
                    title: {
                        line: "切换为折线图",
                        bar: "切换为柱状图",
                        stack: "切换为堆叠",
                        tiled: "切换为平铺"
                    }
                },
                restore: {
                    title: "还原"
                },
                saveAsImage: {
                    title: "保存为图片",
                    lang: [ "右键另存为图片" ]
                }
            },
            series: {
                typeNames: {
                    pie: "饼图",
                    bar: "柱状图",
                    line: "折线图",
                    scatter: "散点图",
                    effectScatter: "涟漪散点图",
                    radar: "雷达图",
                    tree: "树图",
                    treemap: "矩形树图",
                    boxplot: "箱型图",
                    candlestick: "K线图",
                    k: "K线图",
                    heatmap: "热力图",
                    map: "地图",
                    parallel: "平行坐标图",
                    lines: "线图",
                    graph: "关系图",
                    sankey: "桑基图",
                    funnel: "漏斗图",
                    gauge: "仪表盘图",
                    pictorialBar: "象形柱图",
                    themeRiver: "主题河流图",
                    sunburst: "旭日图"
                }
            },
            aria: {
                general: {
                    withTitle: "这是一个关于“{title}”的图表。",
                    withoutTitle: "这是一个图表，"
                },
                series: {
                    single: {
                        prefix: "",
                        withName: "图表类型是{seriesType}，表示{seriesName}。",
                        withoutName: "图表类型是{seriesType}。"
                    },
                    multiple: {
                        prefix: "它由{seriesCount}个图表系列组成。",
                        withName: "第{seriesId}个系列是一个表示{seriesName}的{seriesType}，",
                        withoutName: "第{seriesId}个系列是一个{seriesType}，",
                        separator: {
                            middle: "；",
                            end: "。"
                        }
                    }
                },
                data: {
                    allData: "其数据是——",
                    partialData: "其中，前{displayCnt}项是——",
                    withName: "{name}的数据是{value}",
                    withoutName: "{value}",
                    separator: {
                        middle: "，",
                        end: ""
                    }
                }
            }
        };
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), graphic = __webpack_require__(2), PI = Math.PI;
        module.exports = function(api, opts) {
            opts = opts || {}, zrUtil.defaults(opts, {
                text: "loading",
                color: "#c23531",
                textColor: "#000",
                maskColor: "rgba(255, 255, 255, 0.8)",
                zlevel: 0
            });
            var mask = new graphic.Rect({
                style: {
                    fill: opts.maskColor
                },
                zlevel: opts.zlevel,
                z: 1e4
            }), arc = new graphic.Arc({
                shape: {
                    startAngle: -PI / 2,
                    endAngle: -PI / 2 + .1,
                    r: 10
                },
                style: {
                    stroke: opts.color,
                    lineCap: "round",
                    lineWidth: 5
                },
                zlevel: opts.zlevel,
                z: 10001
            }), labelRect = new graphic.Rect({
                style: {
                    fill: "none",
                    text: opts.text,
                    textPosition: "right",
                    textDistance: 10,
                    textFill: opts.textColor
                },
                zlevel: opts.zlevel,
                z: 10001
            });
            arc.animateShape(!0).when(1e3, {
                endAngle: 3 * PI / 2
            }).start("circularInOut"), arc.animateShape(!0).when(1e3, {
                startAngle: 3 * PI / 2
            }).delay(300).start("circularInOut");
            var group = new graphic.Group();
            return group.add(arc), group.add(labelRect), group.add(mask), group.resize = function() {
                var cx = api.getWidth() / 2, cy = api.getHeight() / 2;
                arc.setShape({
                    cx: cx,
                    cy: cy
                });
                var r = arc.shape.r;
                labelRect.setShape({
                    x: cx - r,
                    y: cy - r,
                    width: 2 * r,
                    height: 2 * r
                }), mask.setShape({
                    x: 0,
                    y: 0,
                    width: api.getWidth(),
                    height: api.getHeight()
                });
            }, group.resize(), group;
        };
    }, function(module, exports, __webpack_require__) {
        var _util = __webpack_require__(0), each = _util.each, map = _util.map, isFunction = _util.isFunction, createHashMap = _util.createHashMap, noop = _util.noop, createTask = __webpack_require__(63).createTask, getUID = __webpack_require__(39).getUID, GlobalModel = __webpack_require__(98), ExtensionAPI = __webpack_require__(114), normalizeToArray = __webpack_require__(3).normalizeToArray;
        function Scheduler(ecInstance, api, dataProcessorHandlers, visualHandlers) {
            this.ecInstance = ecInstance, this.api = api, this.unfinished;
            dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice(), 
            visualHandlers = this._visualHandlers = visualHandlers.slice();
            this._allHandlers = dataProcessorHandlers.concat(visualHandlers), this._stageTaskMap = createHashMap();
        }
        var proto = Scheduler.prototype;
        function performStageTasks(scheduler, stageHandlers, ecModel, payload, opt) {
            var unfinished;
            function needSetDirty(opt, task) {
                return opt.setDirty && (!opt.dirtyMap || opt.dirtyMap.get(task.__pipeline.id));
            }
            opt = opt || {}, each(stageHandlers, function(stageHandler, idx) {
                if (!opt.visualType || opt.visualType === stageHandler.visualType) {
                    var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid), seriesTaskMap = stageHandlerRecord.seriesTaskMap, overallTask = stageHandlerRecord.overallTask;
                    if (overallTask) {
                        var overallNeedDirty, agentStubMap = overallTask.agentStubMap;
                        agentStubMap.each(function(stub) {
                            needSetDirty(opt, stub) && (stub.dirty(), overallNeedDirty = !0);
                        }), overallNeedDirty && overallTask.dirty(), updatePayload(overallTask, payload);
                        var performArgs = scheduler.getPerformArgs(overallTask, opt.block);
                        agentStubMap.each(function(stub) {
                            stub.perform(performArgs);
                        }), unfinished |= overallTask.perform(performArgs);
                    } else seriesTaskMap && seriesTaskMap.each(function(task, pipelineId) {
                        needSetDirty(opt, task) && task.dirty();
                        var performArgs = scheduler.getPerformArgs(task, opt.block);
                        performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model), 
                        updatePayload(task, payload), unfinished |= task.perform(performArgs);
                    });
                }
            }), scheduler.unfinished |= unfinished;
        }
        proto.restoreData = function(ecModel, payload) {
            ecModel.restoreData(payload), this._stageTaskMap.each(function(taskRecord) {
                var overallTask = taskRecord.overallTask;
                overallTask && overallTask.dirty();
            });
        }, proto.getPerformArgs = function(task, isBlock) {
            if (task.__pipeline) {
                var pipeline = this._pipelineMap.get(task.__pipeline.id), pCtx = pipeline.context, step = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex ? pipeline.step : null, modDataCount = pCtx && pCtx.modDataCount;
                return {
                    step: step,
                    modBy: null != modDataCount ? Math.ceil(modDataCount / step) : null,
                    modDataCount: modDataCount
                };
            }
        }, proto.getPipeline = function(pipelineId) {
            return this._pipelineMap.get(pipelineId);
        }, proto.updateStreamModes = function(seriesModel, view) {
            var pipeline = this._pipelineMap.get(seriesModel.uid), dataLen = seriesModel.getData().count(), progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold, large = seriesModel.get("large") && dataLen >= seriesModel.get("largeThreshold"), modDataCount = "mod" === seriesModel.get("progressiveChunkMode") ? dataLen : null;
            seriesModel.pipelineContext = pipeline.context = {
                progressiveRender: progressiveRender,
                modDataCount: modDataCount,
                large: large
            };
        }, proto.restorePipelines = function(ecModel) {
            var scheduler = this, pipelineMap = scheduler._pipelineMap = createHashMap();
            ecModel.eachSeries(function(seriesModel) {
                var progressive = seriesModel.getProgressive(), pipelineId = seriesModel.uid;
                pipelineMap.set(pipelineId, {
                    id: pipelineId,
                    head: null,
                    tail: null,
                    threshold: seriesModel.getProgressiveThreshold(),
                    progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),
                    blockIndex: -1,
                    step: Math.round(progressive || 700),
                    count: 0
                }), pipe(scheduler, seriesModel, seriesModel.dataTask);
            });
        }, proto.prepareStageTasks = function() {
            var stageTaskMap = this._stageTaskMap, ecModel = this.ecInstance.getModel(), api = this.api;
            each(this._allHandlers, function(handler) {
                var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, []);
                handler.reset && function(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {
                    var seriesTaskMap = stageHandlerRecord.seriesTaskMap || (stageHandlerRecord.seriesTaskMap = createHashMap()), seriesType = stageHandler.seriesType, getTargetSeries = stageHandler.getTargetSeries;
                    stageHandler.createOnAllSeries ? ecModel.eachRawSeries(create) : seriesType ? ecModel.eachRawSeriesByType(seriesType, create) : getTargetSeries && getTargetSeries(ecModel, api).each(create);
                    function create(seriesModel) {
                        var pipelineId = seriesModel.uid, task = seriesTaskMap.get(pipelineId) || seriesTaskMap.set(pipelineId, createTask({
                            plan: seriesTaskPlan,
                            reset: seriesTaskReset,
                            count: seriesTaskCount
                        }));
                        task.context = {
                            model: seriesModel,
                            ecModel: ecModel,
                            api: api,
                            useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,
                            plan: stageHandler.plan,
                            reset: stageHandler.reset,
                            scheduler: scheduler
                        }, pipe(scheduler, seriesModel, task);
                    }
                    var pipelineMap = scheduler._pipelineMap;
                    seriesTaskMap.each(function(task, pipelineId) {
                        pipelineMap.get(pipelineId) || (task.dispose(), seriesTaskMap.removeKey(pipelineId));
                    });
                }(this, handler, record, ecModel, api), handler.overallReset && function(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {
                    var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask || createTask({
                        reset: overallTaskReset
                    });
                    overallTask.context = {
                        ecModel: ecModel,
                        api: api,
                        overallReset: stageHandler.overallReset,
                        scheduler: scheduler
                    };
                    var agentStubMap = overallTask.agentStubMap = overallTask.agentStubMap || createHashMap(), seriesType = stageHandler.seriesType, getTargetSeries = stageHandler.getTargetSeries, overallProgress = !0, modifyOutputEnd = stageHandler.modifyOutputEnd;
                    seriesType ? ecModel.eachRawSeriesByType(seriesType, createStub) : getTargetSeries ? getTargetSeries(ecModel, api).each(createStub) : (overallProgress = !1, 
                    each(ecModel.getSeries(), createStub));
                    function createStub(seriesModel) {
                        var pipelineId = seriesModel.uid, stub = agentStubMap.get(pipelineId);
                        stub || (stub = agentStubMap.set(pipelineId, createTask({
                            reset: stubReset,
                            onDirty: stubOnDirty
                        })), overallTask.dirty()), stub.context = {
                            model: seriesModel,
                            overallProgress: overallProgress,
                            modifyOutputEnd: modifyOutputEnd
                        }, stub.agent = overallTask, stub.__block = overallProgress, pipe(scheduler, seriesModel, stub);
                    }
                    var pipelineMap = scheduler._pipelineMap;
                    agentStubMap.each(function(stub, pipelineId) {
                        pipelineMap.get(pipelineId) || (stub.dispose(), overallTask.dirty(), agentStubMap.removeKey(pipelineId));
                    });
                }(this, handler, record, ecModel, api);
            }, this);
        }, proto.prepareView = function(view, model, ecModel, api) {
            var renderTask = view.renderTask, context = renderTask.context;
            context.model = model, context.ecModel = ecModel, context.api = api, renderTask.__block = !view.incrementalPrepareRender, 
            pipe(this, model, renderTask);
        }, proto.performDataProcessorTasks = function(ecModel, payload) {
            performStageTasks(this, this._dataProcessorHandlers, ecModel, payload, {
                block: !0
            });
        }, proto.performVisualTasks = function(ecModel, payload, opt) {
            performStageTasks(this, this._visualHandlers, ecModel, payload, opt);
        }, proto.performSeriesTasks = function(ecModel) {
            var unfinished;
            ecModel.eachSeries(function(seriesModel) {
                unfinished |= seriesModel.dataTask.perform();
            }), this.unfinished |= unfinished;
        }, proto.plan = function() {
            this._pipelineMap.each(function(pipeline) {
                var task = pipeline.tail;
                do {
                    if (task.__block) {
                        pipeline.blockIndex = task.__idxInPipeline;
                        break;
                    }
                    task = task.getUpstream();
                } while (task);
            });
        };
        var updatePayload = proto.updatePayload = function(task, payload) {
            "remain" !== payload && (task.context.payload = payload);
        };
        function overallTaskReset(context) {
            context.overallReset(context.ecModel, context.api, context.payload);
        }
        function stubReset(context, upstreamContext) {
            return context.overallProgress && stubProgress;
        }
        function stubProgress() {
            this.agent.dirty(), this.getDownstream().dirty();
        }
        function stubOnDirty() {
            this.agent && this.agent.dirty();
        }
        function seriesTaskPlan(context) {
            return context.plan && context.plan(context.model, context.ecModel, context.api, context.payload);
        }
        function seriesTaskReset(context) {
            context.useClearVisual && context.data.clearAllVisual();
            var resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));
            return resetDefines.length > 1 ? map(resetDefines, function(v, idx) {
                return makeSeriesTaskProgress(idx);
            }) : singleSeriesTaskProgress;
        }
        var singleSeriesTaskProgress = makeSeriesTaskProgress(0);
        function makeSeriesTaskProgress(resetDefineIdx) {
            return function(params, context) {
                var data = context.data, resetDefine = context.resetDefines[resetDefineIdx];
                if (resetDefine && resetDefine.dataEach) for (var i = params.start; i < params.end; i++) resetDefine.dataEach(data, i); else resetDefine && resetDefine.progress && resetDefine.progress(params, data);
            };
        }
        function seriesTaskCount(context) {
            return context.data.count();
        }
        function pipe(scheduler, seriesModel, task) {
            var pipelineId = seriesModel.uid, pipeline = scheduler._pipelineMap.get(pipelineId);
            !pipeline.head && (pipeline.head = task), pipeline.tail && pipeline.tail.pipe(task), 
            pipeline.tail = task, task.__idxInPipeline = pipeline.count++, task.__pipeline = pipeline;
        }
        Scheduler.wrapStageHandler = function(stageHandler, visualType) {
            return isFunction(stageHandler) && (stageHandler = {
                overallReset: stageHandler,
                seriesType: function(legacyFunc) {
                    seriesType = null;
                    try {
                        legacyFunc(ecModelMock, apiMock);
                    } catch (e) {}
                    return seriesType;
                }(stageHandler)
            }), stageHandler.uid = getUID("stageHandler"), visualType && (stageHandler.visualType = visualType), 
            stageHandler;
        };
        var seriesType, ecModelMock = {}, apiMock = {};
        function mockMethods(target, Clz) {
            for (var name in Clz.prototype) target[name] = noop;
        }
        mockMethods(ecModelMock, GlobalModel), mockMethods(apiMock, ExtensionAPI), ecModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function(type) {
            seriesType = type;
        }, ecModelMock.eachComponent = function(cond) {
            "series" === cond.mainType && cond.subType && (seriesType = cond.subType);
        };
        var _default = Scheduler;
        module.exports = _default;
    }, function(module, exports) {
        var colorAll = [ "#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF" ], _default = {
            color: colorAll,
            colorLayer: [ [ "#37A2DA", "#ffd85c", "#fd7b5f" ], [ "#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5" ], [ "#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF" ], colorAll ]
        };
        module.exports = _default;
    }, function(module, exports) {
        var colorPalette = [ "#dd6b66", "#759aa0", "#e69d87", "#8dc1a9", "#ea7e53", "#eedd78", "#73a373", "#73b9bc", "#7289ab", "#91ca8c", "#f49f42" ], theme = {
            color: colorPalette,
            backgroundColor: "#333",
            tooltip: {
                axisPointer: {
                    lineStyle: {
                        color: "#eee"
                    },
                    crossStyle: {
                        color: "#eee"
                    }
                }
            },
            legend: {
                textStyle: {
                    color: "#eee"
                }
            },
            textStyle: {
                color: "#eee"
            },
            title: {
                textStyle: {
                    color: "#eee"
                }
            },
            toolbox: {
                iconStyle: {
                    normal: {
                        borderColor: "#eee"
                    }
                }
            },
            dataZoom: {
                textStyle: {
                    color: "#eee"
                }
            },
            visualMap: {
                textStyle: {
                    color: "#eee"
                }
            },
            timeline: {
                lineStyle: {
                    color: "#eee"
                },
                itemStyle: {
                    normal: {
                        color: colorPalette[1]
                    }
                },
                label: {
                    normal: {
                        textStyle: {
                            color: "#eee"
                        }
                    }
                },
                controlStyle: {
                    normal: {
                        color: "#eee",
                        borderColor: "#eee"
                    }
                }
            },
            timeAxis: {
                axisLine: {
                    lineStyle: {
                        color: "#eee"
                    }
                },
                axisTick: {
                    lineStyle: {
                        color: "#eee"
                    }
                },
                axisLabel: {
                    textStyle: {
                        color: "#eee"
                    }
                },
                splitLine: {
                    lineStyle: {
                        type: "dashed",
                        color: "#aaa"
                    }
                },
                splitArea: {
                    areaStyle: {
                        color: "#eee"
                    }
                }
            },
            logAxis: {
                axisLine: {
                    lineStyle: {
                        color: "#eee"
                    }
                },
                axisTick: {
                    lineStyle: {
                        color: "#eee"
                    }
                },
                axisLabel: {
                    textStyle: {
                        color: "#eee"
                    }
                },
                splitLine: {
                    lineStyle: {
                        type: "dashed",
                        color: "#aaa"
                    }
                },
                splitArea: {
                    areaStyle: {
                        color: "#eee"
                    }
                }
            },
            valueAxis: {
                axisLine: {
                    lineStyle: {
                        color: "#eee"
                    }
                },
                axisTick: {
                    lineStyle: {
                        color: "#eee"
                    }
                },
                axisLabel: {
                    textStyle: {
                        color: "#eee"
                    }
                },
                splitLine: {
                    lineStyle: {
                        type: "dashed",
                        color: "#aaa"
                    }
                },
                splitArea: {
                    areaStyle: {
                        color: "#eee"
                    }
                }
            },
            categoryAxis: {
                axisLine: {
                    lineStyle: {
                        color: "#eee"
                    }
                },
                axisTick: {
                    lineStyle: {
                        color: "#eee"
                    }
                },
                axisLabel: {
                    textStyle: {
                        color: "#eee"
                    }
                },
                splitLine: {
                    lineStyle: {
                        type: "dashed",
                        color: "#aaa"
                    }
                },
                splitArea: {
                    areaStyle: {
                        color: "#eee"
                    }
                }
            },
            line: {
                symbol: "circle"
            },
            graph: {
                color: colorPalette
            },
            gauge: {
                title: {
                    textStyle: {
                        color: "#eee"
                    }
                }
            },
            candlestick: {
                itemStyle: {
                    normal: {
                        color: "#FD1050",
                        color0: "#0CF49B",
                        borderColor: "#FD1050",
                        borderColor0: "#0CF49B"
                    }
                }
            }
        };
        theme.categoryAxis.splitLine.show = !1;
        var _default = theme;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var ComponentModel = __webpack_require__(13), ComponentView = __webpack_require__(64), detectSourceFormat = __webpack_require__(40).detectSourceFormat, SERIES_LAYOUT_BY_COLUMN = __webpack_require__(29).SERIES_LAYOUT_BY_COLUMN;
        ComponentModel.extend({
            type: "dataset",
            defaultOption: {
                seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
                sourceHeader: null,
                dimensions: null,
                source: null
            },
            optionUpdated: function() {
                detectSourceFormat(this);
            }
        }), ComponentView.extend({
            type: "dataset"
        });
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(5).__DEV__;
        var _util = __webpack_require__(0), createHashMap = _util.createHashMap, isString = _util.isString, isArray = _util.isArray, each = _util.each, parseXML = (_util.assert, 
        __webpack_require__(232).parseXML), storage = createHashMap(), _default = {
            registerMap: function(mapName, rawGeoJson, rawSpecialAreas) {
                var records;
                return isArray(rawGeoJson) ? records = rawGeoJson : rawGeoJson.svg ? records = [ {
                    type: "svg",
                    source: rawGeoJson.svg,
                    specialAreas: rawGeoJson.specialAreas
                } ] : (rawGeoJson.geoJson && !rawGeoJson.features && (rawSpecialAreas = rawGeoJson.specialAreas, 
                rawGeoJson = rawGeoJson.geoJson), records = [ {
                    type: "geoJSON",
                    source: rawGeoJson,
                    specialAreas: rawSpecialAreas
                } ]), each(records, function(record) {
                    var type = record.type;
                    "geoJson" === type && (type = record.type = "geoJSON"), (0, parsers[type])(record);
                }), storage.set(mapName, records);
            },
            retrieveMap: function(mapName) {
                return storage.get(mapName);
            }
        }, parsers = {
            geoJSON: function(record) {
                var source = record.source;
                record.geoJSON = isString(source) ? "undefined" != typeof JSON && JSON.parse ? JSON.parse(source) : new Function("return (" + source + ");")() : source;
            },
            svg: function(record) {
                record.svgXML = parseXML(record.source);
            }
        };
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var Group = __webpack_require__(27), ZImage = __webpack_require__(55), Text = __webpack_require__(58), Circle = __webpack_require__(105), Rect = __webpack_require__(110), Ellipse = __webpack_require__(233), Line = __webpack_require__(111), Path = __webpack_require__(8), Polygon = __webpack_require__(107), Polyline = __webpack_require__(109), LinearGradient = __webpack_require__(60), Style = __webpack_require__(54), matrix = __webpack_require__(17), createFromString = __webpack_require__(99).createFromString, _util = __webpack_require__(0), isString = _util.isString, extend = _util.extend, defaults = _util.defaults, trim = _util.trim, each = _util.each, DILIMITER_REG = /[\s,]+/;
        function parseXML(svg) {
            isString(svg) && (svg = new DOMParser().parseFromString(svg, "text/xml"));
            for (9 === svg.nodeType && (svg = svg.firstChild); "svg" !== svg.nodeName.toLowerCase() || 1 !== svg.nodeType; ) svg = svg.nextSibling;
            return svg;
        }
        function SVGParser() {
            this._defs = {}, this._root = null, this._isDefine = !1, this._isText = !1;
        }
        SVGParser.prototype.parse = function(xml, opt) {
            opt = opt || {};
            var svg = parseXML(xml);
            if (!svg) throw new Error("Illegal svg");
            var root = new Group();
            this._root = root;
            var viewBox = svg.getAttribute("viewBox") || "", width = parseFloat(svg.getAttribute("width") || opt.width), height = parseFloat(svg.getAttribute("height") || opt.height);
            isNaN(width) && (width = null), isNaN(height) && (height = null), parseAttributes(svg, root, null, !0);
            for (var viewBoxRect, viewBoxTransform, child = svg.firstChild; child; ) this._parseNode(child, root), 
            child = child.nextSibling;
            if (viewBox) {
                var viewBoxArr = trim(viewBox).split(DILIMITER_REG);
                viewBoxArr.length >= 4 && (viewBoxRect = {
                    x: parseFloat(viewBoxArr[0] || 0),
                    y: parseFloat(viewBoxArr[1] || 0),
                    width: parseFloat(viewBoxArr[2]),
                    height: parseFloat(viewBoxArr[3])
                });
            }
            if (viewBoxRect && null != width && null != height && (viewBoxTransform = makeViewBoxTransform(viewBoxRect, width, height), 
            !opt.ignoreViewBox)) {
                var elRoot = root;
                (root = new Group()).add(elRoot), elRoot.scale = viewBoxTransform.scale.slice(), 
                elRoot.position = viewBoxTransform.position.slice();
            }
            return opt.ignoreRootClip || null == width || null == height || root.setClipPath(new Rect({
                shape: {
                    x: 0,
                    y: 0,
                    width: width,
                    height: height
                }
            })), {
                root: root,
                width: width,
                height: height,
                viewBoxRect: viewBoxRect,
                viewBoxTransform: viewBoxTransform
            };
        }, SVGParser.prototype._parseNode = function(xmlNode, parentGroup) {
            var el, parser, nodeName = xmlNode.nodeName.toLowerCase();
            if ("defs" === nodeName ? this._isDefine = !0 : "text" === nodeName && (this._isText = !0), 
            this._isDefine) {
                if (parser = defineParsers[nodeName]) {
                    var def = parser.call(this, xmlNode), id = xmlNode.getAttribute("id");
                    id && (this._defs[id] = def);
                }
            } else (parser = nodeParsers[nodeName]) && (el = parser.call(this, xmlNode, parentGroup), 
            parentGroup.add(el));
            for (var child = xmlNode.firstChild; child; ) 1 === child.nodeType && this._parseNode(child, el), 
            3 === child.nodeType && this._isText && this._parseText(child, el), child = child.nextSibling;
            "defs" === nodeName ? this._isDefine = !1 : "text" === nodeName && (this._isText = !1);
        }, SVGParser.prototype._parseText = function(xmlNode, parentGroup) {
            if (1 === xmlNode.nodeType) {
                var dx = xmlNode.getAttribute("dx") || 0, dy = xmlNode.getAttribute("dy") || 0;
                this._textX += parseFloat(dx), this._textY += parseFloat(dy);
            }
            var text = new Text({
                style: {
                    text: xmlNode.textContent,
                    transformText: !0
                },
                position: [ this._textX || 0, this._textY || 0 ]
            });
            inheritStyle(parentGroup, text), parseAttributes(xmlNode, text, this._defs);
            var fontSize = text.style.fontSize;
            fontSize && fontSize < 9 && (text.style.fontSize = 9, text.scale = text.scale || [ 1, 1 ], 
            text.scale[0] *= fontSize / 9, text.scale[1] *= fontSize / 9);
            var rect = text.getBoundingRect();
            return this._textX += rect.width, parentGroup.add(text), text;
        };
        var nodeParsers = {
            g: function(xmlNode, parentGroup) {
                var g = new Group();
                return inheritStyle(parentGroup, g), parseAttributes(xmlNode, g, this._defs), g;
            },
            rect: function(xmlNode, parentGroup) {
                var rect = new Rect();
                return inheritStyle(parentGroup, rect), parseAttributes(xmlNode, rect, this._defs), 
                rect.setShape({
                    x: parseFloat(xmlNode.getAttribute("x") || 0),
                    y: parseFloat(xmlNode.getAttribute("y") || 0),
                    width: parseFloat(xmlNode.getAttribute("width") || 0),
                    height: parseFloat(xmlNode.getAttribute("height") || 0)
                }), rect;
            },
            circle: function(xmlNode, parentGroup) {
                var circle = new Circle();
                return inheritStyle(parentGroup, circle), parseAttributes(xmlNode, circle, this._defs), 
                circle.setShape({
                    cx: parseFloat(xmlNode.getAttribute("cx") || 0),
                    cy: parseFloat(xmlNode.getAttribute("cy") || 0),
                    r: parseFloat(xmlNode.getAttribute("r") || 0)
                }), circle;
            },
            line: function(xmlNode, parentGroup) {
                var line = new Line();
                return inheritStyle(parentGroup, line), parseAttributes(xmlNode, line, this._defs), 
                line.setShape({
                    x1: parseFloat(xmlNode.getAttribute("x1") || 0),
                    y1: parseFloat(xmlNode.getAttribute("y1") || 0),
                    x2: parseFloat(xmlNode.getAttribute("x2") || 0),
                    y2: parseFloat(xmlNode.getAttribute("y2") || 0)
                }), line;
            },
            ellipse: function(xmlNode, parentGroup) {
                var ellipse = new Ellipse();
                return inheritStyle(parentGroup, ellipse), parseAttributes(xmlNode, ellipse, this._defs), 
                ellipse.setShape({
                    cx: parseFloat(xmlNode.getAttribute("cx") || 0),
                    cy: parseFloat(xmlNode.getAttribute("cy") || 0),
                    rx: parseFloat(xmlNode.getAttribute("rx") || 0),
                    ry: parseFloat(xmlNode.getAttribute("ry") || 0)
                }), ellipse;
            },
            polygon: function(xmlNode, parentGroup) {
                var points = xmlNode.getAttribute("points");
                points && (points = parsePoints(points));
                var polygon = new Polygon({
                    shape: {
                        points: points || []
                    }
                });
                return inheritStyle(parentGroup, polygon), parseAttributes(xmlNode, polygon, this._defs), 
                polygon;
            },
            polyline: function(xmlNode, parentGroup) {
                var path = new Path();
                inheritStyle(parentGroup, path), parseAttributes(xmlNode, path, this._defs);
                var points = xmlNode.getAttribute("points");
                return points && (points = parsePoints(points)), new Polyline({
                    shape: {
                        points: points || []
                    }
                });
            },
            image: function(xmlNode, parentGroup) {
                var img = new ZImage();
                return inheritStyle(parentGroup, img), parseAttributes(xmlNode, img, this._defs), 
                img.setStyle({
                    image: xmlNode.getAttribute("xlink:href"),
                    x: xmlNode.getAttribute("x"),
                    y: xmlNode.getAttribute("y"),
                    width: xmlNode.getAttribute("width"),
                    height: xmlNode.getAttribute("height")
                }), img;
            },
            text: function(xmlNode, parentGroup) {
                var x = xmlNode.getAttribute("x") || 0, y = xmlNode.getAttribute("y") || 0, dx = xmlNode.getAttribute("dx") || 0, dy = xmlNode.getAttribute("dy") || 0;
                this._textX = parseFloat(x) + parseFloat(dx), this._textY = parseFloat(y) + parseFloat(dy);
                var g = new Group();
                return inheritStyle(parentGroup, g), parseAttributes(xmlNode, g, this._defs), g;
            },
            tspan: function(xmlNode, parentGroup) {
                var x = xmlNode.getAttribute("x"), y = xmlNode.getAttribute("y");
                null != x && (this._textX = parseFloat(x)), null != y && (this._textY = parseFloat(y));
                var dx = xmlNode.getAttribute("dx") || 0, dy = xmlNode.getAttribute("dy") || 0, g = new Group();
                return inheritStyle(parentGroup, g), parseAttributes(xmlNode, g, this._defs), this._textX += dx, 
                this._textY += dy, g;
            },
            path: function(xmlNode, parentGroup) {
                var d = xmlNode.getAttribute("d") || "", path = createFromString(d);
                return inheritStyle(parentGroup, path), parseAttributes(xmlNode, path, this._defs), 
                path;
            }
        }, defineParsers = {
            lineargradient: function(xmlNode) {
                var x1 = parseInt(xmlNode.getAttribute("x1") || 0, 10), y1 = parseInt(xmlNode.getAttribute("y1") || 0, 10), x2 = parseInt(xmlNode.getAttribute("x2") || 10, 10), y2 = parseInt(xmlNode.getAttribute("y2") || 0, 10), gradient = new LinearGradient(x1, y1, x2, y2);
                return function(xmlNode, gradient) {
                    var stop = xmlNode.firstChild;
                    for (;stop; ) {
                        if (1 === stop.nodeType) {
                            var offset = stop.getAttribute("offset");
                            offset = offset.indexOf("%") > 0 ? parseInt(offset, 10) / 100 : offset ? parseFloat(offset) : 0;
                            var stopColor = stop.getAttribute("stop-color") || "#000000";
                            gradient.addColorStop(offset, stopColor);
                        }
                        stop = stop.nextSibling;
                    }
                }(xmlNode, gradient), gradient;
            },
            radialgradient: function(xmlNode) {}
        };
        function inheritStyle(parent, child) {
            parent && parent.__inheritedStyle && (child.__inheritedStyle || (child.__inheritedStyle = {}), 
            defaults(child.__inheritedStyle, parent.__inheritedStyle));
        }
        function parsePoints(pointsString) {
            for (var list = trim(pointsString).split(DILIMITER_REG), points = [], i = 0; i < list.length; i += 2) {
                var x = parseFloat(list[i]), y = parseFloat(list[i + 1]);
                points.push([ x, y ]);
            }
            return points;
        }
        var attributesMap = {
            fill: "fill",
            stroke: "stroke",
            "stroke-width": "lineWidth",
            opacity: "opacity",
            "fill-opacity": "fillOpacity",
            "stroke-opacity": "strokeOpacity",
            "stroke-dasharray": "lineDash",
            "stroke-dashoffset": "lineDashOffset",
            "stroke-linecap": "lineCap",
            "stroke-linejoin": "lineJoin",
            "stroke-miterlimit": "miterLimit",
            "font-family": "fontFamily",
            "font-size": "fontSize",
            "font-style": "fontStyle",
            "font-weight": "fontWeight",
            "text-align": "textAlign",
            "alignment-baseline": "textBaseline"
        };
        function parseAttributes(xmlNode, el, defs, onlyInlineStyle) {
            var zrStyle = el.__inheritedStyle || {}, isTextEl = "text" === el.type;
            if (1 === xmlNode.nodeType && (function(xmlNode, node) {
                var transform = xmlNode.getAttribute("transform");
                if (transform) {
                    var m = null, transformOps = [];
                    (transform = transform.replace(/,/g, " ")).replace(transformRegex, function(str, type, value) {
                        transformOps.push(type, value);
                    });
                    for (var i = transformOps.length - 1; i > 0; i -= 2) {
                        var value = transformOps[i], type = transformOps[i - 1];
                        switch (m = m || matrix.create(), type) {
                          case "translate":
                            value = trim(value).split(DILIMITER_REG), matrix.translate(m, m, [ parseFloat(value[0]), parseFloat(value[1] || 0) ]);
                            break;

                          case "scale":
                            value = trim(value).split(DILIMITER_REG), matrix.scale(m, m, [ parseFloat(value[0]), parseFloat(value[1] || value[0]) ]);
                            break;

                          case "rotate":
                            value = trim(value).split(DILIMITER_REG), matrix.rotate(m, m, parseFloat(value[0]));
                            break;

                          case "skew":
                            value = trim(value).split(DILIMITER_REG), console.warn("Skew transform is not supported yet");
                            break;

                          case "matrix":
                            var value = trim(value).split(DILIMITER_REG);
                            m[0] = parseFloat(value[0]), m[1] = parseFloat(value[1]), m[2] = parseFloat(value[2]), 
                            m[3] = parseFloat(value[3]), m[4] = parseFloat(value[4]), m[5] = parseFloat(value[5]);
                        }
                    }
                    node.setLocalTransform(m);
                }
            }(xmlNode, el), extend(zrStyle, function(xmlNode) {
                var style = xmlNode.getAttribute("style"), result = {};
                if (!style) return result;
                var styleRegResult, styleList = {};
                styleRegex.lastIndex = 0;
                for (;null != (styleRegResult = styleRegex.exec(style)); ) styleList[styleRegResult[1]] = styleRegResult[2];
                for (var svgAttrName in attributesMap) attributesMap.hasOwnProperty(svgAttrName) && null != styleList[svgAttrName] && (result[attributesMap[svgAttrName]] = styleList[svgAttrName]);
                return result;
            }(xmlNode)), !onlyInlineStyle)) for (var svgAttrName in attributesMap) if (attributesMap.hasOwnProperty(svgAttrName)) {
                var attrValue = xmlNode.getAttribute(svgAttrName);
                null != attrValue && (zrStyle[attributesMap[svgAttrName]] = attrValue);
            }
            var elFillProp = isTextEl ? "textFill" : "fill", elStrokeProp = isTextEl ? "textStroke" : "stroke";
            el.style = el.style || new Style();
            var elStyle = el.style;
            null != zrStyle.fill && elStyle.set(elFillProp, getPaint(zrStyle.fill, defs)), null != zrStyle.stroke && elStyle.set(elStrokeProp, getPaint(zrStyle.stroke, defs)), 
            each([ "lineWidth", "opacity", "fillOpacity", "strokeOpacity", "miterLimit", "fontSize" ], function(propName) {
                var elPropName = "lineWidth" === propName && isTextEl ? "textStrokeWidth" : propName;
                null != zrStyle[propName] && elStyle.set(elPropName, parseFloat(zrStyle[propName]));
            }), zrStyle.textBaseline && "auto" !== zrStyle.textBaseline || (zrStyle.textBaseline = "alphabetic"), 
            "alphabetic" === zrStyle.textBaseline && (zrStyle.textBaseline = "bottom"), "start" === zrStyle.textAlign && (zrStyle.textAlign = "left"), 
            "end" === zrStyle.textAlign && (zrStyle.textAlign = "right"), each([ "lineDashOffset", "lineCap", "lineJoin", "fontWeight", "fontFamily", "fontStyle", "textAlign", "textBaseline" ], function(propName) {
                null != zrStyle[propName] && elStyle.set(propName, zrStyle[propName]);
            }), zrStyle.lineDash && (el.style.lineDash = trim(zrStyle.lineDash).split(DILIMITER_REG)), 
            elStyle[elStrokeProp] && "none" !== elStyle[elStrokeProp] && (el[elStrokeProp] = !0), 
            el.__inheritedStyle = zrStyle;
        }
        var urlRegex = /url\(\s*#(.*?)\)/;
        function getPaint(str, defs) {
            var urlMatch = defs && str && str.match(urlRegex);
            return urlMatch ? defs[trim(urlMatch[1])] : str;
        }
        var transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.e,]*)\)/g;
        var styleRegex = /([^\s:;]+)\s*:\s*([^:;]+)/g;
        function makeViewBoxTransform(viewBoxRect, width, height) {
            var scaleX = width / viewBoxRect.width, scaleY = height / viewBoxRect.height, scale = Math.min(scaleX, scaleY);
            return {
                scale: [ scale, scale ],
                position: [ -(viewBoxRect.x + viewBoxRect.width / 2) * scale + width / 2, -(viewBoxRect.y + viewBoxRect.height / 2) * scale + height / 2 ]
            };
        }
        exports.parseXML = parseXML, exports.makeViewBoxTransform = makeViewBoxTransform, 
        exports.parseSVG = function(xml, opt) {
            return new SVGParser().parse(xml, opt);
        };
    }, function(module, exports, __webpack_require__) {
        var _default = __webpack_require__(8).extend({
            type: "ellipse",
            shape: {
                cx: 0,
                cy: 0,
                rx: 0,
                ry: 0
            },
            buildPath: function(ctx, shape) {
                var k = .5522848, x = shape.cx, y = shape.cy, a = shape.rx, b = shape.ry, ox = a * k, oy = b * k;
                ctx.moveTo(x - a, y), ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b), 
                ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y), ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b), 
                ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y), ctx.closePath();
            }
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrender = __webpack_require__(86);
        exports.zrender = zrender;
        var matrix = __webpack_require__(17);
        exports.matrix = matrix;
        var vector = __webpack_require__(6);
        exports.vector = vector;
        var zrUtil = __webpack_require__(0), colorTool = __webpack_require__(20);
        exports.color = colorTool;
        var graphicUtil = __webpack_require__(2), numberUtil = __webpack_require__(4);
        exports.number = numberUtil;
        var formatUtil = __webpack_require__(9);
        exports.format = formatUtil;
        var _throttle = __webpack_require__(31);
        _throttle.throttle;
        exports.throttle = _throttle.throttle;
        var ecHelper = __webpack_require__(235);
        exports.helper = ecHelper;
        var parseGeoJSON = __webpack_require__(239);
        exports.parseGeoJSON = parseGeoJSON;
        var _List = __webpack_require__(25);
        exports.List = _List;
        var _Model = __webpack_require__(14);
        exports.Model = _Model;
        var _Axis = __webpack_require__(123);
        exports.Axis = _Axis;
        var _env = __webpack_require__(7);
        exports.env = _env;
        var parseGeoJson = parseGeoJSON, ecUtil = {};
        zrUtil.each([ "map", "each", "filter", "indexOf", "inherits", "reduce", "filter", "bind", "curry", "isArray", "isString", "isObject", "isFunction", "extend", "defaults", "clone", "merge" ], function(name) {
            ecUtil[name] = zrUtil[name];
        });
        var graphic = {};
        zrUtil.each([ "extendShape", "extendPath", "makePath", "makeImage", "mergePath", "resizePath", "createIcon", "setHoverStyle", "setLabelStyle", "setTextStyle", "setText", "getFont", "updateProps", "initProps", "getTransform", "clipPointsByRect", "clipRectByRect", "Group", "Image", "Text", "Circle", "Sector", "Ring", "Polygon", "Polyline", "Rect", "Line", "BezierCurve", "Arc", "IncrementalDisplayable", "CompoundPath", "LinearGradient", "RadialGradient", "BoundingRect" ], function(name) {
            graphic[name] = graphicUtil[name];
        }), exports.parseGeoJson = parseGeoJson, exports.util = ecUtil, exports.graphic = graphic;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), createListFromArray = __webpack_require__(32), axisHelper = __webpack_require__(26), axisModelCommonMixin = __webpack_require__(122), Model = __webpack_require__(14), _layout = __webpack_require__(10);
        _layout.getLayoutRect;
        exports.getLayoutRect = _layout.getLayoutRect;
        var _dataStackHelper = __webpack_require__(19), enableDataStack = _dataStackHelper.enableDataStack, isDimensionStacked = _dataStackHelper.isDimensionStacked, getStackedDimension = _dataStackHelper.getStackedDimension, _completeDimensions = __webpack_require__(118);
        exports.completeDimensions = _completeDimensions;
        var _createDimensions = __webpack_require__(117);
        exports.createDimensions = _createDimensions;
        var _symbol = __webpack_require__(16);
        exports.createSymbol = _symbol.createSymbol;
        var dataStack = {
            isDimensionStacked: isDimensionStacked,
            enableDataStack: enableDataStack,
            getStackedDimension: getStackedDimension
        };
        exports.createList = function(seriesModel) {
            return createListFromArray(seriesModel.getSource(), seriesModel);
        }, exports.dataStack = dataStack, exports.createScale = function(dataExtent, option) {
            var axisModel = option;
            Model.isInstance(option) || (axisModel = new Model(option), zrUtil.mixin(axisModel, axisModelCommonMixin));
            var scale = axisHelper.createScaleByModel(axisModel);
            return scale.setExtent(dataExtent[0], dataExtent[1]), axisHelper.niceScaleExtent(scale, axisModel), 
            scale;
        }, exports.mixinAxisModelCommonMethods = function(Model) {
            zrUtil.mixin(Model, axisModelCommonMixin);
        };
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), Scale = __webpack_require__(43), OrdinalMeta = __webpack_require__(119), scaleProto = Scale.prototype, OrdinalScale = Scale.extend({
            type: "ordinal",
            init: function(ordinalMeta, extent) {
                ordinalMeta && !zrUtil.isArray(ordinalMeta) || (ordinalMeta = new OrdinalMeta({
                    categories: ordinalMeta
                })), this._ordinalMeta = ordinalMeta, this._extent = extent || [ 0, ordinalMeta.categories.length - 1 ];
            },
            parse: function(val) {
                return "string" == typeof val ? this._ordinalMeta.getOrdinal(val) : Math.round(val);
            },
            contain: function(rank) {
                return rank = this.parse(rank), scaleProto.contain.call(this, rank) && null != this._ordinalMeta.categories[rank];
            },
            normalize: function(val) {
                return scaleProto.normalize.call(this, this.parse(val));
            },
            scale: function(val) {
                return Math.round(scaleProto.scale.call(this, val));
            },
            getTicks: function() {
                for (var ticks = [], extent = this._extent, rank = extent[0]; rank <= extent[1]; ) ticks.push(rank), 
                rank++;
                return ticks;
            },
            getLabel: function(n) {
                if (!this.isBlank()) return this._ordinalMeta.categories[n];
            },
            count: function() {
                return this._extent[1] - this._extent[0] + 1;
            },
            unionExtentFromData: function(data, dim) {
                this.unionExtent(data.getApproximateExtent(dim));
            },
            getOrdinalMeta: function() {
                return this._ordinalMeta;
            },
            niceTicks: zrUtil.noop,
            niceExtent: zrUtil.noop
        });
        OrdinalScale.create = function() {
            return new OrdinalScale();
        };
        var _default = OrdinalScale;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), numberUtil = __webpack_require__(4), formatUtil = __webpack_require__(9), scaleHelper = __webpack_require__(120), IntervalScale = __webpack_require__(67), intervalScaleProto = IntervalScale.prototype, mathCeil = Math.ceil, mathFloor = Math.floor, TimeScale = IntervalScale.extend({
            type: "time",
            getLabel: function(val) {
                var stepLvl = this._stepLvl, date = new Date(val);
                return formatUtil.formatTime(stepLvl[0], date, this.getSetting("useUTC"));
            },
            niceExtent: function(opt) {
                var extent = this._extent;
                if (extent[0] === extent[1] && (extent[0] -= 864e5, extent[1] += 864e5), extent[1] === -1 / 0 && extent[0] === 1 / 0) {
                    var d = new Date();
                    extent[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate()), extent[0] = extent[1] - 864e5;
                }
                this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
                var interval = this._interval;
                opt.fixMin || (extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval)), 
                opt.fixMax || (extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval));
            },
            niceTicks: function(approxTickNum, minInterval, maxInterval) {
                approxTickNum = approxTickNum || 10;
                var extent = this._extent, span = extent[1] - extent[0], approxInterval = span / approxTickNum;
                null != minInterval && approxInterval < minInterval && (approxInterval = minInterval), 
                null != maxInterval && approxInterval > maxInterval && (approxInterval = maxInterval);
                var scaleLevelsLen = scaleLevels.length, idx = function(a, x, lo, hi) {
                    for (;lo < hi; ) {
                        var mid = lo + hi >>> 1;
                        a[mid][1] < x ? lo = mid + 1 : hi = mid;
                    }
                    return lo;
                }(scaleLevels, approxInterval, 0, scaleLevelsLen), level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)], interval = level[1];
                if ("year" === level[0]) {
                    var yearSpan = span / interval;
                    interval *= numberUtil.nice(yearSpan / approxTickNum, !0);
                }
                var timezoneOffset = this.getSetting("useUTC") ? 0 : 60 * new Date(+extent[0] || +extent[1]).getTimezoneOffset() * 1e3, niceExtent = [ Math.round(mathCeil((extent[0] - timezoneOffset) / interval) * interval + timezoneOffset), Math.round(mathFloor((extent[1] - timezoneOffset) / interval) * interval + timezoneOffset) ];
                scaleHelper.fixExtent(niceExtent, extent), this._stepLvl = level, this._interval = interval, 
                this._niceExtent = niceExtent;
            },
            parse: function(val) {
                return +numberUtil.parseDate(val);
            }
        });
        zrUtil.each([ "contain", "normalize" ], function(methodName) {
            TimeScale.prototype[methodName] = function(val) {
                return intervalScaleProto[methodName].call(this, this.parse(val));
            };
        });
        var scaleLevels = [ [ "hh:mm:ss", 1e3 ], [ "hh:mm:ss", 5e3 ], [ "hh:mm:ss", 1e4 ], [ "hh:mm:ss", 15e3 ], [ "hh:mm:ss", 3e4 ], [ "hh:mm\nMM-dd", 6e4 ], [ "hh:mm\nMM-dd", 3e5 ], [ "hh:mm\nMM-dd", 6e5 ], [ "hh:mm\nMM-dd", 9e5 ], [ "hh:mm\nMM-dd", 18e5 ], [ "hh:mm\nMM-dd", 36e5 ], [ "hh:mm\nMM-dd", 72e5 ], [ "hh:mm\nMM-dd", 216e5 ], [ "hh:mm\nMM-dd", 432e5 ], [ "MM-dd\nyyyy", 864e5 ], [ "MM-dd\nyyyy", 1728e5 ], [ "MM-dd\nyyyy", 2592e5 ], [ "MM-dd\nyyyy", 3456e5 ], [ "MM-dd\nyyyy", 432e6 ], [ "MM-dd\nyyyy", 5184e5 ], [ "week", 6048e5 ], [ "MM-dd\nyyyy", 864e6 ], [ "week", 12096e5 ], [ "week", 18144e5 ], [ "month", 26784e5 ], [ "week", 36288e5 ], [ "month", 53568e5 ], [ "week", 6048e6 ], [ "quarter", 8208e6 ], [ "month", 107136e5 ], [ "month", 13392e6 ], [ "half-year", 16416e6 ], [ "month", 214272e5 ], [ "month", 26784e6 ], [ "year", 32832e6 ] ];
        TimeScale.create = function(model) {
            return new TimeScale({
                useUTC: model.ecModel.get("useUTC")
            });
        };
        var _default = TimeScale;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), Scale = __webpack_require__(43), numberUtil = __webpack_require__(4), IntervalScale = __webpack_require__(67), scaleProto = Scale.prototype, intervalScaleProto = IntervalScale.prototype, getPrecisionSafe = numberUtil.getPrecisionSafe, roundingErrorFix = numberUtil.round, mathFloor = Math.floor, mathCeil = Math.ceil, mathPow = Math.pow, mathLog = Math.log, LogScale = Scale.extend({
            type: "log",
            base: 10,
            $constructor: function() {
                Scale.apply(this, arguments), this._originalScale = new IntervalScale();
            },
            getTicks: function() {
                var originalScale = this._originalScale, extent = this._extent, originalExtent = originalScale.getExtent();
                return zrUtil.map(intervalScaleProto.getTicks.call(this), function(val) {
                    var powVal = numberUtil.round(mathPow(this.base, val));
                    return powVal = val === extent[0] && originalScale.__fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal, 
                    powVal = val === extent[1] && originalScale.__fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;
                }, this);
            },
            getLabel: intervalScaleProto.getLabel,
            scale: function(val) {
                return val = scaleProto.scale.call(this, val), mathPow(this.base, val);
            },
            setExtent: function(start, end) {
                var base = this.base;
                start = mathLog(start) / mathLog(base), end = mathLog(end) / mathLog(base), intervalScaleProto.setExtent.call(this, start, end);
            },
            getExtent: function() {
                var base = this.base, extent = scaleProto.getExtent.call(this);
                extent[0] = mathPow(base, extent[0]), extent[1] = mathPow(base, extent[1]);
                var originalScale = this._originalScale, originalExtent = originalScale.getExtent();
                return originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0])), 
                originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1])), 
                extent;
            },
            unionExtent: function(extent) {
                this._originalScale.unionExtent(extent);
                var base = this.base;
                extent[0] = mathLog(extent[0]) / mathLog(base), extent[1] = mathLog(extent[1]) / mathLog(base), 
                scaleProto.unionExtent.call(this, extent);
            },
            unionExtentFromData: function(data, dim) {
                this.unionExtent(data.getApproximateExtent(dim));
            },
            niceTicks: function(approxTickNum) {
                approxTickNum = approxTickNum || 10;
                var extent = this._extent, span = extent[1] - extent[0];
                if (!(span === 1 / 0 || span <= 0)) {
                    var interval = numberUtil.quantity(span);
                    for (approxTickNum / span * interval <= .5 && (interval *= 10); !isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0; ) interval *= 10;
                    var niceExtent = [ numberUtil.round(mathCeil(extent[0] / interval) * interval), numberUtil.round(mathFloor(extent[1] / interval) * interval) ];
                    this._interval = interval, this._niceExtent = niceExtent;
                }
            },
            niceExtent: function(opt) {
                intervalScaleProto.niceExtent.call(this, opt);
                var originalScale = this._originalScale;
                originalScale.__fixMin = opt.fixMin, originalScale.__fixMax = opt.fixMax;
            }
        });
        function fixRoundingError(val, originalVal) {
            return roundingErrorFix(val, getPrecisionSafe(originalVal));
        }
        zrUtil.each([ "contain", "normalize" ], function(methodName) {
            LogScale.prototype[methodName] = function(val) {
                return val = mathLog(val) / mathLog(this.base), scaleProto[methodName].call(this, val);
            };
        }), LogScale.create = function() {
            return new LogScale();
        };
        var _default = LogScale;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), Region = __webpack_require__(240);
        function decodePolygon(coordinate, encodeOffsets, encodeScale) {
            for (var result = [], prevX = encodeOffsets[0], prevY = encodeOffsets[1], i = 0; i < coordinate.length; i += 2) {
                var x = coordinate.charCodeAt(i) - 64, y = coordinate.charCodeAt(i + 1) - 64;
                x = x >> 1 ^ -(1 & x), y = y >> 1 ^ -(1 & y), prevX = x += prevX, prevY = y += prevY, 
                result.push([ x / encodeScale, y / encodeScale ]);
            }
            return result;
        }
        module.exports = function(geoJson) {
            return function(json) {
                if (!json.UTF8Encoding) return json;
                var encodeScale = json.UTF8Scale;
                null == encodeScale && (encodeScale = 1024);
                for (var features = json.features, f = 0; f < features.length; f++) for (var geometry = features[f].geometry, coordinates = geometry.coordinates, encodeOffsets = geometry.encodeOffsets, c = 0; c < coordinates.length; c++) {
                    var coordinate = coordinates[c];
                    if ("Polygon" === geometry.type) coordinates[c] = decodePolygon(coordinate, encodeOffsets[c], encodeScale); else if ("MultiPolygon" === geometry.type) for (var c2 = 0; c2 < coordinate.length; c2++) {
                        var polygon = coordinate[c2];
                        coordinate[c2] = decodePolygon(polygon, encodeOffsets[c][c2], encodeScale);
                    }
                }
                json.UTF8Encoding = !1;
            }(geoJson), zrUtil.map(zrUtil.filter(geoJson.features, function(featureObj) {
                return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0;
            }), function(featureObj) {
                var properties = featureObj.properties, geo = featureObj.geometry, coordinates = geo.coordinates, geometries = [];
                "Polygon" === geo.type && geometries.push({
                    type: "polygon",
                    exterior: coordinates[0],
                    interiors: coordinates.slice(1)
                }), "MultiPolygon" === geo.type && zrUtil.each(coordinates, function(item) {
                    item[0] && geometries.push({
                        type: "polygon",
                        exterior: item[0],
                        interiors: item.slice(1)
                    });
                });
                var region = new Region(properties.name, geometries, properties.cp);
                return region.properties = properties, region;
            });
        };
    }, function(module, exports, __webpack_require__) {
        var BoundingRect = __webpack_require__(12), bbox = __webpack_require__(100), vec2 = __webpack_require__(6), polygonContain = __webpack_require__(241);
        function Region(name, geometries, cp) {
            if (this.name = name, this.geometries = geometries, cp) cp = [ cp[0], cp[1] ]; else {
                var rect = this.getBoundingRect();
                cp = [ rect.x + rect.width / 2, rect.y + rect.height / 2 ];
            }
            this.center = cp;
        }
        Region.prototype = {
            constructor: Region,
            properties: null,
            getBoundingRect: function() {
                var rect = this._rect;
                if (rect) return rect;
                for (var MAX_NUMBER = Number.MAX_VALUE, min = [ MAX_NUMBER, MAX_NUMBER ], max = [ -MAX_NUMBER, -MAX_NUMBER ], min2 = [], max2 = [], geometries = this.geometries, i = 0; i < geometries.length; i++) if ("polygon" === geometries[i].type) {
                    var exterior = geometries[i].exterior;
                    bbox.fromPoints(exterior, min2, max2), vec2.min(min, min, min2), vec2.max(max, max, max2);
                }
                return 0 === i && (min[0] = min[1] = max[0] = max[1] = 0), this._rect = new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);
            },
            contain: function(coord) {
                var rect = this.getBoundingRect(), geometries = this.geometries;
                if (!rect.contain(coord[0], coord[1])) return !1;
                loopGeo: for (var i = 0, len = geometries.length; i < len; i++) if ("polygon" === geometries[i].type) {
                    var exterior = geometries[i].exterior, interiors = geometries[i].interiors;
                    if (polygonContain.contain(exterior, coord[0], coord[1])) {
                        for (var k = 0; k < (interiors ? interiors.length : 0); k++) if (polygonContain.contain(interiors[k])) continue loopGeo;
                        return !0;
                    }
                }
                return !1;
            },
            transformTo: function(x, y, width, height) {
                var rect = this.getBoundingRect(), aspect = rect.width / rect.height;
                width ? height || (height = width / aspect) : width = aspect * height;
                for (var target = new BoundingRect(x, y, width, height), transform = rect.calculateTransform(target), geometries = this.geometries, i = 0; i < geometries.length; i++) if ("polygon" === geometries[i].type) {
                    for (var exterior = geometries[i].exterior, interiors = geometries[i].interiors, p = 0; p < exterior.length; p++) vec2.applyTransform(exterior[p], exterior[p], transform);
                    for (var h = 0; h < (interiors ? interiors.length : 0); h++) for (p = 0; p < interiors[h].length; p++) vec2.applyTransform(interiors[h][p], interiors[h][p], transform);
                }
                (rect = this._rect).copy(target), this.center = [ rect.x + rect.width / 2, rect.y + rect.height / 2 ];
            },
            cloneShallow: function(name) {
                null == name && (name = this.name);
                var newRegion = new Region(name, this.geometries, this.center);
                return newRegion._rect = this._rect, newRegion.transformTo = null, newRegion;
            }
        };
        var _default = Region;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var windingLine = __webpack_require__(104), EPSILON = 1e-8;
        function isAroundEqual(a, b) {
            return Math.abs(a - b) < EPSILON;
        }
        exports.contain = function(points, x, y) {
            var w = 0, p = points[0];
            if (!p) return !1;
            for (var i = 1; i < points.length; i++) {
                var p2 = points[i];
                w += windingLine(p[0], p[1], p2[0], p2[1], x, y), p = p2;
            }
            var p0 = points[0];
            return isAroundEqual(p[0], p0[0]) && isAroundEqual(p[1], p0[1]) || (w += windingLine(p[0], p[1], p0[0], p0[1], x, y)), 
            0 !== w;
        };
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), textContain = __webpack_require__(21), makeInner = __webpack_require__(3).makeInner, _axisHelper = __webpack_require__(26), makeLabelFormatter = _axisHelper.makeLabelFormatter, getOptionCategoryInterval = _axisHelper.getOptionCategoryInterval, shouldShowAllLabels = _axisHelper.shouldShowAllLabels, inner = makeInner();
        function makeCategoryLabelsActually(axis, labelModel) {
            var numericLabelInterval, labelsCache = getListCache(axis, "labels"), optionLabelInterval = getOptionCategoryInterval(labelModel), result = listCacheGet(labelsCache, optionLabelInterval);
            return result || listCacheSet(labelsCache, optionLabelInterval, {
                labels: zrUtil.isFunction(optionLabelInterval) ? makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval) : makeLabelsByNumericCategoryInterval(axis, numericLabelInterval = "auto" === optionLabelInterval ? function(axis) {
                    var result = inner(axis).autoInterval;
                    return null != result ? result : inner(axis).autoInterval = axis.calculateCategoryInterval();
                }(axis) : optionLabelInterval),
                labelCategoryInterval: numericLabelInterval
            });
        }
        function getListCache(axis, prop) {
            return inner(axis)[prop] || (inner(axis)[prop] = []);
        }
        function listCacheGet(cache, key) {
            for (var i = 0; i < cache.length; i++) if (cache[i].key === key) return cache[i].value;
        }
        function listCacheSet(cache, key, value) {
            return cache.push({
                key: key,
                value: value
            }), value;
        }
        function makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {
            var labelFormatter = makeLabelFormatter(axis), ordinalScale = axis.scale, ordinalExtent = ordinalScale.getExtent(), labelModel = axis.getLabelModel(), result = [], step = Math.max((categoryInterval || 0) + 1, 1), startTick = ordinalExtent[0], tickCount = ordinalScale.count();
            0 !== startTick && step > 1 && tickCount / step > 2 && (startTick = Math.round(Math.ceil(startTick / step) * step));
            var showAllLabel = shouldShowAllLabels(axis), includeMinLabel = labelModel.get("showMinLabel") || showAllLabel, includeMaxLabel = labelModel.get("showMaxLabel") || showAllLabel;
            includeMinLabel && startTick !== ordinalExtent[0] && addItem(ordinalExtent[0]);
            for (var tickValue = startTick; tickValue <= ordinalExtent[1]; tickValue += step) addItem(tickValue);
            function addItem(tVal) {
                result.push(onlyTick ? tVal : {
                    formattedLabel: labelFormatter(tVal),
                    rawLabel: ordinalScale.getLabel(tVal),
                    tickValue: tVal
                });
            }
            return includeMaxLabel && tickValue - step !== ordinalExtent[1] && addItem(ordinalExtent[1]), 
            result;
        }
        function makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {
            var ordinalScale = axis.scale, labelFormatter = makeLabelFormatter(axis), result = [];
            return zrUtil.each(ordinalScale.getTicks(), function(tickValue) {
                var rawLabel = ordinalScale.getLabel(tickValue);
                categoryInterval(tickValue, rawLabel) && result.push(onlyTick ? tickValue : {
                    formattedLabel: labelFormatter(tickValue),
                    rawLabel: rawLabel,
                    tickValue: tickValue
                });
            }), result;
        }
        exports.createAxisLabels = function(axis) {
            return "category" === axis.type ? function(axis) {
                var labelModel = axis.getLabelModel(), result = makeCategoryLabelsActually(axis, labelModel);
                return !labelModel.get("show") || axis.scale.isBlank() ? {
                    labels: [],
                    labelCategoryInterval: result.labelCategoryInterval
                } : result;
            }(axis) : function(axis) {
                var ticks = axis.scale.getTicks(), labelFormatter = makeLabelFormatter(axis);
                return {
                    labels: zrUtil.map(ticks, function(tickValue, idx) {
                        return {
                            formattedLabel: labelFormatter(tickValue, idx),
                            rawLabel: axis.scale.getLabel(tickValue),
                            tickValue: tickValue
                        };
                    })
                };
            }(axis);
        }, exports.createAxisTicks = function(axis, tickModel) {
            return "category" === axis.type ? function(axis, tickModel) {
                var ticks, tickCategoryInterval, ticksCache = getListCache(axis, "ticks"), optionTickInterval = getOptionCategoryInterval(tickModel), result = listCacheGet(ticksCache, optionTickInterval);
                if (result) return result;
                if (tickModel.get("show") && !axis.scale.isBlank() || (ticks = []), zrUtil.isFunction(optionTickInterval)) ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, !0); else if ("auto" === optionTickInterval) {
                    var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel());
                    tickCategoryInterval = labelsResult.labelCategoryInterval, ticks = zrUtil.map(labelsResult.labels, function(labelItem) {
                        return labelItem.tickValue;
                    });
                } else ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval = optionTickInterval, !0);
                return listCacheSet(ticksCache, optionTickInterval, {
                    ticks: ticks,
                    tickCategoryInterval: tickCategoryInterval
                });
            }(axis, tickModel) : {
                ticks: axis.scale.getTicks()
            };
        }, exports.calculateCategoryInterval = function(axis) {
            var params = function(axis) {
                var labelModel = axis.getLabelModel();
                return {
                    axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,
                    labelRotate: labelModel.get("rotate") || 0,
                    font: labelModel.getFont()
                };
            }(axis), labelFormatter = makeLabelFormatter(axis), rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI, ordinalScale = axis.scale, ordinalExtent = ordinalScale.getExtent(), tickCount = ordinalScale.count();
            if (ordinalExtent[1] - ordinalExtent[0] < 1) return 0;
            var step = 1;
            tickCount > 40 && (step = Math.max(1, Math.floor(tickCount / 40)));
            for (var tickValue = ordinalExtent[0], unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue), unitW = Math.abs(unitSpan * Math.cos(rotation)), unitH = Math.abs(unitSpan * Math.sin(rotation)), maxW = 0, maxH = 0; tickValue <= ordinalExtent[1]; tickValue += step) {
                var width, height, rect = textContain.getBoundingRect(labelFormatter(tickValue), params.font, "center", "top");
                width = 1.3 * rect.width, height = 1.3 * rect.height, maxW = Math.max(maxW, width, 7), 
                maxH = Math.max(maxH, height, 7);
            }
            var dw = maxW / unitW, dh = maxH / unitH;
            isNaN(dw) && (dw = 1 / 0), isNaN(dh) && (dh = 1 / 0);
            var interval = Math.max(0, Math.floor(Math.min(dw, dh))), cache = inner(axis.model), lastAutoInterval = cache.lastAutoInterval, lastTickCount = cache.lastTickCount;
            return null != lastAutoInterval && null != lastTickCount && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval ? interval = lastAutoInterval : (cache.lastTickCount = tickCount, 
            cache.lastAutoInterval = interval), interval;
        };
    }, function(module, exports, __webpack_require__) {
        var echarts = __webpack_require__(1);
        __webpack_require__(244), __webpack_require__(245);
        var visualSymbol = __webpack_require__(69), layoutPoints = __webpack_require__(33), dataSample = __webpack_require__(248);
        __webpack_require__(70), echarts.registerVisual(visualSymbol("line", "circle", "line")), 
        echarts.registerLayout(layoutPoints("line")), echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, dataSample("line"));
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(5).__DEV__;
        var createListFromArray = __webpack_require__(32), _default = __webpack_require__(24).extend({
            type: "series.line",
            dependencies: [ "grid", "polar" ],
            getInitialData: function(option, ecModel) {
                return createListFromArray(this.getSource(), this);
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "cartesian2d",
                legendHoverLink: !0,
                hoverAnimation: !0,
                clipOverflow: !0,
                label: {
                    position: "top"
                },
                lineStyle: {
                    width: 2,
                    type: "solid"
                },
                step: !1,
                smooth: !1,
                smoothMonotone: null,
                symbol: "emptyCircle",
                symbolSize: 4,
                symbolRotate: null,
                showSymbol: !0,
                showAllSymbol: "auto",
                connectNulls: !1,
                sampling: "none",
                animationEasing: "linear",
                progressive: 0,
                hoverLayerThreshold: 1 / 0
            }
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(5).__DEV__;
        var zrUtil = __webpack_require__(0), SymbolDraw = __webpack_require__(44), SymbolClz = __webpack_require__(68), lineAnimationDiff = __webpack_require__(246), graphic = __webpack_require__(2), modelUtil = __webpack_require__(3), _poly = __webpack_require__(247), Polyline = _poly.Polyline, Polygon = _poly.Polygon, ChartView = __webpack_require__(65), round = __webpack_require__(4).round, _helper = __webpack_require__(125), prepareDataCoordInfo = _helper.prepareDataCoordInfo, getStackedOnPoint = _helper.getStackedOnPoint;
        function isPointsSame(points1, points2) {
            if (points1.length === points2.length) {
                for (var i = 0; i < points1.length; i++) {
                    var p1 = points1[i], p2 = points2[i];
                    if (p1[0] !== p2[0] || p1[1] !== p2[1]) return;
                }
                return !0;
            }
        }
        function getSmooth(smooth) {
            return "number" == typeof smooth ? smooth : smooth ? .5 : 0;
        }
        function getAxisExtentWithGap(axis) {
            var extent = axis.getGlobalExtent();
            if (axis.onBand) {
                var halfBandWidth = axis.getBandWidth() / 2 - 1, dir = extent[1] > extent[0] ? 1 : -1;
                extent[0] += dir * halfBandWidth, extent[1] -= dir * halfBandWidth;
            }
            return extent;
        }
        function createClipShape(coordSys, hasAnimation, forSymbol, seriesModel) {
            return "polar" === coordSys.type ? function(polar, hasAnimation, forSymbol, seriesModel) {
                var angleAxis = polar.getAngleAxis(), radiusExtent = polar.getRadiusAxis().getExtent().slice();
                radiusExtent[0] > radiusExtent[1] && radiusExtent.reverse();
                var angleExtent = angleAxis.getExtent(), RADIAN = Math.PI / 180;
                forSymbol && (radiusExtent[0] -= .5, radiusExtent[1] += .5);
                var clipPath = new graphic.Sector({
                    shape: {
                        cx: round(polar.cx, 1),
                        cy: round(polar.cy, 1),
                        r0: round(radiusExtent[0], 1),
                        r: round(radiusExtent[1], 1),
                        startAngle: -angleExtent[0] * RADIAN,
                        endAngle: -angleExtent[1] * RADIAN,
                        clockwise: angleAxis.inverse
                    }
                });
                return hasAnimation && (clipPath.shape.endAngle = -angleExtent[0] * RADIAN, graphic.initProps(clipPath, {
                    shape: {
                        endAngle: -angleExtent[1] * RADIAN
                    }
                }, seriesModel)), clipPath;
            }(coordSys, hasAnimation, forSymbol, seriesModel) : function(cartesian, hasAnimation, forSymbol, seriesModel) {
                var xExtent = getAxisExtentWithGap(cartesian.getAxis("x")), yExtent = getAxisExtentWithGap(cartesian.getAxis("y")), isHorizontal = cartesian.getBaseAxis().isHorizontal(), x = Math.min(xExtent[0], xExtent[1]), y = Math.min(yExtent[0], yExtent[1]), width = Math.max(xExtent[0], xExtent[1]) - x, height = Math.max(yExtent[0], yExtent[1]) - y;
                if (forSymbol) x -= .5, width += .5, y -= .5, height += .5; else {
                    var lineWidth = seriesModel.get("lineStyle.width") || 2, expandSize = seriesModel.get("clipOverflow") ? lineWidth / 2 : Math.max(width, height);
                    isHorizontal ? (y -= expandSize, height += 2 * expandSize) : (x -= expandSize, width += 2 * expandSize);
                }
                var clipPath = new graphic.Rect({
                    shape: {
                        x: x,
                        y: y,
                        width: width,
                        height: height
                    }
                });
                return hasAnimation && (clipPath.shape[isHorizontal ? "width" : "height"] = 0, graphic.initProps(clipPath, {
                    shape: {
                        width: width,
                        height: height
                    }
                }, seriesModel)), clipPath;
            }(coordSys, hasAnimation, forSymbol, seriesModel);
        }
        function turnPointsIntoStep(points, coordSys, stepTurnAt) {
            for (var baseAxis = coordSys.getBaseAxis(), baseIndex = "x" === baseAxis.dim || "radius" === baseAxis.dim ? 0 : 1, stepPoints = [], i = 0; i < points.length - 1; i++) {
                var nextPt = points[i + 1], pt = points[i];
                stepPoints.push(pt);
                var stepPt = [];
                switch (stepTurnAt) {
                  case "end":
                    stepPt[baseIndex] = nextPt[baseIndex], stepPt[1 - baseIndex] = pt[1 - baseIndex], 
                    stepPoints.push(stepPt);
                    break;

                  case "middle":
                    var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2, stepPt2 = [];
                    stepPt[baseIndex] = stepPt2[baseIndex] = middle, stepPt[1 - baseIndex] = pt[1 - baseIndex], 
                    stepPt2[1 - baseIndex] = nextPt[1 - baseIndex], stepPoints.push(stepPt), stepPoints.push(stepPt2);
                    break;

                  default:
                    stepPt[baseIndex] = pt[baseIndex], stepPt[1 - baseIndex] = nextPt[1 - baseIndex], 
                    stepPoints.push(stepPt);
                }
            }
            return points[i] && stepPoints.push(points[i]), stepPoints;
        }
        function getIsIgnoreFunc(seriesModel, data, coordSys) {
            var showAllSymbol = seriesModel.get("showAllSymbol"), isAuto = "auto" === showAllSymbol;
            if (!showAllSymbol || isAuto) {
                var categoryAxis = coordSys.getAxesByScale("ordinal")[0];
                if (categoryAxis && (!isAuto || !function(categoryAxis, data) {
                    var axisExtent = categoryAxis.getExtent(), availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis.scale.count();
                    isNaN(availSize) && (availSize = 0);
                    for (var dataLen = data.count(), step = Math.max(1, Math.round(dataLen / 5)), dataIndex = 0; dataIndex < dataLen; dataIndex += step) if (1.5 * SymbolClz.getSymbolSize(data, dataIndex)[categoryAxis.isHorizontal() ? 1 : 0] > availSize) return !1;
                    return !0;
                }(categoryAxis, data))) {
                    var categoryDataDim = data.mapDimension(categoryAxis.dim), labelMap = {};
                    return zrUtil.each(categoryAxis.getViewLabels(), function(labelItem) {
                        labelMap[labelItem.tickValue] = 1;
                    }), function(dataIndex) {
                        return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));
                    };
                }
            }
        }
        var _default = ChartView.extend({
            type: "line",
            init: function() {
                var lineGroup = new graphic.Group(), symbolDraw = new SymbolDraw();
                this.group.add(symbolDraw.group), this._symbolDraw = symbolDraw, this._lineGroup = lineGroup;
            },
            render: function(seriesModel, ecModel, api) {
                var coordSys = seriesModel.coordinateSystem, group = this.group, data = seriesModel.getData(), lineStyleModel = seriesModel.getModel("lineStyle"), areaStyleModel = seriesModel.getModel("areaStyle"), points = data.mapArray(data.getItemLayout), isCoordSysPolar = "polar" === coordSys.type, prevCoordSys = this._coordSys, symbolDraw = this._symbolDraw, polyline = this._polyline, polygon = this._polygon, lineGroup = this._lineGroup, hasAnimation = seriesModel.get("animation"), isAreaChart = !areaStyleModel.isEmpty(), valueOrigin = areaStyleModel.get("origin"), stackedOnPoints = function(coordSys, data, dataCoordInfo) {
                    if (!dataCoordInfo.valueDim) return [];
                    for (var points = [], idx = 0, len = data.count(); idx < len; idx++) points.push(getStackedOnPoint(dataCoordInfo, coordSys, data, idx));
                    return points;
                }(coordSys, data, prepareDataCoordInfo(coordSys, data, valueOrigin)), showSymbol = seriesModel.get("showSymbol"), isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys), oldData = this._data;
                oldData && oldData.eachItemGraphicEl(function(el, idx) {
                    el.__temp && (group.remove(el), oldData.setItemGraphicEl(idx, null));
                }), showSymbol || symbolDraw.remove(), group.add(lineGroup);
                var step = !isCoordSysPolar && seriesModel.get("step");
                polyline && prevCoordSys.type === coordSys.type && step === this._step ? (isAreaChart && !polygon ? polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation) : polygon && !isAreaChart && (lineGroup.remove(polygon), 
                polygon = this._polygon = null), lineGroup.setClipPath(createClipShape(coordSys, !1, !1, seriesModel)), 
                showSymbol && symbolDraw.updateData(data, {
                    isIgnore: isIgnoreFunc,
                    clipShape: createClipShape(coordSys, !1, !0, seriesModel)
                }), data.eachItemGraphicEl(function(el) {
                    el.stopAnimation(!0);
                }), isPointsSame(this._stackedOnPoints, stackedOnPoints) && isPointsSame(this._points, points) || (hasAnimation ? this._updateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin) : (step && (points = turnPointsIntoStep(points, coordSys, step), 
                stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step)), polyline.setShape({
                    points: points
                }), polygon && polygon.setShape({
                    points: points,
                    stackedOnPoints: stackedOnPoints
                })))) : (showSymbol && symbolDraw.updateData(data, {
                    isIgnore: isIgnoreFunc,
                    clipShape: createClipShape(coordSys, !1, !0, seriesModel)
                }), step && (points = turnPointsIntoStep(points, coordSys, step), stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step)), 
                polyline = this._newPolyline(points, coordSys, hasAnimation), isAreaChart && (polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation)), 
                lineGroup.setClipPath(createClipShape(coordSys, !0, !1, seriesModel)));
                var visualColor = function(data, coordSys) {
                    var visualMetaList = data.getVisual("visualMeta");
                    if (visualMetaList && visualMetaList.length && data.count() && "cartesian2d" === coordSys.type) {
                        for (var coordDim, visualMeta, i = visualMetaList.length - 1; i >= 0; i--) {
                            var dimIndex = visualMetaList[i].dimension, dimName = data.dimensions[dimIndex], dimInfo = data.getDimensionInfo(dimName);
                            if ("x" === (coordDim = dimInfo && dimInfo.coordDim) || "y" === coordDim) {
                                visualMeta = visualMetaList[i];
                                break;
                            }
                        }
                        if (visualMeta) {
                            var axis = coordSys.getAxis(coordDim), colorStops = zrUtil.map(visualMeta.stops, function(stop) {
                                return {
                                    coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),
                                    color: stop.color
                                };
                            }), stopLen = colorStops.length, outerColors = visualMeta.outerColors.slice();
                            stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord && (colorStops.reverse(), 
                            outerColors.reverse());
                            var minCoord = colorStops[0].coord - 10, maxCoord = colorStops[stopLen - 1].coord + 10, coordSpan = maxCoord - minCoord;
                            if (coordSpan < .001) return "transparent";
                            zrUtil.each(colorStops, function(stop) {
                                stop.offset = (stop.coord - minCoord) / coordSpan;
                            }), colorStops.push({
                                offset: stopLen ? colorStops[stopLen - 1].offset : .5,
                                color: outerColors[1] || "transparent"
                            }), colorStops.unshift({
                                offset: stopLen ? colorStops[0].offset : .5,
                                color: outerColors[0] || "transparent"
                            });
                            var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, !0);
                            return gradient[coordDim] = minCoord, gradient[coordDim + "2"] = maxCoord, gradient;
                        }
                    }
                }(data, coordSys) || data.getVisual("color");
                polyline.useStyle(zrUtil.defaults(lineStyleModel.getLineStyle(), {
                    fill: "none",
                    stroke: visualColor,
                    lineJoin: "bevel"
                }));
                var smooth = seriesModel.get("smooth");
                if (smooth = getSmooth(seriesModel.get("smooth")), polyline.setShape({
                    smooth: smooth,
                    smoothMonotone: seriesModel.get("smoothMonotone"),
                    connectNulls: seriesModel.get("connectNulls")
                }), polygon) {
                    var stackedOnSeries = data.getCalculationInfo("stackedOnSeries"), stackedOnSmooth = 0;
                    polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {
                        fill: visualColor,
                        opacity: .7,
                        lineJoin: "bevel"
                    })), stackedOnSeries && (stackedOnSmooth = getSmooth(stackedOnSeries.get("smooth"))), 
                    polygon.setShape({
                        smooth: smooth,
                        stackedOnSmooth: stackedOnSmooth,
                        smoothMonotone: seriesModel.get("smoothMonotone"),
                        connectNulls: seriesModel.get("connectNulls")
                    });
                }
                this._data = data, this._coordSys = coordSys, this._stackedOnPoints = stackedOnPoints, 
                this._points = points, this._step = step, this._valueOrigin = valueOrigin;
            },
            dispose: function() {},
            highlight: function(seriesModel, ecModel, api, payload) {
                var data = seriesModel.getData(), dataIndex = modelUtil.queryDataIndex(data, payload);
                if (!(dataIndex instanceof Array) && null != dataIndex && dataIndex >= 0) {
                    var symbol = data.getItemGraphicEl(dataIndex);
                    if (!symbol) {
                        var pt = data.getItemLayout(dataIndex);
                        if (!pt) return;
                        (symbol = new SymbolClz(data, dataIndex)).position = pt, symbol.setZ(seriesModel.get("zlevel"), seriesModel.get("z")), 
                        symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]), symbol.__temp = !0, data.setItemGraphicEl(dataIndex, symbol), 
                        symbol.stopSymbolAnimation(!0), this.group.add(symbol);
                    }
                    symbol.highlight();
                } else ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);
            },
            downplay: function(seriesModel, ecModel, api, payload) {
                var data = seriesModel.getData(), dataIndex = modelUtil.queryDataIndex(data, payload);
                if (null != dataIndex && dataIndex >= 0) {
                    var symbol = data.getItemGraphicEl(dataIndex);
                    symbol && (symbol.__temp ? (data.setItemGraphicEl(dataIndex, null), this.group.remove(symbol)) : symbol.downplay());
                } else ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);
            },
            _newPolyline: function(points) {
                var polyline = this._polyline;
                return polyline && this._lineGroup.remove(polyline), polyline = new Polyline({
                    shape: {
                        points: points
                    },
                    silent: !0,
                    z2: 10
                }), this._lineGroup.add(polyline), this._polyline = polyline, polyline;
            },
            _newPolygon: function(points, stackedOnPoints) {
                var polygon = this._polygon;
                return polygon && this._lineGroup.remove(polygon), polygon = new Polygon({
                    shape: {
                        points: points,
                        stackedOnPoints: stackedOnPoints
                    },
                    silent: !0
                }), this._lineGroup.add(polygon), this._polygon = polygon, polygon;
            },
            _updateAnimation: function(data, stackedOnPoints, coordSys, api, step, valueOrigin) {
                var polyline = this._polyline, polygon = this._polygon, seriesModel = data.hostModel, diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin), current = diff.current, stackedOnCurrent = diff.stackedOnCurrent, next = diff.next, stackedOnNext = diff.stackedOnNext;
                step && (current = turnPointsIntoStep(diff.current, coordSys, step), stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step), 
                next = turnPointsIntoStep(diff.next, coordSys, step), stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step)), 
                polyline.shape.__points = diff.current, polyline.shape.points = current, graphic.updateProps(polyline, {
                    shape: {
                        points: next
                    }
                }, seriesModel), polygon && (polygon.setShape({
                    points: current,
                    stackedOnPoints: stackedOnCurrent
                }), graphic.updateProps(polygon, {
                    shape: {
                        points: next,
                        stackedOnPoints: stackedOnNext
                    }
                }, seriesModel));
                for (var updatedDataInfo = [], diffStatus = diff.status, i = 0; i < diffStatus.length; i++) {
                    if ("=" === diffStatus[i].cmd) {
                        var el = data.getItemGraphicEl(diffStatus[i].idx1);
                        el && updatedDataInfo.push({
                            el: el,
                            ptIdx: i
                        });
                    }
                }
                polyline.animators && polyline.animators.length && polyline.animators[0].during(function() {
                    for (var i = 0; i < updatedDataInfo.length; i++) {
                        updatedDataInfo[i].el.attr("position", polyline.shape.__points[updatedDataInfo[i].ptIdx]);
                    }
                });
            },
            remove: function(ecModel) {
                var group = this.group, oldData = this._data;
                this._lineGroup.removeAll(), this._symbolDraw.remove(!0), oldData && oldData.eachItemGraphicEl(function(el, idx) {
                    el.__temp && (group.remove(el), oldData.setItemGraphicEl(idx, null));
                }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;
            }
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var _helper = __webpack_require__(125), prepareDataCoordInfo = _helper.prepareDataCoordInfo, getStackedOnPoint = _helper.getStackedOnPoint;
        module.exports = function(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {
            for (var diff = function(oldData, newData) {
                var diffResult = [];
                return newData.diff(oldData).add(function(idx) {
                    diffResult.push({
                        cmd: "+",
                        idx: idx
                    });
                }).update(function(newIdx, oldIdx) {
                    diffResult.push({
                        cmd: "=",
                        idx: oldIdx,
                        idx1: newIdx
                    });
                }).remove(function(idx) {
                    diffResult.push({
                        cmd: "-",
                        idx: idx
                    });
                }).execute(), diffResult;
            }(oldData, newData), currPoints = [], nextPoints = [], currStackedPoints = [], nextStackedPoints = [], status = [], sortedIndices = [], rawIndices = [], newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin), oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin), i = 0; i < diff.length; i++) {
                var diffItem = diff[i], pointAdded = !0;
                switch (diffItem.cmd) {
                  case "=":
                    var currentPt = oldData.getItemLayout(diffItem.idx), nextPt = newData.getItemLayout(diffItem.idx1);
                    (isNaN(currentPt[0]) || isNaN(currentPt[1])) && (currentPt = nextPt.slice()), currPoints.push(currentPt), 
                    nextPoints.push(nextPt), currStackedPoints.push(oldStackedOnPoints[diffItem.idx]), 
                    nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]), rawIndices.push(newData.getRawIndex(diffItem.idx1));
                    break;

                  case "+":
                    var idx = diffItem.idx;
                    currPoints.push(oldCoordSys.dataToPoint([ newData.get(newDataOldCoordInfo.dataDimsForPoint[0], idx), newData.get(newDataOldCoordInfo.dataDimsForPoint[1], idx) ])), 
                    nextPoints.push(newData.getItemLayout(idx).slice()), currStackedPoints.push(getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, idx)), 
                    nextStackedPoints.push(newStackedOnPoints[idx]), rawIndices.push(newData.getRawIndex(idx));
                    break;

                  case "-":
                    idx = diffItem.idx;
                    var rawIndex = oldData.getRawIndex(idx);
                    rawIndex !== idx ? (currPoints.push(oldData.getItemLayout(idx)), nextPoints.push(newCoordSys.dataToPoint([ oldData.get(oldDataNewCoordInfo.dataDimsForPoint[0], idx), oldData.get(oldDataNewCoordInfo.dataDimsForPoint[1], idx) ])), 
                    currStackedPoints.push(oldStackedOnPoints[idx]), nextStackedPoints.push(getStackedOnPoint(oldDataNewCoordInfo, newCoordSys, oldData, idx)), 
                    rawIndices.push(rawIndex)) : pointAdded = !1;
                }
                pointAdded && (status.push(diffItem), sortedIndices.push(sortedIndices.length));
            }
            sortedIndices.sort(function(a, b) {
                return rawIndices[a] - rawIndices[b];
            });
            var sortedCurrPoints = [], sortedNextPoints = [], sortedCurrStackedPoints = [], sortedNextStackedPoints = [], sortedStatus = [];
            for (i = 0; i < sortedIndices.length; i++) idx = sortedIndices[i], sortedCurrPoints[i] = currPoints[idx], 
            sortedNextPoints[i] = nextPoints[idx], sortedCurrStackedPoints[i] = currStackedPoints[idx], 
            sortedNextStackedPoints[i] = nextStackedPoints[idx], sortedStatus[i] = status[idx];
            return {
                current: sortedCurrPoints,
                next: sortedNextPoints,
                stackedOnCurrent: sortedCurrStackedPoints,
                stackedOnNext: sortedNextStackedPoints,
                status: sortedStatus
            };
        };
    }, function(module, exports, __webpack_require__) {
        var Path = __webpack_require__(8), vec2 = __webpack_require__(6), fixClipWithShadow = __webpack_require__(106), vec2Min = vec2.min, vec2Max = vec2.max, scaleAndAdd = vec2.scaleAndAdd, v2Copy = vec2.copy, v = [], cp0 = [], cp1 = [];
        function isPointNull(p) {
            return isNaN(p[0]) || isNaN(p[1]);
        }
        function drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {
            return "none" !== smoothMonotone && smoothMonotone ? function(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {
                for (var prevIdx = 0, idx = start, k = 0; k < segLen; k++) {
                    var p = points[idx];
                    if (idx >= allLen || idx < 0) break;
                    if (isPointNull(p)) {
                        if (connectNulls) {
                            idx += dir;
                            continue;
                        }
                        break;
                    }
                    if (idx === start) ctx[dir > 0 ? "moveTo" : "lineTo"](p[0], p[1]); else if (smooth > 0) {
                        var prevP = points[prevIdx], dim = "y" === smoothMonotone ? 1 : 0, ctrlLen = (p[dim] - prevP[dim]) * smooth;
                        v2Copy(cp0, prevP), cp0[dim] = prevP[dim] + ctrlLen, v2Copy(cp1, p), cp1[dim] = p[dim] - ctrlLen, 
                        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);
                    } else ctx.lineTo(p[0], p[1]);
                    prevIdx = idx, idx += dir;
                }
                return k;
            }.apply(this, arguments) : function(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {
                for (var prevIdx = 0, idx = start, k = 0; k < segLen; k++) {
                    var p = points[idx];
                    if (idx >= allLen || idx < 0) break;
                    if (isPointNull(p)) {
                        if (connectNulls) {
                            idx += dir;
                            continue;
                        }
                        break;
                    }
                    if (idx === start) ctx[dir > 0 ? "moveTo" : "lineTo"](p[0], p[1]), v2Copy(cp0, p); else if (smooth > 0) {
                        var nextIdx = idx + dir, nextP = points[nextIdx];
                        if (connectNulls) for (;nextP && isPointNull(points[nextIdx]); ) nextP = points[nextIdx += dir];
                        var ratioNextSeg = .5, prevP = points[prevIdx], nextP = points[nextIdx];
                        if (!nextP || isPointNull(nextP)) v2Copy(cp1, p); else {
                            var lenPrevSeg, lenNextSeg;
                            if (isPointNull(nextP) && !connectNulls && (nextP = p), vec2.sub(v, nextP, prevP), 
                            "x" === smoothMonotone || "y" === smoothMonotone) {
                                var dim = "x" === smoothMonotone ? 0 : 1;
                                lenPrevSeg = Math.abs(p[dim] - prevP[dim]), lenNextSeg = Math.abs(p[dim] - nextP[dim]);
                            } else lenPrevSeg = vec2.dist(p, prevP), lenNextSeg = vec2.dist(p, nextP);
                            scaleAndAdd(cp1, p, v, -smooth * (1 - (ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg))));
                        }
                        vec2Min(cp0, cp0, smoothMax), vec2Max(cp0, cp0, smoothMin), vec2Min(cp1, cp1, smoothMax), 
                        vec2Max(cp1, cp1, smoothMin), ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]), 
                        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);
                    } else ctx.lineTo(p[0], p[1]);
                    prevIdx = idx, idx += dir;
                }
                return k;
            }.apply(this, arguments);
        }
        function getBoundingBox(points, smoothConstraint) {
            var ptMin = [ 1 / 0, 1 / 0 ], ptMax = [ -1 / 0, -1 / 0 ];
            if (smoothConstraint) for (var i = 0; i < points.length; i++) {
                var pt = points[i];
                pt[0] < ptMin[0] && (ptMin[0] = pt[0]), pt[1] < ptMin[1] && (ptMin[1] = pt[1]), 
                pt[0] > ptMax[0] && (ptMax[0] = pt[0]), pt[1] > ptMax[1] && (ptMax[1] = pt[1]);
            }
            return {
                min: smoothConstraint ? ptMin : ptMax,
                max: smoothConstraint ? ptMax : ptMin
            };
        }
        var Polyline = Path.extend({
            type: "ec-polyline",
            shape: {
                points: [],
                smooth: 0,
                smoothConstraint: !0,
                smoothMonotone: null,
                connectNulls: !1
            },
            style: {
                fill: null,
                stroke: "#000"
            },
            brush: fixClipWithShadow(Path.prototype.brush),
            buildPath: function(ctx, shape) {
                var points = shape.points, i = 0, len = points.length, result = getBoundingBox(points, shape.smoothConstraint);
                if (shape.connectNulls) {
                    for (;len > 0 && isPointNull(points[len - 1]); len--) ;
                    for (;i < len && isPointNull(points[i]); i++) ;
                }
                for (;i < len; ) i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;
            }
        }), Polygon = Path.extend({
            type: "ec-polygon",
            shape: {
                points: [],
                stackedOnPoints: [],
                smooth: 0,
                stackedOnSmooth: 0,
                smoothConstraint: !0,
                smoothMonotone: null,
                connectNulls: !1
            },
            brush: fixClipWithShadow(Path.prototype.brush),
            buildPath: function(ctx, shape) {
                var points = shape.points, stackedOnPoints = shape.stackedOnPoints, i = 0, len = points.length, smoothMonotone = shape.smoothMonotone, bbox = getBoundingBox(points, shape.smoothConstraint), stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);
                if (shape.connectNulls) {
                    for (;len > 0 && isPointNull(points[len - 1]); len--) ;
                    for (;i < len && isPointNull(points[i]); i++) ;
                }
                for (;i < len; ) {
                    var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);
                    drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls), 
                    i += k + 1, ctx.closePath();
                }
            }
        });
        exports.Polyline = Polyline, exports.Polygon = Polygon;
    }, function(module, exports) {
        var samplers = {
            average: function(frame) {
                for (var sum = 0, count = 0, i = 0; i < frame.length; i++) isNaN(frame[i]) || (sum += frame[i], 
                count++);
                return 0 === count ? NaN : sum / count;
            },
            sum: function(frame) {
                for (var sum = 0, i = 0; i < frame.length; i++) sum += frame[i] || 0;
                return sum;
            },
            max: function(frame) {
                for (var max = -1 / 0, i = 0; i < frame.length; i++) frame[i] > max && (max = frame[i]);
                return isFinite(max) ? max : NaN;
            },
            min: function(frame) {
                for (var min = 1 / 0, i = 0; i < frame.length; i++) frame[i] < min && (min = frame[i]);
                return isFinite(min) ? min : NaN;
            },
            nearest: function(frame) {
                return frame[0];
            }
        }, indexSampler = function(frame, value) {
            return Math.round(frame.length / 2);
        };
        module.exports = function(seriesType) {
            return {
                seriesType: seriesType,
                modifyOutputEnd: !0,
                reset: function(seriesModel, ecModel, api) {
                    var data = seriesModel.getData(), sampling = seriesModel.get("sampling"), coordSys = seriesModel.coordinateSystem;
                    if ("cartesian2d" === coordSys.type && sampling) {
                        var sampler, baseAxis = coordSys.getBaseAxis(), valueAxis = coordSys.getOtherAxis(baseAxis), extent = baseAxis.getExtent(), size = extent[1] - extent[0], rate = Math.round(data.count() / size);
                        rate > 1 && ("string" == typeof sampling ? sampler = samplers[sampling] : "function" == typeof sampling && (sampler = sampling), 
                        sampler && seriesModel.setData(data.downSample(data.mapDimension(valueAxis.dim), 1 / rate, sampler, indexSampler)));
                    }
                }
            };
        };
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(5).__DEV__;
        var _util = __webpack_require__(0), isObject = _util.isObject, each = _util.each, map = _util.map, indexOf = _util.indexOf, getLayoutRect = (_util.retrieve, 
        __webpack_require__(10).getLayoutRect), _axisHelper = __webpack_require__(26), createScaleByModel = _axisHelper.createScaleByModel, ifAxisCrossZero = _axisHelper.ifAxisCrossZero, niceScaleExtent = _axisHelper.niceScaleExtent, estimateLabelUnionRect = _axisHelper.estimateLabelUnionRect, Cartesian2D = __webpack_require__(250), Axis2D = __webpack_require__(252), CoordinateSystem = __webpack_require__(41), getStackedDimension = __webpack_require__(19).getStackedDimension;
        function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {
            return axisModel.getCoordSysModel() === gridModel;
        }
        function Grid(gridModel, ecModel, api) {
            this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], 
            this._initCartesian(gridModel, ecModel, api), this.model = gridModel;
        }
        __webpack_require__(253);
        var gridProto = Grid.prototype;
        function fixAxisOnZero(axesMap, otherAxisDim, axis, onZeroRecords) {
            axis.getAxesOnZeroOf = function() {
                return otherAxisOnZeroOf ? [ otherAxisOnZeroOf ] : [];
            };
            var otherAxisOnZeroOf, otherAxes = axesMap[otherAxisDim], axisModel = axis.model, onZero = axisModel.get("axisLine.onZero"), onZeroAxisIndex = axisModel.get("axisLine.onZeroAxisIndex");
            if (onZero) {
                if (null != onZeroAxisIndex) canOnZeroToAxis(otherAxes[onZeroAxisIndex]) && (otherAxisOnZeroOf = otherAxes[onZeroAxisIndex]); else for (var idx in otherAxes) if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {
                    otherAxisOnZeroOf = otherAxes[idx];
                    break;
                }
                otherAxisOnZeroOf && (onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = !0);
            }
            function getOnZeroRecordKey(axis) {
                return axis.dim + "_" + axis.index;
            }
        }
        function canOnZeroToAxis(axis) {
            return axis && "category" !== axis.type && "time" !== axis.type && ifAxisCrossZero(axis);
        }
        gridProto.type = "grid", gridProto.axisPointerEnabled = !0, gridProto.getRect = function() {
            return this._rect;
        }, gridProto.update = function(ecModel, api) {
            var axesMap = this._axesMap;
            this._updateScale(ecModel, this.model), each(axesMap.x, function(xAxis) {
                niceScaleExtent(xAxis.scale, xAxis.model);
            }), each(axesMap.y, function(yAxis) {
                niceScaleExtent(yAxis.scale, yAxis.model);
            });
            var onZeroRecords = {};
            each(axesMap.x, function(xAxis) {
                fixAxisOnZero(axesMap, "y", xAxis, onZeroRecords);
            }), each(axesMap.y, function(yAxis) {
                fixAxisOnZero(axesMap, "x", yAxis, onZeroRecords);
            }), this.resize(this.model, api);
        }, gridProto.resize = function(gridModel, api, ignoreContainLabel) {
            var gridRect = getLayoutRect(gridModel.getBoxLayoutParams(), {
                width: api.getWidth(),
                height: api.getHeight()
            });
            this._rect = gridRect;
            var axesList = this._axesList;
            function adjustAxes() {
                each(axesList, function(axis) {
                    var isHorizontal = axis.isHorizontal(), extent = isHorizontal ? [ 0, gridRect.width ] : [ 0, gridRect.height ], idx = axis.inverse ? 1 : 0;
                    axis.setExtent(extent[idx], extent[1 - idx]), function(axis, coordBase) {
                        var axisExtent = axis.getExtent(), axisExtentSum = axisExtent[0] + axisExtent[1];
                        axis.toGlobalCoord = "x" === axis.dim ? function(coord) {
                            return coord + coordBase;
                        } : function(coord) {
                            return axisExtentSum - coord + coordBase;
                        }, axis.toLocalCoord = "x" === axis.dim ? function(coord) {
                            return coord - coordBase;
                        } : function(coord) {
                            return axisExtentSum - coord + coordBase;
                        };
                    }(axis, isHorizontal ? gridRect.x : gridRect.y);
                });
            }
            adjustAxes(), !ignoreContainLabel && gridModel.get("containLabel") && (each(axesList, function(axis) {
                if (!axis.model.get("axisLabel.inside")) {
                    var labelUnionRect = estimateLabelUnionRect(axis);
                    if (labelUnionRect) {
                        var dim = axis.isHorizontal() ? "height" : "width", margin = axis.model.get("axisLabel.margin");
                        gridRect[dim] -= labelUnionRect[dim] + margin, "top" === axis.position ? gridRect.y += labelUnionRect.height + margin : "left" === axis.position && (gridRect.x += labelUnionRect.width + margin);
                    }
                }
            }), adjustAxes());
        }, gridProto.getAxis = function(axisType, axisIndex) {
            var axesMapOnDim = this._axesMap[axisType];
            if (null != axesMapOnDim) {
                if (null == axisIndex) for (var name in axesMapOnDim) if (axesMapOnDim.hasOwnProperty(name)) return axesMapOnDim[name];
                return axesMapOnDim[axisIndex];
            }
        }, gridProto.getAxes = function() {
            return this._axesList.slice();
        }, gridProto.getCartesian = function(xAxisIndex, yAxisIndex) {
            if (null != xAxisIndex && null != yAxisIndex) {
                var key = "x" + xAxisIndex + "y" + yAxisIndex;
                return this._coordsMap[key];
            }
            isObject(xAxisIndex) && (yAxisIndex = xAxisIndex.yAxisIndex, xAxisIndex = xAxisIndex.xAxisIndex);
            for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) if (coordList[i].getAxis("x").index === xAxisIndex || coordList[i].getAxis("y").index === yAxisIndex) return coordList[i];
        }, gridProto.getCartesians = function() {
            return this._coordsList.slice();
        }, gridProto.convertToPixel = function(ecModel, finder, value) {
            var target = this._findConvertTarget(ecModel, finder);
            return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;
        }, gridProto.convertFromPixel = function(ecModel, finder, value) {
            var target = this._findConvertTarget(ecModel, finder);
            return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;
        }, gridProto._findConvertTarget = function(ecModel, finder) {
            var cartesian, axis, seriesModel = finder.seriesModel, xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents("xAxis")[0], yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents("yAxis")[0], gridModel = finder.gridModel, coordsList = this._coordsList;
            if (seriesModel) cartesian = seriesModel.coordinateSystem, indexOf(coordsList, cartesian) < 0 && (cartesian = null); else if (xAxisModel && yAxisModel) cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex); else if (xAxisModel) axis = this.getAxis("x", xAxisModel.componentIndex); else if (yAxisModel) axis = this.getAxis("y", yAxisModel.componentIndex); else if (gridModel) {
                gridModel.coordinateSystem === this && (cartesian = this._coordsList[0]);
            }
            return {
                cartesian: cartesian,
                axis: axis
            };
        }, gridProto.containPoint = function(point) {
            var coord = this._coordsList[0];
            if (coord) return coord.containPoint(point);
        }, gridProto._initCartesian = function(gridModel, ecModel, api) {
            var axisPositionUsed = {
                left: !1,
                right: !1,
                top: !1,
                bottom: !1
            }, axesMap = {
                x: {},
                y: {}
            }, axesCount = {
                x: 0,
                y: 0
            };
            if (ecModel.eachComponent("xAxis", createAxisCreator("x"), this), ecModel.eachComponent("yAxis", createAxisCreator("y"), this), 
            !axesCount.x || !axesCount.y) return this._axesMap = {}, void (this._axesList = []);
            function createAxisCreator(axisType) {
                return function(axisModel, idx) {
                    if (isAxisUsedInTheGrid(axisModel, gridModel)) {
                        var axisPosition = axisModel.get("position");
                        "x" === axisType ? "top" !== axisPosition && "bottom" !== axisPosition && (axisPosition = axisPositionUsed.bottom ? "top" : "bottom") : "left" !== axisPosition && "right" !== axisPosition && (axisPosition = axisPositionUsed.left ? "right" : "left"), 
                        axisPositionUsed[axisPosition] = !0;
                        var axis = new Axis2D(axisType, createScaleByModel(axisModel), [ 0, 0 ], axisModel.get("type"), axisPosition), isCategory = "category" === axis.type;
                        axis.onBand = isCategory && axisModel.get("boundaryGap"), axis.inverse = axisModel.get("inverse"), 
                        axisModel.axis = axis, axis.model = axisModel, axis.grid = this, axis.index = idx, 
                        this._axesList.push(axis), axesMap[axisType][idx] = axis, axesCount[axisType]++;
                    }
                };
            }
            this._axesMap = axesMap, each(axesMap.x, function(xAxis, xAxisIndex) {
                each(axesMap.y, function(yAxis, yAxisIndex) {
                    var key = "x" + xAxisIndex + "y" + yAxisIndex, cartesian = new Cartesian2D(key);
                    cartesian.grid = this, cartesian.model = gridModel, this._coordsMap[key] = cartesian, 
                    this._coordsList.push(cartesian), cartesian.addAxis(xAxis), cartesian.addAxis(yAxis);
                }, this);
            }, this);
        }, gridProto._updateScale = function(ecModel, gridModel) {
            function unionExtent(data, axis, seriesModel) {
                each(data.mapDimension(axis.dim, !0), function(dim) {
                    axis.scale.unionExtentFromData(data, getStackedDimension(data, dim));
                });
            }
            each(this._axesList, function(axis) {
                axis.scale.setExtent(1 / 0, -1 / 0);
            }), ecModel.eachSeries(function(seriesModel) {
                if (isCartesian2D(seriesModel)) {
                    var axesModels = findAxesModels(seriesModel, ecModel), xAxisModel = axesModels[0], yAxisModel = axesModels[1];
                    if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) return;
                    var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex), data = seriesModel.getData(), xAxis = cartesian.getAxis("x"), yAxis = cartesian.getAxis("y");
                    "list" === data.type && (unionExtent(data, xAxis, seriesModel), unionExtent(data, yAxis, seriesModel));
                }
            }, this);
        }, gridProto.getTooltipAxes = function(dim) {
            var baseAxes = [], otherAxes = [];
            return each(this.getCartesians(), function(cartesian) {
                var baseAxis = null != dim && "auto" !== dim ? cartesian.getAxis(dim) : cartesian.getBaseAxis(), otherAxis = cartesian.getOtherAxis(baseAxis);
                indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis), indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);
            }), {
                baseAxes: baseAxes,
                otherAxes: otherAxes
            };
        };
        var axesTypes = [ "xAxis", "yAxis" ];
        function findAxesModels(seriesModel, ecModel) {
            return map(axesTypes, function(axisType) {
                return seriesModel.getReferringComponents(axisType)[0];
            });
        }
        function isCartesian2D(seriesModel) {
            return "cartesian2d" === seriesModel.get("coordinateSystem");
        }
        Grid.create = function(ecModel, api) {
            var grids = [];
            return ecModel.eachComponent("grid", function(gridModel, idx) {
                var grid = new Grid(gridModel, ecModel, api);
                grid.name = "grid_" + idx, grid.resize(gridModel, api, !0), gridModel.coordinateSystem = grid, 
                grids.push(grid);
            }), ecModel.eachSeries(function(seriesModel) {
                if (isCartesian2D(seriesModel)) {
                    var axesModels = findAxesModels(seriesModel), xAxisModel = axesModels[0], yAxisModel = axesModels[1], grid = xAxisModel.getCoordSysModel().coordinateSystem;
                    seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
                }
            }), grids;
        }, Grid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions, 
        CoordinateSystem.register("cartesian2d", Grid);
        var _default = Grid;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), Cartesian = __webpack_require__(251);
        function Cartesian2D(name) {
            Cartesian.call(this, name);
        }
        Cartesian2D.prototype = {
            constructor: Cartesian2D,
            type: "cartesian2d",
            dimensions: [ "x", "y" ],
            getBaseAxis: function() {
                return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
            },
            containPoint: function(point) {
                var axisX = this.getAxis("x"), axisY = this.getAxis("y");
                return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));
            },
            containData: function(data) {
                return this.getAxis("x").containData(data[0]) && this.getAxis("y").containData(data[1]);
            },
            dataToPoint: function(data, reserved, out) {
                var xAxis = this.getAxis("x"), yAxis = this.getAxis("y");
                return (out = out || [])[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(data[0])), out[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(data[1])), 
                out;
            },
            clampData: function(data, out) {
                var xScale = this.getAxis("x").scale, yScale = this.getAxis("y").scale, xAxisExtent = xScale.getExtent(), yAxisExtent = yScale.getExtent(), x = xScale.parse(data[0]), y = yScale.parse(data[1]);
                return (out = out || [])[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1])), 
                out[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1])), 
                out;
            },
            pointToData: function(point, out) {
                var xAxis = this.getAxis("x"), yAxis = this.getAxis("y");
                return (out = out || [])[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0])), out[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1])), 
                out;
            },
            getOtherAxis: function(axis) {
                return this.getAxis("x" === axis.dim ? "y" : "x");
            }
        }, zrUtil.inherits(Cartesian2D, Cartesian);
        var _default = Cartesian2D;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0);
        function dimAxisMapper(dim) {
            return this._axes[dim];
        }
        var Cartesian = function(name) {
            this._axes = {}, this._dimList = [], this.name = name || "";
        };
        Cartesian.prototype = {
            constructor: Cartesian,
            type: "cartesian",
            getAxis: function(dim) {
                return this._axes[dim];
            },
            getAxes: function() {
                return zrUtil.map(this._dimList, dimAxisMapper, this);
            },
            getAxesByScale: function(scaleType) {
                return scaleType = scaleType.toLowerCase(), zrUtil.filter(this.getAxes(), function(axis) {
                    return axis.scale.type === scaleType;
                });
            },
            addAxis: function(axis) {
                var dim = axis.dim;
                this._axes[dim] = axis, this._dimList.push(dim);
            },
            dataToCoord: function(val) {
                return this._dataCoordConvert(val, "dataToCoord");
            },
            coordToData: function(val) {
                return this._dataCoordConvert(val, "coordToData");
            },
            _dataCoordConvert: function(input, method) {
                for (var dimList = this._dimList, output = input instanceof Array ? [] : {}, i = 0; i < dimList.length; i++) {
                    var dim = dimList[i], axis = this._axes[dim];
                    output[dim] = axis[method](input[dim]);
                }
                return output;
            }
        };
        var _default = Cartesian;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), Axis = __webpack_require__(123), Axis2D = function(dim, scale, coordExtent, axisType, position) {
            Axis.call(this, dim, scale, coordExtent), this.type = axisType || "value", this.position = position || "bottom";
        };
        Axis2D.prototype = {
            constructor: Axis2D,
            index: 0,
            getAxesOnZeroOf: null,
            model: null,
            isHorizontal: function() {
                var position = this.position;
                return "top" === position || "bottom" === position;
            },
            getGlobalExtent: function(asc) {
                var ret = this.getExtent();
                return ret[0] = this.toGlobalCoord(ret[0]), ret[1] = this.toGlobalCoord(ret[1]), 
                asc && ret[0] > ret[1] && ret.reverse(), ret;
            },
            getOtherAxis: function() {
                this.grid.getOtherAxis();
            },
            pointToData: function(point, clamp) {
                return this.coordToData(this.toLocalCoord(point["x" === this.dim ? 0 : 1]), clamp);
            },
            toLocalCoord: null,
            toGlobalCoord: null
        }, zrUtil.inherits(Axis2D, Axis);
        var _default = Axis2D;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(126);
        var _default = __webpack_require__(13).extend({
            type: "grid",
            dependencies: [ "xAxis", "yAxis" ],
            layoutMode: "box",
            coordinateSystem: null,
            defaultOption: {
                show: !1,
                zlevel: 0,
                z: 0,
                left: "10%",
                top: 60,
                right: "10%",
                bottom: 60,
                containLabel: !1,
                backgroundColor: "rgba(0,0,0,0)",
                borderWidth: 1,
                borderColor: "#ccc"
            }
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), axisDefault = __webpack_require__(255), ComponentModel = __webpack_require__(13), _layout = __webpack_require__(10), getLayoutParams = _layout.getLayoutParams, mergeLayoutParam = _layout.mergeLayoutParam, OrdinalMeta = __webpack_require__(119), AXIS_TYPES = [ "value", "category", "time", "log" ];
        module.exports = function(axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {
            zrUtil.each(AXIS_TYPES, function(axisType) {
                BaseAxisModelClass.extend({
                    type: axisName + "Axis." + axisType,
                    mergeDefaultAndTheme: function(option, ecModel) {
                        var layoutMode = this.layoutMode, inputPositionParams = layoutMode ? getLayoutParams(option) : {}, themeModel = ecModel.getTheme();
                        zrUtil.merge(option, themeModel.get(axisType + "Axis")), zrUtil.merge(option, this.getDefaultOption()), 
                        option.type = axisTypeDefaulter(axisName, option), layoutMode && mergeLayoutParam(option, inputPositionParams, layoutMode);
                    },
                    optionUpdated: function() {
                        "category" === this.option.type && (this.__ordinalMeta = OrdinalMeta.createByAxisModel(this));
                    },
                    getCategories: function(rawData) {
                        var option = this.option;
                        if ("category" === option.type) return rawData ? option.data : this.__ordinalMeta.categories;
                    },
                    getOrdinalMeta: function() {
                        return this.__ordinalMeta;
                    },
                    defaultOption: zrUtil.mergeAll([ {}, axisDefault[axisType + "Axis"], extraDefaultOption ], !0)
                });
            }), ComponentModel.registerSubTypeDefaulter(axisName + "Axis", zrUtil.curry(axisTypeDefaulter, axisName));
        };
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), defaultOption = {
            show: !0,
            zlevel: 0,
            z: 0,
            inverse: !1,
            name: "",
            nameLocation: "end",
            nameRotate: null,
            nameTruncate: {
                maxWidth: null,
                ellipsis: "...",
                placeholder: "."
            },
            nameTextStyle: {},
            nameGap: 15,
            silent: !1,
            triggerEvent: !1,
            tooltip: {
                show: !1
            },
            axisPointer: {},
            axisLine: {
                show: !0,
                onZero: !0,
                onZeroAxisIndex: null,
                lineStyle: {
                    color: "#333",
                    width: 1,
                    type: "solid"
                },
                symbol: [ "none", "none" ],
                symbolSize: [ 10, 15 ]
            },
            axisTick: {
                show: !0,
                inside: !1,
                length: 5,
                lineStyle: {
                    width: 1
                }
            },
            axisLabel: {
                show: !0,
                inside: !1,
                rotate: 0,
                showMinLabel: null,
                showMaxLabel: null,
                margin: 8,
                fontSize: 12
            },
            splitLine: {
                show: !0,
                lineStyle: {
                    color: [ "#ccc" ],
                    width: 1,
                    type: "solid"
                }
            },
            splitArea: {
                show: !1,
                areaStyle: {
                    color: [ "rgba(250,250,250,0.3)", "rgba(200,200,200,0.3)" ]
                }
            }
        }, axisDefault = {};
        axisDefault.categoryAxis = zrUtil.merge({
            boundaryGap: !0,
            deduplication: null,
            splitLine: {
                show: !1
            },
            axisTick: {
                alignWithLabel: !1,
                interval: "auto"
            },
            axisLabel: {
                interval: "auto"
            }
        }, defaultOption), axisDefault.valueAxis = zrUtil.merge({
            boundaryGap: [ 0, 0 ],
            splitNumber: 5
        }, defaultOption), axisDefault.timeAxis = zrUtil.defaults({
            scale: !0,
            min: "dataMin",
            max: "dataMax"
        }, axisDefault.valueAxis), axisDefault.logAxis = zrUtil.defaults({
            scale: !0,
            logBase: 10
        }, axisDefault.valueAxis);
        var _default = axisDefault;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(126), __webpack_require__(257);
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), graphic = __webpack_require__(2), AxisBuilder = __webpack_require__(127), AxisView = __webpack_require__(128), cartesianAxisHelper = __webpack_require__(129), axisBuilderAttrs = [ "axisLine", "axisTickLabel", "axisName" ], selfBuilderAttrs = [ "splitArea", "splitLine" ], CartesianAxisView = AxisView.extend({
            type: "cartesianAxis",
            axisPointerClass: "CartesianAxisPointer",
            render: function(axisModel, ecModel, api, payload) {
                this.group.removeAll();
                var oldAxisGroup = this._axisGroup;
                if (this._axisGroup = new graphic.Group(), this.group.add(this._axisGroup), axisModel.get("show")) {
                    var gridModel = axisModel.getCoordSysModel(), layout = cartesianAxisHelper.layout(gridModel, axisModel), axisBuilder = new AxisBuilder(axisModel, layout);
                    zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder), this._axisGroup.add(axisBuilder.getGroup()), 
                    zrUtil.each(selfBuilderAttrs, function(name) {
                        axisModel.get(name + ".show") && this["_" + name](axisModel, gridModel);
                    }, this), graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel), CartesianAxisView.superCall(this, "render", axisModel, ecModel, api, payload);
                }
            },
            remove: function() {
                this._splitAreaColors = null;
            },
            _splitLine: function(axisModel, gridModel) {
                var axis = axisModel.axis;
                if (!axis.scale.isBlank()) {
                    var splitLineModel = axisModel.getModel("splitLine"), lineStyleModel = splitLineModel.getModel("lineStyle"), lineColors = lineStyleModel.get("color");
                    lineColors = zrUtil.isArray(lineColors) ? lineColors : [ lineColors ];
                    for (var gridRect = gridModel.coordinateSystem.getRect(), isHorizontal = axis.isHorizontal(), lineCount = 0, ticksCoords = axis.getTicksCoords({
                        tickModel: splitLineModel
                    }), p1 = [], p2 = [], lineStyle = lineStyleModel.getLineStyle(), i = 0; i < ticksCoords.length; i++) {
                        var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
                        isHorizontal ? (p1[0] = tickCoord, p1[1] = gridRect.y, p2[0] = tickCoord, p2[1] = gridRect.y + gridRect.height) : (p1[0] = gridRect.x, 
                        p1[1] = tickCoord, p2[0] = gridRect.x + gridRect.width, p2[1] = tickCoord);
                        var colorIndex = lineCount++ % lineColors.length, tickValue = ticksCoords[i].tickValue;
                        this._axisGroup.add(new graphic.Line({
                            anid: null != tickValue ? "line_" + ticksCoords[i].tickValue : null,
                            subPixelOptimize: !0,
                            shape: {
                                x1: p1[0],
                                y1: p1[1],
                                x2: p2[0],
                                y2: p2[1]
                            },
                            style: zrUtil.defaults({
                                stroke: lineColors[colorIndex]
                            }, lineStyle),
                            silent: !0
                        }));
                    }
                }
            },
            _splitArea: function(axisModel, gridModel) {
                var axis = axisModel.axis;
                if (!axis.scale.isBlank()) {
                    var splitAreaModel = axisModel.getModel("splitArea"), areaStyleModel = splitAreaModel.getModel("areaStyle"), areaColors = areaStyleModel.get("color"), gridRect = gridModel.coordinateSystem.getRect(), ticksCoords = axis.getTicksCoords({
                        tickModel: splitAreaModel,
                        clamp: !0
                    });
                    if (ticksCoords.length) {
                        var areaColorsLen = areaColors.length, lastSplitAreaColors = this._splitAreaColors, newSplitAreaColors = zrUtil.createHashMap(), colorIndex = 0;
                        if (lastSplitAreaColors) for (var i = 0; i < ticksCoords.length; i++) {
                            var cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);
                            if (null != cIndex) {
                                colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;
                                break;
                            }
                        }
                        var prev = axis.toGlobalCoord(ticksCoords[0].coord), areaStyle = areaStyleModel.getAreaStyle();
                        areaColors = zrUtil.isArray(areaColors) ? areaColors : [ areaColors ];
                        for (i = 1; i < ticksCoords.length; i++) {
                            var x, y, width, height, tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
                            axis.isHorizontal() ? (x = prev, y = gridRect.y, width = tickCoord - x, height = gridRect.height, 
                            prev = x + width) : (x = gridRect.x, y = prev, width = gridRect.width, prev = y + (height = tickCoord - y));
                            var tickValue = ticksCoords[i - 1].tickValue;
                            null != tickValue && newSplitAreaColors.set(tickValue, colorIndex), this._axisGroup.add(new graphic.Rect({
                                anid: null != tickValue ? "area_" + tickValue : null,
                                shape: {
                                    x: x,
                                    y: y,
                                    width: width,
                                    height: height
                                },
                                style: zrUtil.defaults({
                                    fill: areaColors[colorIndex]
                                }, areaStyle),
                                silent: !0
                            })), colorIndex = (colorIndex + 1) % areaColorsLen;
                        }
                        this._splitAreaColors = newSplitAreaColors;
                    }
                }
            }
        });
        CartesianAxisView.extend({
            type: "xAxis"
        }), CartesianAxisView.extend({
            type: "yAxis"
        });
    }, function(module, exports, __webpack_require__) {
        var echarts = __webpack_require__(1);
        __webpack_require__(259), __webpack_require__(260);
        var linesLayout = __webpack_require__(133), linesVisual = __webpack_require__(264);
        echarts.registerLayout(linesLayout), echarts.registerVisual(linesVisual);
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(5).__DEV__;
        var SeriesModel = __webpack_require__(24), List = __webpack_require__(25), _util = __webpack_require__(0), concatArray = _util.concatArray, mergeAll = _util.mergeAll, map = _util.map, encodeHTML = __webpack_require__(9).encodeHTML, Uint32Arr = (__webpack_require__(41), 
        "undefined" == typeof Uint32Array ? Array : Uint32Array), Float64Arr = "undefined" == typeof Float64Array ? Array : Float64Array;
        function compatEc2(seriesOpt) {
            var data = seriesOpt.data;
            data && data[0] && data[0][0] && data[0][0].coord && (seriesOpt.data = map(data, function(itemOpt) {
                var target = {
                    coords: [ itemOpt[0].coord, itemOpt[1].coord ]
                };
                return itemOpt[0].name && (target.fromName = itemOpt[0].name), itemOpt[1].name && (target.toName = itemOpt[1].name), 
                mergeAll([ target, itemOpt[0], itemOpt[1] ]);
            }));
        }
        var LinesSeries = SeriesModel.extend({
            type: "series.lines",
            dependencies: [ "grid", "polar" ],
            visualColorAccessPath: "lineStyle.color",
            init: function(option) {
                option.data = option.data || [], compatEc2(option);
                var result = this._processFlatCoordsArray(option.data);
                this._flatCoords = result.flatCoords, this._flatCoordsOffset = result.flatCoordsOffset, 
                result.flatCoords && (option.data = new Float32Array(result.count)), LinesSeries.superApply(this, "init", arguments);
            },
            mergeOption: function(option) {
                if (option.data = option.data || [], compatEc2(option), option.data) {
                    var result = this._processFlatCoordsArray(option.data);
                    this._flatCoords = result.flatCoords, this._flatCoordsOffset = result.flatCoordsOffset, 
                    result.flatCoords && (option.data = new Float32Array(result.count));
                }
                LinesSeries.superApply(this, "mergeOption", arguments);
            },
            appendData: function(params) {
                var result = this._processFlatCoordsArray(params.data);
                result.flatCoords && (this._flatCoords ? (this._flatCoords = concatArray(this._flatCoords, result.flatCoords), 
                this._flatCoordsOffset = concatArray(this._flatCoordsOffset, result.flatCoordsOffset)) : (this._flatCoords = result.flatCoords, 
                this._flatCoordsOffset = result.flatCoordsOffset), params.data = new Float32Array(result.count)), 
                this.getRawData().appendData(params.data);
            },
            _getCoordsFromItemModel: function(idx) {
                var itemModel = this.getData().getItemModel(idx);
                return itemModel.option instanceof Array ? itemModel.option : itemModel.getShallow("coords");
            },
            getLineCoordsCount: function(idx) {
                return this._flatCoordsOffset ? this._flatCoordsOffset[2 * idx + 1] : this._getCoordsFromItemModel(idx).length;
            },
            getLineCoords: function(idx, out) {
                if (this._flatCoordsOffset) {
                    for (var offset = this._flatCoordsOffset[2 * idx], len = this._flatCoordsOffset[2 * idx + 1], i = 0; i < len; i++) out[i] = out[i] || [], 
                    out[i][0] = this._flatCoords[offset + 2 * i], out[i][1] = this._flatCoords[offset + 2 * i + 1];
                    return len;
                }
                var coords = this._getCoordsFromItemModel(idx);
                for (i = 0; i < coords.length; i++) out[i] = out[i] || [], out[i][0] = coords[i][0], 
                out[i][1] = coords[i][1];
                return coords.length;
            },
            _processFlatCoordsArray: function(data) {
                var startOffset = 0;
                if (this._flatCoords && (startOffset = this._flatCoords.length), "number" == typeof data[0]) {
                    for (var len = data.length, coordsOffsetAndLenStorage = new Uint32Arr(len), coordsStorage = new Float64Arr(len), coordsCursor = 0, offsetCursor = 0, dataCount = 0, i = 0; i < len; ) {
                        dataCount++;
                        var count = data[i++];
                        coordsOffsetAndLenStorage[offsetCursor++] = coordsCursor + startOffset, coordsOffsetAndLenStorage[offsetCursor++] = count;
                        for (var k = 0; k < count; k++) {
                            var x = data[i++], y = data[i++];
                            coordsStorage[coordsCursor++] = x, coordsStorage[coordsCursor++] = y;
                        }
                    }
                    return {
                        flatCoordsOffset: new Uint32Array(coordsOffsetAndLenStorage.buffer, 0, offsetCursor),
                        flatCoords: coordsStorage,
                        count: dataCount
                    };
                }
                return {
                    flatCoordsOffset: null,
                    flatCoords: null,
                    count: data.length
                };
            },
            getInitialData: function(option, ecModel) {
                var lineData = new List([ "value" ], this);
                return lineData.hasItemOption = !1, lineData.initData(option.data, [], function(dataItem, dimName, dataIndex, dimIndex) {
                    if (dataItem instanceof Array) return NaN;
                    lineData.hasItemOption = !0;
                    var value = dataItem.value;
                    return null != value ? value instanceof Array ? value[dimIndex] : value : void 0;
                }), lineData;
            },
            formatTooltip: function(dataIndex) {
                var itemModel = this.getData().getItemModel(dataIndex), name = itemModel.get("name");
                if (name) return name;
                var fromName = itemModel.get("fromName"), toName = itemModel.get("toName"), html = [];
                return null != fromName && html.push(fromName), null != toName && html.push(toName), 
                encodeHTML(html.join(" > "));
            },
            preventIncremental: function() {
                return !!this.get("effect.show");
            },
            getProgressive: function() {
                var progressive = this.option.progressive;
                return null == progressive ? this.option.large ? 1e4 : this.get("progressive") : progressive;
            },
            getProgressiveThreshold: function() {
                var progressiveThreshold = this.option.progressiveThreshold;
                return null == progressiveThreshold ? this.option.large ? 2e4 : this.get("progressiveThreshold") : progressiveThreshold;
            },
            defaultOption: {
                coordinateSystem: "geo",
                zlevel: 0,
                z: 2,
                legendHoverLink: !0,
                hoverAnimation: !0,
                xAxisIndex: 0,
                yAxisIndex: 0,
                symbol: [ "none", "none" ],
                symbolSize: [ 10, 10 ],
                geoIndex: 0,
                effect: {
                    show: !1,
                    period: 4,
                    constantSpeed: 0,
                    symbol: "circle",
                    symbolSize: 3,
                    loop: !0,
                    trailLength: .2
                },
                large: !1,
                largeThreshold: 2e3,
                polyline: !1,
                label: {
                    show: !1,
                    position: "end"
                },
                lineStyle: {
                    opacity: .5
                }
            }
        }), _default = LinesSeries;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(5).__DEV__;
        var echarts = __webpack_require__(1), LineDraw = __webpack_require__(130), EffectLine = __webpack_require__(131), Line = __webpack_require__(71), Polyline = __webpack_require__(132), EffectPolyline = __webpack_require__(262), LargeLineDraw = __webpack_require__(263), linesLayout = __webpack_require__(133), _default = echarts.extendChartView({
            type: "lines",
            init: function() {},
            render: function(seriesModel, ecModel, api) {
                var data = seriesModel.getData(), lineDraw = this._updateLineDraw(data, seriesModel), zlevel = seriesModel.get("zlevel"), trailLength = seriesModel.get("effect.trailLength"), zr = api.getZr(), isSvg = "svg" === zr.painter.getType();
                isSvg || zr.painter.getLayer(zlevel).clear(!0), null == this._lastZlevel || isSvg || zr.configLayer(this._lastZlevel, {
                    motionBlur: !1
                }), this._showEffect(seriesModel) && trailLength && (isSvg || zr.configLayer(zlevel, {
                    motionBlur: !0,
                    lastFrameAlpha: Math.max(Math.min(trailLength / 10 + .9, 1), 0)
                })), lineDraw.updateData(data), this._lastZlevel = zlevel, this._finished = !0;
            },
            incrementalPrepareRender: function(seriesModel, ecModel, api) {
                var data = seriesModel.getData();
                this._updateLineDraw(data, seriesModel).incrementalPrepareUpdate(data), this._clearLayer(api), 
                this._finished = !1;
            },
            incrementalRender: function(taskParams, seriesModel, ecModel) {
                this._lineDraw.incrementalUpdate(taskParams, seriesModel.getData()), this._finished = taskParams.end === seriesModel.getData().count();
            },
            updateTransform: function(seriesModel, ecModel, api) {
                var data = seriesModel.getData(), pipelineContext = seriesModel.pipelineContext;
                if (!this._finished || pipelineContext.large || pipelineContext.progressiveRender) return {
                    update: !0
                };
                var res = linesLayout.reset(seriesModel);
                res.progress && res.progress({
                    start: 0,
                    end: data.count()
                }, data), this._lineDraw.updateLayout(), this._clearLayer(api);
            },
            _updateLineDraw: function(data, seriesModel) {
                var lineDraw = this._lineDraw, hasEffect = this._showEffect(seriesModel), isPolyline = !!seriesModel.get("polyline"), isLargeDraw = seriesModel.pipelineContext.large;
                return lineDraw && hasEffect === this._hasEffet && isPolyline === this._isPolyline && isLargeDraw === this._isLargeDraw || (lineDraw && lineDraw.remove(), 
                lineDraw = this._lineDraw = isLargeDraw ? new LargeLineDraw() : new LineDraw(isPolyline ? hasEffect ? EffectPolyline : Polyline : hasEffect ? EffectLine : Line), 
                this._hasEffet = hasEffect, this._isPolyline = isPolyline, this._isLargeDraw = isLargeDraw, 
                this.group.removeAll()), this.group.add(lineDraw.group), lineDraw;
            },
            _showEffect: function(seriesModel) {
                return !!seriesModel.get("effect.show");
            },
            _clearLayer: function(api) {
                var zr = api.getZr();
                "svg" === zr.painter.getType() || null == this._lastZlevel || zr.painter.getLayer(this._lastZlevel).clear(!0);
            },
            remove: function(ecModel, api) {
                this._lineDraw && this._lineDraw.remove(), this._lineDraw = null, this._clearLayer(api);
            },
            dispose: function() {}
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var graphic = __webpack_require__(2), vec2 = __webpack_require__(6), straightLineProto = graphic.Line.prototype, bezierCurveProto = graphic.BezierCurve.prototype;
        function isLine(shape) {
            return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);
        }
        var _default = graphic.extendShape({
            type: "ec-line",
            style: {
                stroke: "#000",
                fill: null
            },
            shape: {
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 0,
                percent: 1,
                cpx1: null,
                cpy1: null
            },
            buildPath: function(ctx, shape) {
                this[isLine(shape) ? "_buildPathLine" : "_buildPathCurve"](ctx, shape);
            },
            _buildPathLine: straightLineProto.buildPath,
            _buildPathCurve: bezierCurveProto.buildPath,
            pointAt: function(t) {
                return this[isLine(this.shape) ? "_pointAtLine" : "_pointAtCurve"](t);
            },
            _pointAtLine: straightLineProto.pointAt,
            _pointAtCurve: bezierCurveProto.pointAt,
            tangentAt: function(t) {
                var shape = this.shape, p = isLine(shape) ? [ shape.x2 - shape.x1, shape.y2 - shape.y1 ] : this._tangentAtCurve(t);
                return vec2.normalize(p, p);
            },
            _tangentAtCurve: bezierCurveProto.tangentAt
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var Polyline = __webpack_require__(132), zrUtil = __webpack_require__(0), EffectLine = __webpack_require__(131), vec2 = __webpack_require__(6);
        function EffectPolyline(lineData, idx, seriesScope) {
            EffectLine.call(this, lineData, idx, seriesScope), this._lastFrame = 0, this._lastFramePercent = 0;
        }
        var effectPolylineProto = EffectPolyline.prototype;
        effectPolylineProto.createLine = function(lineData, idx, seriesScope) {
            return new Polyline(lineData, idx, seriesScope);
        }, effectPolylineProto.updateAnimationPoints = function(symbol, points) {
            this._points = points;
            for (var accLenArr = [ 0 ], len = 0, i = 1; i < points.length; i++) {
                var p1 = points[i - 1], p2 = points[i];
                len += vec2.dist(p1, p2), accLenArr.push(len);
            }
            if (0 !== len) {
                for (i = 0; i < accLenArr.length; i++) accLenArr[i] /= len;
                this._offsets = accLenArr, this._length = len;
            }
        }, effectPolylineProto.getLineLength = function(symbol) {
            return this._length;
        }, effectPolylineProto.updateSymbolPosition = function(symbol) {
            var t = symbol.__t, points = this._points, offsets = this._offsets, len = points.length;
            if (offsets) {
                var lastFrame = this._lastFrame;
                if (t < this._lastFramePercent) {
                    for (frame = Math.min(lastFrame + 1, len - 1); frame >= 0 && !(offsets[frame] <= t); frame--) ;
                    frame = Math.min(frame, len - 2);
                } else {
                    for (var frame = lastFrame; frame < len && !(offsets[frame] > t); frame++) ;
                    frame = Math.min(frame - 1, len - 2);
                }
                vec2.lerp(symbol.position, points[frame], points[frame + 1], (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame]));
                var tx = points[frame + 1][0] - points[frame][0], ty = points[frame + 1][1] - points[frame][1];
                symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2, this._lastFrame = frame, this._lastFramePercent = t, 
                symbol.ignore = !1;
            }
        }, zrUtil.inherits(EffectPolyline, EffectLine);
        var _default = EffectPolyline;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var graphic = __webpack_require__(2), IncrementalDisplayable = __webpack_require__(62), lineContain = __webpack_require__(101), quadraticContain = __webpack_require__(102), LargeLineShape = graphic.extendShape({
            shape: {
                polyline: !1,
                curveness: 0,
                segs: []
            },
            buildPath: function(path, shape) {
                var segs = shape.segs, curveness = shape.curveness;
                if (shape.polyline) for (var i = 0; i < segs.length; ) {
                    var count = segs[i++];
                    if (count > 0) {
                        path.moveTo(segs[i++], segs[i++]);
                        for (var k = 1; k < count; k++) path.lineTo(segs[i++], segs[i++]);
                    }
                } else for (i = 0; i < segs.length; ) {
                    var x0 = segs[i++], y0 = segs[i++], x1 = segs[i++], y1 = segs[i++];
                    if (path.moveTo(x0, y0), curveness > 0) {
                        var x2 = (x0 + x1) / 2 - (y0 - y1) * curveness, y2 = (y0 + y1) / 2 - (x1 - x0) * curveness;
                        path.quadraticCurveTo(x2, y2, x1, y1);
                    } else path.lineTo(x1, y1);
                }
            },
            findDataIndex: function(x, y) {
                var shape = this.shape, segs = shape.segs, curveness = shape.curveness;
                if (shape.polyline) for (var dataIndex = 0, i = 0; i < segs.length; ) {
                    var count = segs[i++];
                    if (count > 0) for (var x0 = segs[i++], y0 = segs[i++], k = 1; k < count; k++) {
                        var x1 = segs[i++], y1 = segs[i++];
                        if (lineContain.containStroke(x0, y0, x1, y1)) return dataIndex;
                    }
                    dataIndex++;
                } else for (dataIndex = 0, i = 0; i < segs.length; ) {
                    x0 = segs[i++], y0 = segs[i++], x1 = segs[i++], y1 = segs[i++];
                    if (curveness > 0) {
                        var x2 = (x0 + x1) / 2 - (y0 - y1) * curveness, y2 = (y0 + y1) / 2 - (x1 - x0) * curveness;
                        if (quadraticContain.containStroke(x0, y0, x2, y2, x1, y1)) return dataIndex;
                    } else if (lineContain.containStroke(x0, y0, x1, y1)) return dataIndex;
                    dataIndex++;
                }
                return -1;
            }
        });
        function LargeLineDraw() {
            this.group = new graphic.Group();
        }
        var largeLineProto = LargeLineDraw.prototype;
        largeLineProto.isPersistent = function() {
            return !this._incremental;
        }, largeLineProto.updateData = function(data) {
            this.group.removeAll();
            var lineEl = new LargeLineShape({
                rectHover: !0,
                cursor: "default"
            });
            lineEl.setShape({
                segs: data.getLayout("linesPoints")
            }), this._setCommon(lineEl, data), this.group.add(lineEl), this._incremental = null;
        }, largeLineProto.incrementalPrepareUpdate = function(data) {
            this.group.removeAll(), this._clearIncremental(), data.count() > 5e5 ? (this._incremental || (this._incremental = new IncrementalDisplayable({
                silent: !0
            })), this.group.add(this._incremental)) : this._incremental = null;
        }, largeLineProto.incrementalUpdate = function(taskParams, data) {
            var lineEl = new LargeLineShape();
            lineEl.setShape({
                segs: data.getLayout("linesPoints")
            }), this._setCommon(lineEl, data, !!this._incremental), this._incremental ? this._incremental.addDisplayable(lineEl, !0) : (lineEl.rectHover = !0, 
            lineEl.cursor = "default", lineEl.__startIndex = taskParams.start, this.group.add(lineEl));
        }, largeLineProto.remove = function() {
            this._clearIncremental(), this._incremental = null, this.group.removeAll();
        }, largeLineProto._setCommon = function(lineEl, data, isIncremental) {
            var hostModel = data.hostModel;
            lineEl.setShape({
                polyline: hostModel.get("polyline"),
                curveness: hostModel.get("lineStyle.curveness")
            }), lineEl.useStyle(hostModel.getModel("lineStyle").getLineStyle()), lineEl.style.strokeNoScale = !0;
            var visualColor = data.getVisual("color");
            visualColor && lineEl.setStyle("stroke", visualColor), lineEl.setStyle("fill"), 
            isIncremental || (lineEl.seriesIndex = hostModel.seriesIndex, lineEl.on("mousemove", function(e) {
                lineEl.dataIndex = null;
                var dataIndex = lineEl.findDataIndex(e.offsetX, e.offsetY);
                dataIndex > 0 && (lineEl.dataIndex = dataIndex + lineEl.__startIndex);
            }));
        }, largeLineProto._clearIncremental = function() {
            var incremental = this._incremental;
            incremental && incremental.clearDisplaybles();
        };
        var _default = LargeLineDraw;
        module.exports = _default;
    }, function(module, exports) {
        function normalize(a) {
            return a instanceof Array || (a = [ a, a ]), a;
        }
        var opacityQuery = "lineStyle.opacity".split("."), _default = {
            seriesType: "lines",
            reset: function(seriesModel, ecModel, api) {
                var symbolType = normalize(seriesModel.get("symbol")), symbolSize = normalize(seriesModel.get("symbolSize")), data = seriesModel.getData();
                return data.setVisual("fromSymbol", symbolType && symbolType[0]), data.setVisual("toSymbol", symbolType && symbolType[1]), 
                data.setVisual("fromSymbolSize", symbolSize && symbolSize[0]), data.setVisual("toSymbolSize", symbolSize && symbolSize[1]), 
                data.setVisual("opacity", seriesModel.get(opacityQuery)), {
                    dataEach: data.hasItemOption ? function(data, idx) {
                        var itemModel = data.getItemModel(idx), symbolType = normalize(itemModel.getShallow("symbol", !0)), symbolSize = normalize(itemModel.getShallow("symbolSize", !0)), opacity = itemModel.get(opacityQuery);
                        symbolType[0] && data.setItemVisual(idx, "fromSymbol", symbolType[0]), symbolType[1] && data.setItemVisual(idx, "toSymbol", symbolType[1]), 
                        symbolSize[0] && data.setItemVisual(idx, "fromSymbolSize", symbolSize[0]), symbolSize[1] && data.setItemVisual(idx, "toSymbolSize", symbolSize[1]), 
                        data.setItemVisual(idx, "opacity", opacity);
                    } : null
                };
            }
        };
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var echarts = __webpack_require__(1);
        __webpack_require__(266), __webpack_require__(267);
        var visualSymbol = __webpack_require__(69), layoutPoints = __webpack_require__(33);
        __webpack_require__(70), echarts.registerVisual(visualSymbol("scatter", "circle")), 
        echarts.registerLayout(layoutPoints("scatter"));
    }, function(module, exports, __webpack_require__) {
        var createListFromArray = __webpack_require__(32), _default = __webpack_require__(24).extend({
            type: "series.scatter",
            dependencies: [ "grid", "polar", "geo", "singleAxis", "calendar" ],
            getInitialData: function(option, ecModel) {
                return createListFromArray(this.getSource(), this);
            },
            brushSelector: "point",
            getProgressive: function() {
                var progressive = this.option.progressive;
                return null == progressive ? this.option.large ? 5e3 : this.get("progressive") : progressive;
            },
            getProgressiveThreshold: function() {
                var progressiveThreshold = this.option.progressiveThreshold;
                return null == progressiveThreshold ? this.option.large ? 1e4 : this.get("progressiveThreshold") : progressiveThreshold;
            },
            defaultOption: {
                coordinateSystem: "cartesian2d",
                zlevel: 0,
                z: 2,
                legendHoverLink: !0,
                hoverAnimation: !0,
                symbolSize: 10,
                large: !1,
                largeThreshold: 2e3,
                itemStyle: {
                    opacity: .8
                }
            }
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var echarts = __webpack_require__(1), SymbolDraw = __webpack_require__(44), LargeSymbolDraw = __webpack_require__(268), pointsLayout = __webpack_require__(33);
        echarts.extendChartView({
            type: "scatter",
            render: function(seriesModel, ecModel, api) {
                var data = seriesModel.getData();
                this._updateSymbolDraw(data, seriesModel).updateData(data), this._finished = !0;
            },
            incrementalPrepareRender: function(seriesModel, ecModel, api) {
                var data = seriesModel.getData();
                this._updateSymbolDraw(data, seriesModel).incrementalPrepareUpdate(data), this._finished = !1;
            },
            incrementalRender: function(taskParams, seriesModel, ecModel) {
                this._symbolDraw.incrementalUpdate(taskParams, seriesModel.getData()), this._finished = taskParams.end === seriesModel.getData().count();
            },
            updateTransform: function(seriesModel, ecModel, api) {
                var data = seriesModel.getData();
                if (this.group.dirty(), !this._finished || data.count() > 1e4 || !this._symbolDraw.isPersistent()) return {
                    update: !0
                };
                var res = pointsLayout().reset(seriesModel);
                res.progress && res.progress({
                    start: 0,
                    end: data.count()
                }, data), this._symbolDraw.updateLayout(data);
            },
            _updateSymbolDraw: function(data, seriesModel) {
                var symbolDraw = this._symbolDraw, isLargeDraw = seriesModel.pipelineContext.large;
                return symbolDraw && isLargeDraw === this._isLargeDraw || (symbolDraw && symbolDraw.remove(), 
                symbolDraw = this._symbolDraw = isLargeDraw ? new LargeSymbolDraw() : new SymbolDraw(), 
                this._isLargeDraw = isLargeDraw, this.group.removeAll()), this.group.add(symbolDraw.group), 
                symbolDraw;
            },
            remove: function(ecModel, api) {
                this._symbolDraw && this._symbolDraw.remove(!0), this._symbolDraw = null;
            },
            dispose: function() {}
        });
    }, function(module, exports, __webpack_require__) {
        var graphic = __webpack_require__(2), createSymbol = __webpack_require__(16).createSymbol, IncrementalDisplayable = __webpack_require__(62), LargeSymbolPath = graphic.extendShape({
            shape: {
                points: null
            },
            symbolProxy: null,
            buildPath: function(path, shape) {
                var points = shape.points, size = shape.size, symbolProxy = this.symbolProxy, symbolProxyShape = symbolProxy.shape;
                if (!((path.getContext ? path.getContext() : path) && size[0] < 4)) for (var i = 0; i < points.length; ) {
                    var x = points[i++], y = points[i++];
                    isNaN(x) || isNaN(y) || (symbolProxyShape.x = x - size[0] / 2, symbolProxyShape.y = y - size[1] / 2, 
                    symbolProxyShape.width = size[0], symbolProxyShape.height = size[1], symbolProxy.buildPath(path, symbolProxyShape, !0));
                }
            },
            afterBrush: function(ctx) {
                var shape = this.shape, points = shape.points, size = shape.size;
                if (size[0] < 4) {
                    this.setTransform(ctx);
                    for (var i = 0; i < points.length; ) {
                        var x = points[i++], y = points[i++];
                        isNaN(x) || isNaN(y) || ctx.fillRect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]);
                    }
                    this.restoreTransform(ctx);
                }
            },
            findDataIndex: function(x, y) {
                for (var shape = this.shape, points = shape.points, size = shape.size, w = Math.max(size[0], 4), h = Math.max(size[1], 4), idx = points.length / 2 - 1; idx >= 0; idx--) {
                    var i = 2 * idx, x0 = points[i] - w / 2, y0 = points[i + 1] - h / 2;
                    if (x >= x0 && y >= y0 && x <= x0 + w && y <= y0 + h) return idx;
                }
                return -1;
            }
        });
        function LargeSymbolDraw() {
            this.group = new graphic.Group();
        }
        var largeSymbolProto = LargeSymbolDraw.prototype;
        largeSymbolProto.isPersistent = function() {
            return !this._incremental;
        }, largeSymbolProto.updateData = function(data) {
            this.group.removeAll();
            var symbolEl = new LargeSymbolPath({
                rectHover: !0,
                cursor: "default"
            });
            symbolEl.setShape({
                points: data.getLayout("symbolPoints")
            }), this._setCommon(symbolEl, data), this.group.add(symbolEl), this._incremental = null;
        }, largeSymbolProto.updateLayout = function(data) {
            if (!this._incremental) {
                var points = data.getLayout("symbolPoints");
                this.group.eachChild(function(child) {
                    if (null != child.startIndex) {
                        var len = 2 * (child.endIndex - child.startIndex), byteOffset = 4 * child.startIndex * 2;
                        points = new Float32Array(points.buffer, byteOffset, len);
                    }
                    child.setShape("points", points);
                });
            }
        }, largeSymbolProto.incrementalPrepareUpdate = function(data) {
            this.group.removeAll(), this._clearIncremental(), data.count() > 2e6 ? (this._incremental || (this._incremental = new IncrementalDisplayable({
                silent: !0
            })), this.group.add(this._incremental)) : this._incremental = null;
        }, largeSymbolProto.incrementalUpdate = function(taskParams, data) {
            var symbolEl;
            this._incremental ? (symbolEl = new LargeSymbolPath(), this._incremental.addDisplayable(symbolEl, !0)) : ((symbolEl = new LargeSymbolPath({
                rectHover: !0,
                cursor: "default",
                startIndex: taskParams.start,
                endIndex: taskParams.end
            })).incremental = !0, this.group.add(symbolEl)), symbolEl.setShape({
                points: data.getLayout("symbolPoints")
            }), this._setCommon(symbolEl, data, !!this._incremental);
        }, largeSymbolProto._setCommon = function(symbolEl, data, isIncremental) {
            var hostModel = data.hostModel, size = data.getVisual("symbolSize");
            symbolEl.setShape("size", size instanceof Array ? size : [ size, size ]), symbolEl.symbolProxy = createSymbol(data.getVisual("symbol"), 0, 0, 0, 0), 
            symbolEl.setColor = symbolEl.symbolProxy.setColor;
            var extrudeShadow = symbolEl.shape.size[0] < 4;
            symbolEl.useStyle(hostModel.getModel("itemStyle").getItemStyle(extrudeShadow ? [ "color", "shadowBlur", "shadowColor" ] : [ "color" ]));
            var visualColor = data.getVisual("color");
            visualColor && symbolEl.setColor(visualColor), isIncremental || (symbolEl.seriesIndex = hostModel.seriesIndex, 
            symbolEl.on("mousemove", function(e) {
                symbolEl.dataIndex = null;
                var dataIndex = symbolEl.findDataIndex(e.offsetX, e.offsetY);
                dataIndex >= 0 && (symbolEl.dataIndex = dataIndex + (symbolEl.startIndex || 0));
            }));
        }, largeSymbolProto.remove = function() {
            this._clearIncremental(), this._incremental = null, this.group.removeAll();
        }, largeSymbolProto._clearIncremental = function() {
            var incremental = this._incremental;
            incremental && incremental.clearDisplaybles();
        };
        var _default = LargeSymbolDraw;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var echarts = __webpack_require__(1);
        __webpack_require__(270), __webpack_require__(271);
        var visualSymbol = __webpack_require__(69), layoutPoints = __webpack_require__(33);
        echarts.registerVisual(visualSymbol("effectScatter", "circle")), echarts.registerLayout(layoutPoints("effectScatter"));
    }, function(module, exports, __webpack_require__) {
        var createListFromArray = __webpack_require__(32), _default = __webpack_require__(24).extend({
            type: "series.effectScatter",
            dependencies: [ "grid", "polar" ],
            getInitialData: function(option, ecModel) {
                return createListFromArray(this.getSource(), this);
            },
            brushSelector: "point",
            defaultOption: {
                coordinateSystem: "cartesian2d",
                zlevel: 0,
                z: 2,
                legendHoverLink: !0,
                effectType: "ripple",
                progressive: 0,
                showEffectOn: "render",
                rippleEffect: {
                    period: 4,
                    scale: 2.5,
                    brushType: "fill"
                },
                symbolSize: 10
            }
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var echarts = __webpack_require__(1), SymbolDraw = __webpack_require__(44), EffectSymbol = __webpack_require__(272), matrix = __webpack_require__(17), pointsLayout = __webpack_require__(33), _default = echarts.extendChartView({
            type: "effectScatter",
            init: function() {
                this._symbolDraw = new SymbolDraw(EffectSymbol);
            },
            render: function(seriesModel, ecModel, api) {
                var data = seriesModel.getData(), effectSymbolDraw = this._symbolDraw;
                effectSymbolDraw.updateData(data), this.group.add(effectSymbolDraw.group);
            },
            updateTransform: function(seriesModel, ecModel, api) {
                var data = seriesModel.getData();
                this.group.dirty();
                var res = pointsLayout().reset(seriesModel);
                res.progress && res.progress({
                    start: 0,
                    end: data.count()
                }, data), this._symbolDraw.updateLayout(data);
            },
            _updateGroupTransform: function(seriesModel) {
                var coordSys = seriesModel.coordinateSystem;
                coordSys && coordSys.getRoamTransform && (this.group.transform = matrix.clone(coordSys.getRoamTransform()), 
                this.group.decomposeTransform());
            },
            remove: function(ecModel, api) {
                this._symbolDraw && this._symbolDraw.remove(api);
            },
            dispose: function() {}
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), createSymbol = __webpack_require__(16).createSymbol, Group = __webpack_require__(2).Group, parsePercent = __webpack_require__(4).parsePercent, SymbolClz = __webpack_require__(68);
        function updateRipplePath(rippleGroup, effectCfg) {
            rippleGroup.eachChild(function(ripplePath) {
                ripplePath.attr({
                    z: effectCfg.z,
                    zlevel: effectCfg.zlevel,
                    style: {
                        stroke: "stroke" === effectCfg.brushType ? effectCfg.color : null,
                        fill: "fill" === effectCfg.brushType ? effectCfg.color : null
                    }
                });
            });
        }
        function EffectSymbol(data, idx) {
            Group.call(this);
            var symbol = new SymbolClz(data, idx), rippleGroup = new Group();
            this.add(symbol), this.add(rippleGroup), rippleGroup.beforeUpdate = function() {
                this.attr(symbol.getScale());
            }, this.updateData(data, idx);
        }
        var effectSymbolProto = EffectSymbol.prototype;
        effectSymbolProto.stopEffectAnimation = function() {
            this.childAt(1).removeAll();
        }, effectSymbolProto.startEffectAnimation = function(effectCfg) {
            for (var symbolType = effectCfg.symbolType, color = effectCfg.color, rippleGroup = this.childAt(1), i = 0; i < 3; i++) {
                var ripplePath = createSymbol(symbolType, -1, -1, 2, 2, color);
                ripplePath.attr({
                    style: {
                        strokeNoScale: !0
                    },
                    z2: 99,
                    silent: !0,
                    scale: [ .5, .5 ]
                });
                var delay = -i / 3 * effectCfg.period + effectCfg.effectOffset;
                ripplePath.animate("", !0).when(effectCfg.period, {
                    scale: [ effectCfg.rippleScale / 2, effectCfg.rippleScale / 2 ]
                }).delay(delay).start(), ripplePath.animateStyle(!0).when(effectCfg.period, {
                    opacity: 0
                }).delay(delay).start(), rippleGroup.add(ripplePath);
            }
            updateRipplePath(rippleGroup, effectCfg);
        }, effectSymbolProto.updateEffectAnimation = function(effectCfg) {
            for (var oldEffectCfg = this._effectCfg, rippleGroup = this.childAt(1), DIFFICULT_PROPS = [ "symbolType", "period", "rippleScale" ], i = 0; i < DIFFICULT_PROPS.length; i++) {
                var propName = DIFFICULT_PROPS[i];
                if (oldEffectCfg[propName] !== effectCfg[propName]) return this.stopEffectAnimation(), 
                void this.startEffectAnimation(effectCfg);
            }
            updateRipplePath(rippleGroup, effectCfg);
        }, effectSymbolProto.highlight = function() {
            this.trigger("emphasis");
        }, effectSymbolProto.downplay = function() {
            this.trigger("normal");
        }, effectSymbolProto.updateData = function(data, idx) {
            var seriesModel = data.hostModel;
            this.childAt(0).updateData(data, idx);
            var rippleGroup = this.childAt(1), itemModel = data.getItemModel(idx), symbolType = data.getItemVisual(idx, "symbol"), symbolSize = function(symbolSize) {
                return zrUtil.isArray(symbolSize) || (symbolSize = [ +symbolSize, +symbolSize ]), 
                symbolSize;
            }(data.getItemVisual(idx, "symbolSize")), color = data.getItemVisual(idx, "color");
            rippleGroup.attr("scale", symbolSize), rippleGroup.traverse(function(ripplePath) {
                ripplePath.attr({
                    fill: color
                });
            });
            var symbolOffset = itemModel.getShallow("symbolOffset");
            if (symbolOffset) {
                var pos = rippleGroup.position;
                pos[0] = parsePercent(symbolOffset[0], symbolSize[0]), pos[1] = parsePercent(symbolOffset[1], symbolSize[1]);
            }
            rippleGroup.rotation = (itemModel.getShallow("symbolRotate") || 0) * Math.PI / 180 || 0;
            var effectCfg = {};
            if (effectCfg.showEffectOn = seriesModel.get("showEffectOn"), effectCfg.rippleScale = itemModel.get("rippleEffect.scale"), 
            effectCfg.brushType = itemModel.get("rippleEffect.brushType"), effectCfg.period = 1e3 * itemModel.get("rippleEffect.period"), 
            effectCfg.effectOffset = idx / data.count(), effectCfg.z = itemModel.getShallow("z") || 0, 
            effectCfg.zlevel = itemModel.getShallow("zlevel") || 0, effectCfg.symbolType = symbolType, 
            effectCfg.color = color, this.off("mouseover").off("mouseout").off("emphasis").off("normal"), 
            "render" === effectCfg.showEffectOn) this._effectCfg ? this.updateEffectAnimation(effectCfg) : this.startEffectAnimation(effectCfg), 
            this._effectCfg = effectCfg; else {
                this._effectCfg = null, this.stopEffectAnimation();
                var symbol = this.childAt(0), onEmphasis = function() {
                    symbol.highlight(), "render" !== effectCfg.showEffectOn && this.startEffectAnimation(effectCfg);
                }, onNormal = function() {
                    symbol.downplay(), "render" !== effectCfg.showEffectOn && this.stopEffectAnimation();
                };
                this.on("mouseover", onEmphasis, this).on("mouseout", onNormal, this).on("emphasis", onEmphasis, this).on("normal", onNormal, this);
            }
            this._effectCfg = effectCfg;
        }, effectSymbolProto.fadeOut = function(cb) {
            this.off("mouseover").off("mouseout").off("emphasis").off("normal"), cb && cb();
        }, zrUtil.inherits(EffectSymbol, Group);
        var _default = EffectSymbol;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(5).__DEV__;
        var zrUtil = __webpack_require__(0), graphicUtil = __webpack_require__(2), getDefaultLabel = __webpack_require__(124).getDefaultLabel, createListFromArray = __webpack_require__(32), getLayoutOnAxis = __webpack_require__(121).getLayoutOnAxis, DataDiffer = __webpack_require__(116), SeriesModel = __webpack_require__(24), Model = __webpack_require__(14), ChartView = __webpack_require__(65), prepareCartesian2d = __webpack_require__(274), prepareGeo = __webpack_require__(275), prepareSingleAxis = __webpack_require__(276), preparePolar = __webpack_require__(277), prepareCalendar = __webpack_require__(278), CACHED_LABEL_STYLE_PROPERTIES = graphicUtil.CACHED_LABEL_STYLE_PROPERTIES, ITEM_STYLE_NORMAL_PATH = [ "itemStyle" ], ITEM_STYLE_EMPHASIS_PATH = [ "emphasis", "itemStyle" ], LABEL_NORMAL = [ "label" ], LABEL_EMPHASIS = [ "emphasis", "label" ], GROUP_DIFF_PREFIX = "e\0\0", prepareCustoms = {
            cartesian2d: prepareCartesian2d,
            geo: prepareGeo,
            singleAxis: prepareSingleAxis,
            polar: preparePolar,
            calendar: prepareCalendar
        };
        function prepareStyleTransition(prop, targetStyle, elOptionStyle, oldElStyle, isInit) {
            null == elOptionStyle[prop] || isInit || (targetStyle[prop] = elOptionStyle[prop], 
            elOptionStyle[prop] = oldElStyle[prop]);
        }
        function makeRenderItem(customSeries, data, ecModel, api) {
            var renderItem = customSeries.get("renderItem"), coordSys = customSeries.coordinateSystem, prepareResult = {};
            coordSys && (prepareResult = coordSys.prepareCustoms ? coordSys.prepareCustoms() : prepareCustoms[coordSys.type](coordSys));
            var currDataIndexInside, currItemModel, currLabelNormalModel, currLabelEmphasisModel, currVisualColor, userAPI = zrUtil.defaults({
                getWidth: api.getWidth,
                getHeight: api.getHeight,
                getZr: api.getZr,
                getDevicePixelRatio: api.getDevicePixelRatio,
                value: function(dim, dataIndexInside) {
                    return null == dataIndexInside && (dataIndexInside = currDataIndexInside), data.get(data.getDimension(dim || 0), dataIndexInside);
                },
                style: function(extra, dataIndexInside) {
                    null == dataIndexInside && (dataIndexInside = currDataIndexInside), updateCache(dataIndexInside);
                    var itemStyle = currItemModel.getModel(ITEM_STYLE_NORMAL_PATH).getItemStyle();
                    null != currVisualColor && (itemStyle.fill = currVisualColor);
                    var opacity = data.getItemVisual(dataIndexInside, "opacity");
                    null != opacity && (itemStyle.opacity = opacity);
                    var labelModel = extra ? applyExtraBefore(extra, currLabelNormalModel) : currLabelNormalModel;
                    return graphicUtil.setTextStyle(itemStyle, labelModel, null, {
                        autoColor: currVisualColor,
                        isRectText: !0
                    }), itemStyle.text = labelModel.getShallow("show") ? zrUtil.retrieve2(customSeries.getFormattedLabel(dataIndexInside, "normal"), getDefaultLabel(data, dataIndexInside)) : null, 
                    extra && applyExtraAfter(itemStyle, extra), itemStyle;
                },
                styleEmphasis: function(extra, dataIndexInside) {
                    null == dataIndexInside && (dataIndexInside = currDataIndexInside), updateCache(dataIndexInside);
                    var itemStyle = currItemModel.getModel(ITEM_STYLE_EMPHASIS_PATH).getItemStyle(), labelModel = extra ? applyExtraBefore(extra, currLabelEmphasisModel) : currLabelEmphasisModel;
                    return graphicUtil.setTextStyle(itemStyle, labelModel, null, {
                        isRectText: !0
                    }, !0), itemStyle.text = labelModel.getShallow("show") ? zrUtil.retrieve3(customSeries.getFormattedLabel(dataIndexInside, "emphasis"), customSeries.getFormattedLabel(dataIndexInside, "normal"), getDefaultLabel(data, dataIndexInside)) : null, 
                    extra && applyExtraAfter(itemStyle, extra), itemStyle;
                },
                visual: function(visualType, dataIndexInside) {
                    return null == dataIndexInside && (dataIndexInside = currDataIndexInside), data.getItemVisual(dataIndexInside, visualType);
                },
                barLayout: function(opt) {
                    if (coordSys.getBaseAxis) {
                        var baseAxis = coordSys.getBaseAxis();
                        return getLayoutOnAxis(zrUtil.defaults({
                            axis: baseAxis
                        }, opt), api);
                    }
                },
                currentSeriesIndices: function() {
                    return ecModel.getCurrentSeriesIndices();
                },
                font: function(opt) {
                    return graphicUtil.getFont(opt, ecModel);
                }
            }, prepareResult.api || {}), userParams = {
                context: {},
                seriesId: customSeries.id,
                seriesName: customSeries.name,
                seriesIndex: customSeries.seriesIndex,
                coordSys: prepareResult.coordSys,
                dataInsideLength: data.count(),
                encode: function(data) {
                    var encodeDef = {};
                    return zrUtil.each(data.dimensions, function(dimName, dataDimIndex) {
                        var dimInfo = data.getDimensionInfo(dimName);
                        if (!dimInfo.isExtraCoord) {
                            var coordDim = dimInfo.coordDim;
                            (encodeDef[coordDim] = encodeDef[coordDim] || [])[dimInfo.coordDimIndex] = dataDimIndex;
                        }
                    }), encodeDef;
                }(customSeries.getData())
            }, currDirty = !0;
            return function(dataIndexInside, payload) {
                return currDataIndexInside = dataIndexInside, currDirty = !0, renderItem && renderItem(zrUtil.defaults({
                    dataIndexInside: dataIndexInside,
                    dataIndex: data.getRawIndex(dataIndexInside),
                    actionType: payload ? payload.type : null
                }, userParams), userAPI);
            };
            function updateCache(dataIndexInside) {
                null == dataIndexInside && (dataIndexInside = currDataIndexInside), currDirty && (currItemModel = data.getItemModel(dataIndexInside), 
                currLabelNormalModel = currItemModel.getModel(LABEL_NORMAL), currLabelEmphasisModel = currItemModel.getModel(LABEL_EMPHASIS), 
                currVisualColor = data.getItemVisual(dataIndexInside, "color"), currDirty = !1);
            }
        }
        function createOrUpdate(el, dataIndex, elOption, animatableModel, group, data) {
            return (el = doCreateOrUpdate(el, dataIndex, elOption, animatableModel, group, data, !0)) && data.setItemGraphicEl(dataIndex, el), 
            el;
        }
        function doCreateOrUpdate(el, dataIndex, elOption, animatableModel, group, data, isRoot) {
            var simplyRemove = !elOption, elOptionType = (elOption = elOption || {}).type, elOptionShape = elOption.shape, elOptionStyle = elOption.style;
            if (el && (simplyRemove || null != elOptionType && elOptionType !== el.__customGraphicType || "path" === elOptionType && function(shape) {
                return shape && (shape.hasOwnProperty("pathData") || shape.hasOwnProperty("d"));
            }(elOptionShape) && getPathData(elOptionShape) !== el.__customPathData || "image" === elOptionType && hasOwn(elOptionStyle, "image") && elOptionStyle.image !== el.__customImagePath || "text" === elOptionType && hasOwn(elOptionShape, "text") && elOptionStyle.text !== el.__customText) && (group.remove(el), 
            el = null), !simplyRemove) {
                var isInit = !el;
                return !el && (el = function(elOption) {
                    var el, graphicType = elOption.type;
                    if ("path" === graphicType) {
                        var shape = elOption.shape, pathRect = null != shape.width && null != shape.height ? {
                            x: shape.x || 0,
                            y: shape.y || 0,
                            width: shape.width,
                            height: shape.height
                        } : null, pathData = getPathData(shape);
                        (el = graphicUtil.makePath(pathData, null, pathRect, shape.layout || "center")).__customPathData = pathData;
                    } else "image" === graphicType ? (el = new graphicUtil.Image({})).__customImagePath = elOption.style.image : "text" === graphicType ? (el = new graphicUtil.Text({})).__customText = elOption.style.text : el = new (0, 
                    graphicUtil[graphicType.charAt(0).toUpperCase() + graphicType.slice(1)])();
                    return el.__customGraphicType = graphicType, el.name = elOption.name, el;
                }(elOption)), function(el, dataIndex, elOption, animatableModel, data, isInit, isRoot) {
                    var transitionProps = {}, elOptionStyle = elOption.style || {};
                    if (elOption.shape && (transitionProps.shape = zrUtil.clone(elOption.shape)), elOption.position && (transitionProps.position = elOption.position.slice()), 
                    elOption.scale && (transitionProps.scale = elOption.scale.slice()), elOption.origin && (transitionProps.origin = elOption.origin.slice()), 
                    elOption.rotation && (transitionProps.rotation = elOption.rotation), "image" === el.type && elOption.style) {
                        var targetStyle = transitionProps.style = {};
                        zrUtil.each([ "x", "y", "width", "height" ], function(prop) {
                            prepareStyleTransition(prop, targetStyle, elOptionStyle, el.style, isInit);
                        });
                    }
                    "text" === el.type && elOption.style && (targetStyle = transitionProps.style = {}, 
                    zrUtil.each([ "x", "y" ], function(prop) {
                        prepareStyleTransition(prop, targetStyle, elOptionStyle, el.style, isInit);
                    }), !elOptionStyle.hasOwnProperty("textFill") && elOptionStyle.fill && (elOptionStyle.textFill = elOptionStyle.fill), 
                    !elOptionStyle.hasOwnProperty("textStroke") && elOptionStyle.stroke && (elOptionStyle.textStroke = elOptionStyle.stroke));
                    if ("group" !== el.type && (el.useStyle(elOptionStyle), isInit)) {
                        el.style.opacity = 0;
                        var targetOpacity = elOptionStyle.opacity;
                        null == targetOpacity && (targetOpacity = 1), graphicUtil.initProps(el, {
                            style: {
                                opacity: targetOpacity
                            }
                        }, animatableModel, dataIndex);
                    }
                    isInit ? el.attr(transitionProps) : graphicUtil.updateProps(el, transitionProps, animatableModel, dataIndex), 
                    elOption.hasOwnProperty("z2") && el.attr("z2", elOption.z2 || 0), elOption.hasOwnProperty("silent") && el.attr("silent", elOption.silent), 
                    elOption.hasOwnProperty("invisible") && el.attr("invisible", elOption.invisible), 
                    elOption.hasOwnProperty("ignore") && el.attr("ignore", elOption.ignore), elOption.hasOwnProperty("info") && el.attr("info", elOption.info);
                    var styleEmphasis = elOption.styleEmphasis, disableStyleEmphasis = !1 === styleEmphasis;
                    el.__cusHasEmphStl && null == styleEmphasis || !el.__cusHasEmphStl && disableStyleEmphasis || (graphicUtil.setElementHoverStyle(el, styleEmphasis), 
                    el.__cusHasEmphStl = !disableStyleEmphasis), isRoot && graphicUtil.setAsHighDownDispatcher(el, !disableStyleEmphasis);
                }(el, dataIndex, elOption, animatableModel, 0, isInit, isRoot), "group" === elOptionType && function(el, dataIndex, elOption, animatableModel, data) {
                    var newChildren = elOption.children, newLen = newChildren ? newChildren.length : 0, mergeChildren = elOption.$mergeChildren, byName = "byName" === mergeChildren || elOption.diffChildrenByName, notMerge = !1 === mergeChildren;
                    if (!newLen && !byName && !notMerge) return;
                    if (byName) return void function(context) {
                        new DataDiffer(context.oldChildren, context.newChildren, getKey, getKey, context).add(processAddUpdate).update(processAddUpdate).remove(processRemove).execute();
                    }({
                        oldChildren: el.children() || [],
                        newChildren: newChildren || [],
                        dataIndex: dataIndex,
                        animatableModel: animatableModel,
                        group: el,
                        data: data
                    });
                    notMerge && el.removeAll();
                    for (var index = 0; index < newLen; index++) newChildren[index] && doCreateOrUpdate(el.childAt(index), dataIndex, newChildren[index], animatableModel, el, data);
                }(el, dataIndex, elOption, animatableModel, data), group.add(el), el;
            }
        }
        function getKey(item, idx) {
            var name = item && item.name;
            return null != name ? name : GROUP_DIFF_PREFIX + idx;
        }
        function processAddUpdate(newIndex, oldIndex) {
            var context = this.context, childOption = null != newIndex ? context.newChildren[newIndex] : null;
            doCreateOrUpdate(null != oldIndex ? context.oldChildren[oldIndex] : null, context.dataIndex, childOption, context.animatableModel, context.group, context.data);
        }
        function applyExtraBefore(extra, model) {
            var dummyModel = new Model({}, model);
            return zrUtil.each(CACHED_LABEL_STYLE_PROPERTIES, function(stylePropName, modelPropName) {
                extra.hasOwnProperty(stylePropName) && (dummyModel.option[modelPropName] = extra[stylePropName]);
            }), dummyModel;
        }
        function applyExtraAfter(itemStyle, extra) {
            for (var key in extra) !extra.hasOwnProperty(key) && CACHED_LABEL_STYLE_PROPERTIES.hasOwnProperty(key) || (itemStyle[key] = extra[key]);
        }
        function processRemove(oldIndex) {
            var context = this.context, child = context.oldChildren[oldIndex];
            child && context.group.remove(child);
        }
        function getPathData(shape) {
            return shape && (shape.pathData || shape.d);
        }
        function hasOwn(host, prop) {
            return host && host.hasOwnProperty(prop);
        }
        SeriesModel.extend({
            type: "series.custom",
            dependencies: [ "grid", "polar", "geo", "singleAxis", "calendar" ],
            defaultOption: {
                coordinateSystem: "cartesian2d",
                zlevel: 0,
                z: 2,
                legendHoverLink: !0,
                useTransform: !0
            },
            getInitialData: function(option, ecModel) {
                return createListFromArray(this.getSource(), this);
            },
            getDataParams: function(dataIndex, dataType, el) {
                var params = SeriesModel.prototype.getDataParams.apply(this, arguments);
                return el && (params.info = el.info), params;
            }
        }), ChartView.extend({
            type: "custom",
            _data: null,
            render: function(customSeries, ecModel, api, payload) {
                var oldData = this._data, data = customSeries.getData(), group = this.group, renderItem = makeRenderItem(customSeries, data, ecModel, api);
                data.diff(oldData).add(function(newIdx) {
                    createOrUpdate(null, newIdx, renderItem(newIdx, payload), customSeries, group, data);
                }).update(function(newIdx, oldIdx) {
                    createOrUpdate(oldData.getItemGraphicEl(oldIdx), newIdx, renderItem(newIdx, payload), customSeries, group, data);
                }).remove(function(oldIdx) {
                    var el = oldData.getItemGraphicEl(oldIdx);
                    el && group.remove(el);
                }).execute(), this._data = data;
            },
            incrementalPrepareRender: function(customSeries, ecModel, api) {
                this.group.removeAll(), this._data = null;
            },
            incrementalRender: function(params, customSeries, ecModel, api, payload) {
                var data = customSeries.getData(), renderItem = makeRenderItem(customSeries, data, ecModel, api);
                function setIncrementalAndHoverLayer(el) {
                    el.isGroup || (el.incremental = !0, el.useHoverLayer = !0);
                }
                for (var idx = params.start; idx < params.end; idx++) {
                    createOrUpdate(null, idx, renderItem(idx, payload), customSeries, this.group, data).traverse(setIncrementalAndHoverLayer);
                }
            },
            dispose: zrUtil.noop,
            filterForExposedEvent: function(eventType, query, targetEl, packedEvent) {
                var elementName = query.element;
                if (null == elementName || targetEl.name === elementName) return !0;
                for (;(targetEl = targetEl.parent) && targetEl !== this.group; ) if (targetEl.name === elementName) return !0;
                return !1;
            }
        });
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0);
        function dataToCoordSize(dataSize, dataItem) {
            return dataItem = dataItem || [ 0, 0 ], zrUtil.map([ "x", "y" ], function(dim, dimIdx) {
                var axis = this.getAxis(dim), val = dataItem[dimIdx], halfSize = dataSize[dimIdx] / 2;
                return "category" === axis.type ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
            }, this);
        }
        module.exports = function(coordSys) {
            var rect = coordSys.grid.getRect();
            return {
                coordSys: {
                    type: "cartesian2d",
                    x: rect.x,
                    y: rect.y,
                    width: rect.width,
                    height: rect.height
                },
                api: {
                    coord: function(data) {
                        return coordSys.dataToPoint(data);
                    },
                    size: zrUtil.bind(dataToCoordSize, coordSys)
                }
            };
        };
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0);
        function dataToCoordSize(dataSize, dataItem) {
            return dataItem = dataItem || [ 0, 0 ], zrUtil.map([ 0, 1 ], function(dimIdx) {
                var val = dataItem[dimIdx], halfSize = dataSize[dimIdx] / 2, p1 = [], p2 = [];
                return p1[dimIdx] = val - halfSize, p2[dimIdx] = val + halfSize, p1[1 - dimIdx] = p2[1 - dimIdx] = dataItem[1 - dimIdx], 
                Math.abs(this.dataToPoint(p1)[dimIdx] - this.dataToPoint(p2)[dimIdx]);
            }, this);
        }
        module.exports = function(coordSys) {
            var rect = coordSys.getBoundingRect();
            return {
                coordSys: {
                    type: "geo",
                    x: rect.x,
                    y: rect.y,
                    width: rect.width,
                    height: rect.height,
                    zoom: coordSys.getZoom()
                },
                api: {
                    coord: function(data) {
                        return coordSys.dataToPoint(data);
                    },
                    size: zrUtil.bind(dataToCoordSize, coordSys)
                }
            };
        };
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0);
        function dataToCoordSize(dataSize, dataItem) {
            var axis = this.getAxis(), val = dataItem instanceof Array ? dataItem[0] : dataItem, halfSize = (dataSize instanceof Array ? dataSize[0] : dataSize) / 2;
            return "category" === axis.type ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
        }
        module.exports = function(coordSys) {
            var rect = coordSys.getRect();
            return {
                coordSys: {
                    type: "singleAxis",
                    x: rect.x,
                    y: rect.y,
                    width: rect.width,
                    height: rect.height
                },
                api: {
                    coord: function(val) {
                        return coordSys.dataToPoint(val);
                    },
                    size: zrUtil.bind(dataToCoordSize, coordSys)
                }
            };
        };
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0);
        function dataToCoordSize(dataSize, dataItem) {
            return zrUtil.map([ "Radius", "Angle" ], function(dim, dimIdx) {
                var axis = this["get" + dim + "Axis"](), val = dataItem[dimIdx], halfSize = dataSize[dimIdx] / 2, method = "dataTo" + dim, result = "category" === axis.type ? axis.getBandWidth() : Math.abs(axis[method](val - halfSize) - axis[method](val + halfSize));
                return "Angle" === dim && (result = result * Math.PI / 180), result;
            }, this);
        }
        module.exports = function(coordSys) {
            var radiusAxis = coordSys.getRadiusAxis(), angleAxis = coordSys.getAngleAxis(), radius = radiusAxis.getExtent();
            return radius[0] > radius[1] && radius.reverse(), {
                coordSys: {
                    type: "polar",
                    cx: coordSys.cx,
                    cy: coordSys.cy,
                    r: radius[1],
                    r0: radius[0]
                },
                api: {
                    coord: zrUtil.bind(function(data) {
                        var radius = radiusAxis.dataToRadius(data[0]), angle = angleAxis.dataToAngle(data[1]), coord = coordSys.coordToPoint([ radius, angle ]);
                        return coord.push(radius, angle * Math.PI / 180), coord;
                    }),
                    size: zrUtil.bind(dataToCoordSize, coordSys)
                }
            };
        };
    }, function(module, exports) {
        module.exports = function(coordSys) {
            var rect = coordSys.getRect(), rangeInfo = coordSys.getRangeInfo();
            return {
                coordSys: {
                    type: "calendar",
                    x: rect.x,
                    y: rect.y,
                    width: rect.width,
                    height: rect.height,
                    cellWidth: coordSys.getCellWidth(),
                    cellHeight: coordSys.getCellHeight(),
                    rangeInfo: {
                        start: rangeInfo.start,
                        end: rangeInfo.end,
                        weeks: rangeInfo.weeks,
                        dayCount: rangeInfo.allDay
                    }
                },
                api: {
                    coord: function(data, clamp) {
                        return coordSys.dataToPoint(data, clamp);
                    }
                }
            };
        };
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(70), __webpack_require__(134), __webpack_require__(136);
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), clazzUtil = __webpack_require__(18), graphic = __webpack_require__(2), axisPointerModelHelper = __webpack_require__(45), eventTool = __webpack_require__(15), throttleUtil = __webpack_require__(31), inner = (0, 
        __webpack_require__(3).makeInner)(), clone = zrUtil.clone, bind = zrUtil.bind;
        function BaseAxisPointer() {}
        function updateProps(animationModel, moveAnimation, el, props) {
            (function propsEqual(lastProps, newProps) {
                if (zrUtil.isObject(lastProps) && zrUtil.isObject(newProps)) {
                    var equals = !0;
                    return zrUtil.each(newProps, function(item, key) {
                        equals = equals && propsEqual(lastProps[key], item);
                    }), !!equals;
                }
                return lastProps === newProps;
            })(inner(el).lastProp, props) || (inner(el).lastProp = props, moveAnimation ? graphic.updateProps(el, props, animationModel) : (el.stopAnimation(), 
            el.attr(props)));
        }
        function updateLabelShowHide(labelEl, axisPointerModel) {
            labelEl[axisPointerModel.get("label.show") ? "show" : "hide"]();
        }
        function getHandleTransProps(trans) {
            return {
                position: trans.position.slice(),
                rotation: trans.rotation || 0
            };
        }
        function updateMandatoryProps(group, axisPointerModel, silent) {
            var z = axisPointerModel.get("z"), zlevel = axisPointerModel.get("zlevel");
            group && group.traverse(function(el) {
                "group" !== el.type && (null != z && (el.z = z), null != zlevel && (el.zlevel = zlevel), 
                el.silent = silent);
            });
        }
        BaseAxisPointer.prototype = {
            _group: null,
            _lastGraphicKey: null,
            _handle: null,
            _dragging: !1,
            _lastValue: null,
            _lastStatus: null,
            _payloadInfo: null,
            animationThreshold: 15,
            render: function(axisModel, axisPointerModel, api, forceRender) {
                var value = axisPointerModel.get("value"), status = axisPointerModel.get("status");
                if (this._axisModel = axisModel, this._axisPointerModel = axisPointerModel, this._api = api, 
                forceRender || this._lastValue !== value || this._lastStatus !== status) {
                    this._lastValue = value, this._lastStatus = status;
                    var group = this._group, handle = this._handle;
                    if (!status || "hide" === status) return group && group.hide(), void (handle && handle.hide());
                    group && group.show(), handle && handle.show();
                    var elOption = {};
                    this.makeElOption(elOption, value, axisModel, axisPointerModel, api);
                    var graphicKey = elOption.graphicKey;
                    graphicKey !== this._lastGraphicKey && this.clear(api), this._lastGraphicKey = graphicKey;
                    var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);
                    if (group) {
                        var doUpdateProps = zrUtil.curry(updateProps, axisPointerModel, moveAnimation);
                        this.updatePointerEl(group, elOption, doUpdateProps, axisPointerModel), this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);
                    } else group = this._group = new graphic.Group(), this.createPointerEl(group, elOption, axisModel, axisPointerModel), 
                    this.createLabelEl(group, elOption, axisModel, axisPointerModel), api.getZr().add(group);
                    updateMandatoryProps(group, axisPointerModel, !0), this._renderHandle(value);
                }
            },
            remove: function(api) {
                this.clear(api);
            },
            dispose: function(api) {
                this.clear(api);
            },
            determineAnimation: function(axisModel, axisPointerModel) {
                var animation = axisPointerModel.get("animation"), axis = axisModel.axis, isCategoryAxis = "category" === axis.type, useSnap = axisPointerModel.get("snap");
                if (!useSnap && !isCategoryAxis) return !1;
                if ("auto" === animation || null == animation) {
                    var animationThreshold = this.animationThreshold;
                    if (isCategoryAxis && axis.getBandWidth() > animationThreshold) return !0;
                    if (useSnap) {
                        var seriesDataCount = axisPointerModelHelper.getAxisInfo(axisModel).seriesDataCount, axisExtent = axis.getExtent();
                        return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;
                    }
                    return !1;
                }
                return !0 === animation;
            },
            makeElOption: function(elOption, value, axisModel, axisPointerModel, api) {},
            createPointerEl: function(group, elOption, axisModel, axisPointerModel) {
                var pointerOption = elOption.pointer;
                if (pointerOption) {
                    var pointerEl = inner(group).pointerEl = new graphic[pointerOption.type](clone(elOption.pointer));
                    group.add(pointerEl);
                }
            },
            createLabelEl: function(group, elOption, axisModel, axisPointerModel) {
                if (elOption.label) {
                    var labelEl = inner(group).labelEl = new graphic.Rect(clone(elOption.label));
                    group.add(labelEl), updateLabelShowHide(labelEl, axisPointerModel);
                }
            },
            updatePointerEl: function(group, elOption, updateProps) {
                var pointerEl = inner(group).pointerEl;
                pointerEl && elOption.pointer && (pointerEl.setStyle(elOption.pointer.style), updateProps(pointerEl, {
                    shape: elOption.pointer.shape
                }));
            },
            updateLabelEl: function(group, elOption, updateProps, axisPointerModel) {
                var labelEl = inner(group).labelEl;
                labelEl && (labelEl.setStyle(elOption.label.style), updateProps(labelEl, {
                    shape: elOption.label.shape,
                    position: elOption.label.position
                }), updateLabelShowHide(labelEl, axisPointerModel));
            },
            _renderHandle: function(value) {
                if (!this._dragging && this.updateHandleTransform) {
                    var isInit, axisPointerModel = this._axisPointerModel, zr = this._api.getZr(), handle = this._handle, handleModel = axisPointerModel.getModel("handle"), status = axisPointerModel.get("status");
                    if (!handleModel.get("show") || !status || "hide" === status) return handle && zr.remove(handle), 
                    void (this._handle = null);
                    this._handle || (isInit = !0, handle = this._handle = graphic.createIcon(handleModel.get("icon"), {
                        cursor: "move",
                        draggable: !0,
                        onmousemove: function(e) {
                            eventTool.stop(e.event);
                        },
                        onmousedown: bind(this._onHandleDragMove, this, 0, 0),
                        drift: bind(this._onHandleDragMove, this),
                        ondragend: bind(this._onHandleDragEnd, this)
                    }), zr.add(handle)), updateMandatoryProps(handle, axisPointerModel, !1);
                    handle.setStyle(handleModel.getItemStyle(null, [ "color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY" ]));
                    var handleSize = handleModel.get("size");
                    zrUtil.isArray(handleSize) || (handleSize = [ handleSize, handleSize ]), handle.attr("scale", [ handleSize[0] / 2, handleSize[1] / 2 ]), 
                    throttleUtil.createOrUpdate(this, "_doDispatchAxisPointer", handleModel.get("throttle") || 0, "fixRate"), 
                    this._moveHandleToValue(value, isInit);
                }
            },
            _moveHandleToValue: function(value, isInit) {
                updateProps(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));
            },
            _onHandleDragMove: function(dx, dy) {
                var handle = this._handle;
                if (handle) {
                    this._dragging = !0;
                    var trans = this.updateHandleTransform(getHandleTransProps(handle), [ dx, dy ], this._axisModel, this._axisPointerModel);
                    this._payloadInfo = trans, handle.stopAnimation(), handle.attr(getHandleTransProps(trans)), 
                    inner(handle).lastProp = null, this._doDispatchAxisPointer();
                }
            },
            _doDispatchAxisPointer: function() {
                if (this._handle) {
                    var payloadInfo = this._payloadInfo, axisModel = this._axisModel;
                    this._api.dispatchAction({
                        type: "updateAxisPointer",
                        x: payloadInfo.cursorPoint[0],
                        y: payloadInfo.cursorPoint[1],
                        tooltipOption: payloadInfo.tooltipOption,
                        axesInfo: [ {
                            axisDim: axisModel.axis.dim,
                            axisIndex: axisModel.componentIndex
                        } ]
                    });
                }
            },
            _onHandleDragEnd: function(moveAnimation) {
                if (this._dragging = !1, this._handle) {
                    var value = this._axisPointerModel.get("value");
                    this._moveHandleToValue(value), this._api.dispatchAction({
                        type: "hideTip"
                    });
                }
            },
            getHandleTransform: null,
            updateHandleTransform: null,
            clear: function(api) {
                this._lastValue = null, this._lastStatus = null;
                var zr = api.getZr(), group = this._group, handle = this._handle;
                zr && group && (this._lastGraphicKey = null, group && zr.remove(group), handle && zr.remove(handle), 
                this._group = null, this._handle = null, this._payloadInfo = null);
            },
            doClear: function() {},
            buildLabel: function(xy, wh, xDimIndex) {
                return {
                    x: xy[xDimIndex = xDimIndex || 0],
                    y: xy[1 - xDimIndex],
                    width: wh[xDimIndex],
                    height: wh[1 - xDimIndex]
                };
            }
        }, BaseAxisPointer.prototype.constructor = BaseAxisPointer, clazzUtil.enableClassExtend(BaseAxisPointer);
        var _default = BaseAxisPointer;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), makeInner = __webpack_require__(3).makeInner, modelHelper = __webpack_require__(45), findPointFromSeries = __webpack_require__(137), each = zrUtil.each, curry = zrUtil.curry, inner = makeInner();
        function processOnAxis(axisInfo, newValue, updaters, dontSnap, outputFinder) {
            var axis = axisInfo.axis;
            if (!axis.scale.isBlank() && axis.containData(newValue)) if (axisInfo.involveSeries) {
                var payloadInfo = function(value, axisInfo) {
                    var axis = axisInfo.axis, dim = axis.dim, snapToValue = value, payloadBatch = [], minDist = Number.MAX_VALUE, minDiff = -1;
                    return each(axisInfo.seriesModels, function(series, idx) {
                        var seriesNestestValue, dataIndices, dataDim = series.getData().mapDimension(dim, !0);
                        if (series.getAxisTooltipData) {
                            var result = series.getAxisTooltipData(dataDim, value, axis);
                            dataIndices = result.dataIndices, seriesNestestValue = result.nestestValue;
                        } else {
                            if (!(dataIndices = series.getData().indicesOfNearest(dataDim[0], value, "category" === axis.type ? .5 : null)).length) return;
                            seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);
                        }
                        if (null != seriesNestestValue && isFinite(seriesNestestValue)) {
                            var diff = value - seriesNestestValue, dist = Math.abs(diff);
                            dist <= minDist && ((dist < minDist || diff >= 0 && minDiff < 0) && (minDist = dist, 
                            minDiff = diff, snapToValue = seriesNestestValue, payloadBatch.length = 0), each(dataIndices, function(dataIndex) {
                                payloadBatch.push({
                                    seriesIndex: series.seriesIndex,
                                    dataIndexInside: dataIndex,
                                    dataIndex: series.getData().getRawIndex(dataIndex)
                                });
                            }));
                        }
                    }), {
                        payloadBatch: payloadBatch,
                        snapToValue: snapToValue
                    };
                }(newValue, axisInfo), payloadBatch = payloadInfo.payloadBatch, snapToValue = payloadInfo.snapToValue;
                payloadBatch[0] && null == outputFinder.seriesIndex && zrUtil.extend(outputFinder, payloadBatch[0]), 
                !dontSnap && axisInfo.snap && axis.containData(snapToValue) && null != snapToValue && (newValue = snapToValue), 
                updaters.showPointer(axisInfo, newValue, payloadBatch, outputFinder), updaters.showTooltip(axisInfo, payloadInfo, snapToValue);
            } else updaters.showPointer(axisInfo, newValue);
        }
        function showPointer(showValueMap, axisInfo, value, payloadBatch) {
            showValueMap[axisInfo.key] = {
                value: value,
                payloadBatch: payloadBatch
            };
        }
        function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {
            var payloadBatch = payloadInfo.payloadBatch, axis = axisInfo.axis, axisModel = axis.model, axisPointerModel = axisInfo.axisPointerModel;
            if (axisInfo.triggerTooltip && payloadBatch.length) {
                var coordSysModel = axisInfo.coordSys.model, coordSysKey = modelHelper.makeKey(coordSysModel), coordSysItem = dataByCoordSys.map[coordSysKey];
                coordSysItem || (coordSysItem = dataByCoordSys.map[coordSysKey] = {
                    coordSysId: coordSysModel.id,
                    coordSysIndex: coordSysModel.componentIndex,
                    coordSysType: coordSysModel.type,
                    coordSysMainType: coordSysModel.mainType,
                    dataByAxis: []
                }, dataByCoordSys.list.push(coordSysItem)), coordSysItem.dataByAxis.push({
                    axisDim: axis.dim,
                    axisIndex: axisModel.componentIndex,
                    axisType: axisModel.type,
                    axisId: axisModel.id,
                    value: value,
                    valueLabelOpt: {
                        precision: axisPointerModel.get("label.precision"),
                        formatter: axisPointerModel.get("label.formatter")
                    },
                    seriesDataIndices: payloadBatch.slice()
                });
            }
        }
        function makeMapperParam(axisInfo) {
            var axisModel = axisInfo.axis.model, item = {}, dim = item.axisDim = axisInfo.axis.dim;
            return item.axisIndex = item[dim + "AxisIndex"] = axisModel.componentIndex, item.axisName = item[dim + "AxisName"] = axisModel.name, 
            item.axisId = item[dim + "AxisId"] = axisModel.id, item;
        }
        function illegalPoint(point) {
            return !point || null == point[0] || isNaN(point[0]) || null == point[1] || isNaN(point[1]);
        }
        module.exports = function(payload, ecModel, api) {
            var currTrigger = payload.currTrigger, point = [ payload.x, payload.y ], finder = payload, dispatchAction = payload.dispatchAction || zrUtil.bind(api.dispatchAction, api), coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
            if (coordSysAxesInfo) {
                illegalPoint(point) && (point = findPointFromSeries({
                    seriesIndex: finder.seriesIndex,
                    dataIndex: finder.dataIndex
                }, ecModel).point);
                var isIllegalPoint = illegalPoint(point), inputAxesInfo = finder.axesInfo, axesInfo = coordSysAxesInfo.axesInfo, shouldHide = "leave" === currTrigger || illegalPoint(point), outputFinder = {}, showValueMap = {}, dataByCoordSys = {
                    list: [],
                    map: {}
                }, updaters = {
                    showPointer: curry(showPointer, showValueMap),
                    showTooltip: curry(showTooltip, dataByCoordSys)
                };
                each(coordSysAxesInfo.coordSysMap, function(coordSys, coordSysKey) {
                    var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);
                    each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function(axisInfo, key) {
                        var axis = axisInfo.axis, inputAxisInfo = function(inputAxesInfo, axisInfo) {
                            for (var i = 0; i < (inputAxesInfo || []).length; i++) {
                                var inputAxisInfo = inputAxesInfo[i];
                                if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) return inputAxisInfo;
                            }
                        }(inputAxesInfo, axisInfo);
                        if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {
                            var val = inputAxisInfo && inputAxisInfo.value;
                            null != val || isIllegalPoint || (val = axis.pointToData(point)), null != val && processOnAxis(axisInfo, val, updaters, !1, outputFinder);
                        }
                    });
                });
                var linkTriggers = {};
                return each(axesInfo, function(tarAxisInfo, tarKey) {
                    var linkGroup = tarAxisInfo.linkGroup;
                    linkGroup && !showValueMap[tarKey] && each(linkGroup.axesInfo, function(srcAxisInfo, srcKey) {
                        var srcValItem = showValueMap[srcKey];
                        if (srcAxisInfo !== tarAxisInfo && srcValItem) {
                            var val = srcValItem.value;
                            linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo)))), 
                            linkTriggers[tarAxisInfo.key] = val;
                        }
                    });
                }), each(linkTriggers, function(val, tarKey) {
                    processOnAxis(axesInfo[tarKey], val, updaters, !0, outputFinder);
                }), function(showValueMap, axesInfo, outputFinder) {
                    var outputAxesInfo = outputFinder.axesInfo = [];
                    each(axesInfo, function(axisInfo, key) {
                        var option = axisInfo.axisPointerModel.option, valItem = showValueMap[key];
                        valItem ? (!axisInfo.useHandle && (option.status = "show"), option.value = valItem.value, 
                        option.seriesDataIndices = (valItem.payloadBatch || []).slice()) : !axisInfo.useHandle && (option.status = "hide"), 
                        "show" === option.status && outputAxesInfo.push({
                            axisDim: axisInfo.axis.dim,
                            axisIndex: axisInfo.axis.model.componentIndex,
                            value: option.value
                        });
                    });
                }(showValueMap, axesInfo, outputFinder), function(dataByCoordSys, point, payload, dispatchAction) {
                    if (!illegalPoint(point) && dataByCoordSys.list.length) {
                        var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
                        dispatchAction({
                            type: "showTip",
                            escapeConnect: !0,
                            x: point[0],
                            y: point[1],
                            tooltipOption: payload.tooltipOption,
                            position: payload.position,
                            dataIndexInside: sampleItem.dataIndexInside,
                            dataIndex: sampleItem.dataIndex,
                            seriesIndex: sampleItem.seriesIndex,
                            dataByCoordSys: dataByCoordSys.list
                        });
                    } else dispatchAction({
                        type: "hideTip"
                    });
                }(dataByCoordSys, point, payload, dispatchAction), function(axesInfo, dispatchAction, api) {
                    var zr = api.getZr(), lastHighlights = inner(zr).axisPointerLastHighlights || {}, newHighlights = inner(zr).axisPointerLastHighlights = {};
                    each(axesInfo, function(axisInfo, key) {
                        var option = axisInfo.axisPointerModel.option;
                        "show" === option.status && each(option.seriesDataIndices, function(batchItem) {
                            var key = batchItem.seriesIndex + " | " + batchItem.dataIndex;
                            newHighlights[key] = batchItem;
                        });
                    });
                    var toHighlight = [], toDownplay = [];
                    zrUtil.each(lastHighlights, function(batchItem, key) {
                        !newHighlights[key] && toDownplay.push(batchItem);
                    }), zrUtil.each(newHighlights, function(batchItem, key) {
                        !lastHighlights[key] && toHighlight.push(batchItem);
                    }), toDownplay.length && api.dispatchAction({
                        type: "downplay",
                        escapeConnect: !0,
                        batch: toDownplay
                    }), toHighlight.length && api.dispatchAction({
                        type: "highlight",
                        escapeConnect: !0,
                        batch: toHighlight
                    });
                }(axesInfo, 0, api), outputFinder;
            }
        };
    }, function(module, exports, __webpack_require__) {
        var _default = __webpack_require__(1).extendComponentModel({
            type: "axisPointer",
            coordSysAxesInfo: null,
            defaultOption: {
                show: "auto",
                triggerOn: null,
                zlevel: 0,
                z: 50,
                type: "line",
                snap: !1,
                triggerTooltip: !0,
                value: null,
                status: null,
                link: [],
                animation: null,
                animationDurationUpdate: 200,
                lineStyle: {
                    color: "#aaa",
                    width: 1,
                    type: "solid"
                },
                shadowStyle: {
                    color: "rgba(150,150,150,0.3)"
                },
                label: {
                    show: !0,
                    formatter: null,
                    precision: "auto",
                    margin: 3,
                    color: "#fff",
                    padding: [ 5, 7, 5, 7 ],
                    backgroundColor: "auto",
                    borderColor: null,
                    borderWidth: 0,
                    shadowBlur: 3,
                    shadowColor: "#aaa"
                },
                handle: {
                    show: !1,
                    icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
                    size: 45,
                    margin: 50,
                    color: "#333",
                    shadowBlur: 3,
                    shadowColor: "#aaa",
                    shadowOffsetX: 0,
                    shadowOffsetY: 2,
                    throttle: 40
                }
            }
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var echarts = __webpack_require__(1), globalListener = __webpack_require__(138), AxisPointerView = echarts.extendComponentView({
            type: "axisPointer",
            render: function(globalAxisPointerModel, ecModel, api) {
                var globalTooltipModel = ecModel.getComponent("tooltip"), triggerOn = globalAxisPointerModel.get("triggerOn") || globalTooltipModel && globalTooltipModel.get("triggerOn") || "mousemove|click";
                globalListener.register("axisPointer", api, function(currTrigger, e, dispatchAction) {
                    "none" !== triggerOn && ("leave" === currTrigger || triggerOn.indexOf(currTrigger) >= 0) && dispatchAction({
                        type: "updateAxisPointer",
                        currTrigger: currTrigger,
                        x: e && e.offsetX,
                        y: e && e.offsetY
                    });
                });
            },
            remove: function(ecModel, api) {
                globalListener.unregister(api.getZr(), "axisPointer"), AxisPointerView.superApply(this._model, "remove", arguments);
            },
            dispose: function(ecModel, api) {
                globalListener.unregister("axisPointer", api), AxisPointerView.superApply(this._model, "dispose", arguments);
            }
        }), _default = AxisPointerView;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var echarts = __webpack_require__(1);
        __webpack_require__(285), __webpack_require__(286), __webpack_require__(287);
        var legendFilter = __webpack_require__(289), Component = __webpack_require__(13);
        echarts.registerProcessor(legendFilter), Component.registerSubTypeDefaulter("legend", function() {
            return "plain";
        });
    }, function(module, exports, __webpack_require__) {
        var echarts = __webpack_require__(1), zrUtil = __webpack_require__(0), Model = __webpack_require__(14), isNameSpecified = __webpack_require__(3).isNameSpecified, LegendModel = echarts.extendComponentModel({
            type: "legend.plain",
            dependencies: [ "series" ],
            layoutMode: {
                type: "box",
                ignoreSize: !0
            },
            init: function(option, parentModel, ecModel) {
                this.mergeDefaultAndTheme(option, ecModel), option.selected = option.selected || {};
            },
            mergeOption: function(option) {
                LegendModel.superCall(this, "mergeOption", option);
            },
            optionUpdated: function() {
                this._updateData(this.ecModel);
                var legendData = this._data;
                if (legendData[0] && "single" === this.get("selectedMode")) {
                    for (var hasSelected = !1, i = 0; i < legendData.length; i++) {
                        var name = legendData[i].get("name");
                        if (this.isSelected(name)) {
                            this.select(name), hasSelected = !0;
                            break;
                        }
                    }
                    !hasSelected && this.select(legendData[0].get("name"));
                }
            },
            _updateData: function(ecModel) {
                var potentialData = [], availableNames = [];
                ecModel.eachRawSeries(function(seriesModel) {
                    var isPotential, seriesName = seriesModel.name;
                    if (availableNames.push(seriesName), seriesModel.legendDataProvider) {
                        var data = seriesModel.legendDataProvider(), names = data.mapArray(data.getName);
                        ecModel.isSeriesFiltered(seriesModel) || (availableNames = availableNames.concat(names)), 
                        names.length ? potentialData = potentialData.concat(names) : isPotential = !0;
                    } else isPotential = !0;
                    isPotential && isNameSpecified(seriesModel) && potentialData.push(seriesModel.name);
                }), this._availableNames = availableNames;
                var rawData = this.get("data") || potentialData, legendData = zrUtil.map(rawData, function(dataItem) {
                    return "string" != typeof dataItem && "number" != typeof dataItem || (dataItem = {
                        name: dataItem
                    }), new Model(dataItem, this, this.ecModel);
                }, this);
                this._data = legendData;
            },
            getData: function() {
                return this._data;
            },
            select: function(name) {
                var selected = this.option.selected;
                if ("single" === this.get("selectedMode")) {
                    var data = this._data;
                    zrUtil.each(data, function(dataItem) {
                        selected[dataItem.get("name")] = !1;
                    });
                }
                selected[name] = !0;
            },
            unSelect: function(name) {
                "single" !== this.get("selectedMode") && (this.option.selected[name] = !1);
            },
            toggleSelected: function(name) {
                var selected = this.option.selected;
                selected.hasOwnProperty(name) || (selected[name] = !0), this[selected[name] ? "unSelect" : "select"](name);
            },
            isSelected: function(name) {
                var selected = this.option.selected;
                return !(selected.hasOwnProperty(name) && !selected[name]) && zrUtil.indexOf(this._availableNames, name) >= 0;
            },
            defaultOption: {
                zlevel: 0,
                z: 4,
                show: !0,
                orient: "horizontal",
                left: "center",
                top: 0,
                align: "auto",
                backgroundColor: "rgba(0,0,0,0)",
                borderColor: "#ccc",
                borderRadius: 0,
                borderWidth: 0,
                padding: 5,
                itemGap: 10,
                itemWidth: 25,
                itemHeight: 14,
                inactiveColor: "#ccc",
                textStyle: {
                    color: "#333"
                },
                selectedMode: !0,
                tooltip: {
                    show: !1
                }
            }
        }), _default = LegendModel;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var echarts = __webpack_require__(1), zrUtil = __webpack_require__(0);
        function legendSelectActionHandler(methodName, payload, ecModel) {
            var isSelected, selectedMap = {}, isToggleSelect = "toggleSelected" === methodName;
            return ecModel.eachComponent("legend", function(legendModel) {
                isToggleSelect && null != isSelected ? legendModel[isSelected ? "select" : "unSelect"](payload.name) : (legendModel[methodName](payload.name), 
                isSelected = legendModel.isSelected(payload.name));
                var legendData = legendModel.getData();
                zrUtil.each(legendData, function(model) {
                    var name = model.get("name");
                    if ("\n" !== name && "" !== name) {
                        var isItemSelected = legendModel.isSelected(name);
                        selectedMap.hasOwnProperty(name) ? selectedMap[name] = selectedMap[name] && isItemSelected : selectedMap[name] = isItemSelected;
                    }
                });
            }), {
                name: payload.name,
                selected: selectedMap
            };
        }
        echarts.registerAction("legendToggleSelect", "legendselectchanged", zrUtil.curry(legendSelectActionHandler, "toggleSelected")), 
        echarts.registerAction("legendSelect", "legendselected", zrUtil.curry(legendSelectActionHandler, "select")), 
        echarts.registerAction("legendUnSelect", "legendunselected", zrUtil.curry(legendSelectActionHandler, "unSelect"));
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(5).__DEV__;
        var echarts = __webpack_require__(1), zrUtil = __webpack_require__(0), createSymbol = __webpack_require__(16).createSymbol, graphic = __webpack_require__(2), makeBackground = __webpack_require__(288).makeBackground, layoutUtil = __webpack_require__(10), curry = zrUtil.curry, each = zrUtil.each, Group = graphic.Group, _default = echarts.extendComponentView({
            type: "legend.plain",
            newlineDisabled: !1,
            init: function() {
                this.group.add(this._contentGroup = new Group()), this._backgroundEl, this._isFirstRender = !0;
            },
            getContentGroup: function() {
                return this._contentGroup;
            },
            render: function(legendModel, ecModel, api) {
                var isFirstRender = this._isFirstRender;
                if (this._isFirstRender = !1, this.resetInner(), legendModel.get("show", !0)) {
                    var itemAlign = legendModel.get("align");
                    itemAlign && "auto" !== itemAlign || (itemAlign = "right" === legendModel.get("left") && "vertical" === legendModel.get("orient") ? "right" : "left"), 
                    this.renderInner(itemAlign, legendModel, ecModel, api);
                    var positionInfo = legendModel.getBoxLayoutParams(), viewportSize = {
                        width: api.getWidth(),
                        height: api.getHeight()
                    }, padding = legendModel.get("padding"), maxSize = layoutUtil.getLayoutRect(positionInfo, viewportSize, padding), mainRect = this.layoutInner(legendModel, itemAlign, maxSize, isFirstRender), layoutRect = layoutUtil.getLayoutRect(zrUtil.defaults({
                        width: mainRect.width,
                        height: mainRect.height
                    }, positionInfo), viewportSize, padding);
                    this.group.attr("position", [ layoutRect.x - mainRect.x, layoutRect.y - mainRect.y ]), 
                    this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));
                }
            },
            resetInner: function() {
                this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl);
            },
            renderInner: function(itemAlign, legendModel, ecModel, api) {
                var contentGroup = this.getContentGroup(), legendDrawnMap = zrUtil.createHashMap(), selectMode = legendModel.get("selectedMode"), excludeSeriesId = [];
                ecModel.eachRawSeries(function(seriesModel) {
                    !seriesModel.get("legendHoverLink") && excludeSeriesId.push(seriesModel.id);
                }), each(legendModel.getData(), function(itemModel, dataIndex) {
                    var name = itemModel.get("name");
                    if (this.newlineDisabled || "" !== name && "\n" !== name) {
                        var seriesModel = ecModel.getSeriesByName(name)[0];
                        if (!legendDrawnMap.get(name)) if (seriesModel) {
                            var data = seriesModel.getData(), color = data.getVisual("color");
                            "function" == typeof color && (color = color(seriesModel.getDataParams(0)));
                            var legendSymbolType = data.getVisual("legendSymbol") || "roundRect", symbolType = data.getVisual("symbol");
                            this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode).on("click", curry(dispatchSelectAction, name, api)).on("mouseover", curry(dispatchHighlightAction, seriesModel.name, null, api, excludeSeriesId)).on("mouseout", curry(dispatchDownplayAction, seriesModel.name, null, api, excludeSeriesId)), 
                            legendDrawnMap.set(name, !0);
                        } else ecModel.eachRawSeries(function(seriesModel) {
                            if (!legendDrawnMap.get(name) && seriesModel.legendDataProvider) {
                                var data = seriesModel.legendDataProvider(), idx = data.indexOfName(name);
                                if (idx < 0) return;
                                var color = data.getItemVisual(idx, "color");
                                this._createItem(name, dataIndex, itemModel, legendModel, "roundRect", null, itemAlign, color, selectMode).on("click", curry(dispatchSelectAction, name, api)).on("mouseover", curry(dispatchHighlightAction, null, name, api, excludeSeriesId)).on("mouseout", curry(dispatchDownplayAction, null, name, api, excludeSeriesId)), 
                                legendDrawnMap.set(name, !0);
                            }
                        }, this);
                    } else contentGroup.add(new Group({
                        newline: !0
                    }));
                }, this);
            },
            _createItem: function(name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode) {
                var itemWidth = legendModel.get("itemWidth"), itemHeight = legendModel.get("itemHeight"), inactiveColor = legendModel.get("inactiveColor"), symbolKeepAspect = legendModel.get("symbolKeepAspect"), isSelected = legendModel.isSelected(name), itemGroup = new Group(), textStyleModel = itemModel.getModel("textStyle"), itemIcon = itemModel.get("icon"), tooltipModel = itemModel.getModel("tooltip"), legendGlobalTooltipModel = tooltipModel.parentModel;
                if (legendSymbolType = itemIcon || legendSymbolType, itemGroup.add(createSymbol(legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor, null == symbolKeepAspect || symbolKeepAspect)), 
                !itemIcon && symbolType && (symbolType !== legendSymbolType || "none" === symbolType)) {
                    var size = .8 * itemHeight;
                    "none" === symbolType && (symbolType = "circle"), itemGroup.add(createSymbol(symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size, isSelected ? color : inactiveColor, null == symbolKeepAspect || symbolKeepAspect));
                }
                var textX = "left" === itemAlign ? itemWidth + 5 : -5, textAlign = itemAlign, formatter = legendModel.get("formatter"), content = name;
                "string" == typeof formatter && formatter ? content = formatter.replace("{name}", null != name ? name : "") : "function" == typeof formatter && (content = formatter(name)), 
                itemGroup.add(new graphic.Text({
                    style: graphic.setTextStyle({}, textStyleModel, {
                        text: content,
                        x: textX,
                        y: itemHeight / 2,
                        textFill: isSelected ? textStyleModel.getTextColor() : inactiveColor,
                        textAlign: textAlign,
                        textVerticalAlign: "middle"
                    })
                }));
                var hitRect = new graphic.Rect({
                    shape: itemGroup.getBoundingRect(),
                    invisible: !0,
                    tooltip: tooltipModel.get("show") ? zrUtil.extend({
                        content: name,
                        formatter: legendGlobalTooltipModel.get("formatter", !0) || function() {
                            return name;
                        },
                        formatterParams: {
                            componentType: "legend",
                            legendIndex: legendModel.componentIndex,
                            name: name,
                            $vars: [ "name" ]
                        }
                    }, tooltipModel.option) : null
                });
                return itemGroup.add(hitRect), itemGroup.eachChild(function(child) {
                    child.silent = !0;
                }), hitRect.silent = !selectMode, this.getContentGroup().add(itemGroup), graphic.setHoverStyle(itemGroup), 
                itemGroup.__legendDataIndex = dataIndex, itemGroup;
            },
            layoutInner: function(legendModel, itemAlign, maxSize) {
                var contentGroup = this.getContentGroup();
                layoutUtil.box(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), maxSize.width, maxSize.height);
                var contentRect = contentGroup.getBoundingRect();
                return contentGroup.attr("position", [ -contentRect.x, -contentRect.y ]), this.group.getBoundingRect();
            },
            remove: function() {
                this.getContentGroup().removeAll(), this._isFirstRender = !0;
            }
        });
        function dispatchSelectAction(name, api) {
            api.dispatchAction({
                type: "legendToggleSelect",
                name: name
            });
        }
        function dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId) {
            var el = api.getZr().storage.getDisplayList()[0];
            el && el.useHoverLayer || api.dispatchAction({
                type: "highlight",
                seriesName: seriesName,
                name: dataName,
                excludeSeriesId: excludeSeriesId
            });
        }
        function dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId) {
            var el = api.getZr().storage.getDisplayList()[0];
            el && el.useHoverLayer || api.dispatchAction({
                type: "downplay",
                seriesName: seriesName,
                name: dataName,
                excludeSeriesId: excludeSeriesId
            });
        }
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var _layout = __webpack_require__(10), getLayoutRect = _layout.getLayoutRect, layoutBox = _layout.box, positionElement = _layout.positionElement, formatUtil = __webpack_require__(9), graphic = __webpack_require__(2);
        exports.layout = function(group, componentModel, api) {
            var boxLayoutParams = componentModel.getBoxLayoutParams(), padding = componentModel.get("padding"), viewportSize = {
                width: api.getWidth(),
                height: api.getHeight()
            }, rect = getLayoutRect(boxLayoutParams, viewportSize, padding);
            layoutBox(componentModel.get("orient"), group, componentModel.get("itemGap"), rect.width, rect.height), 
            positionElement(group, boxLayoutParams, viewportSize, padding);
        }, exports.makeBackground = function(rect, componentModel) {
            var padding = formatUtil.normalizeCssArray(componentModel.get("padding")), style = componentModel.getItemStyle([ "color", "opacity" ]);
            return style.fill = componentModel.get("backgroundColor"), rect = new graphic.Rect({
                shape: {
                    x: rect.x - padding[3],
                    y: rect.y - padding[0],
                    width: rect.width + padding[1] + padding[3],
                    height: rect.height + padding[0] + padding[2],
                    r: componentModel.get("borderRadius")
                },
                style: style,
                silent: !0,
                z2: -1
            });
        };
    }, function(module, exports) {
        module.exports = function(ecModel) {
            var legendModels = ecModel.findComponents({
                mainType: "legend"
            });
            legendModels && legendModels.length && ecModel.filterSeries(function(series) {
                for (var i = 0; i < legendModels.length; i++) if (!legendModels[i].isSelected(series.name)) return !1;
                return !0;
            });
        };
    }, function(module, exports, __webpack_require__) {
        var echarts = __webpack_require__(1);
        __webpack_require__(136), __webpack_require__(291), __webpack_require__(292), echarts.registerAction({
            type: "showTip",
            event: "showTip",
            update: "tooltip:manuallyShowTip"
        }, function() {}), echarts.registerAction({
            type: "hideTip",
            event: "hideTip",
            update: "tooltip:manuallyHideTip"
        }, function() {});
    }, function(module, exports, __webpack_require__) {
        var _default = __webpack_require__(1).extendComponentModel({
            type: "tooltip",
            dependencies: [ "axisPointer" ],
            defaultOption: {
                zlevel: 0,
                z: 60,
                show: !0,
                showContent: !0,
                trigger: "item",
                triggerOn: "mousemove|click",
                alwaysShowContent: !1,
                displayMode: "single",
                renderMode: "auto",
                confine: !1,
                showDelay: 0,
                hideDelay: 100,
                transitionDuration: .4,
                enterable: !1,
                backgroundColor: "rgba(50,50,50,0.7)",
                borderColor: "#333",
                borderRadius: 4,
                borderWidth: 0,
                padding: 5,
                extraCssText: "",
                axisPointer: {
                    type: "line",
                    axis: "auto",
                    animation: "auto",
                    animationDurationUpdate: 200,
                    animationEasingUpdate: "exponentialOut",
                    crossStyle: {
                        color: "#999",
                        width: 1,
                        type: "dashed",
                        textStyle: {}
                    }
                },
                textStyle: {
                    color: "#fff",
                    fontSize: 14
                }
            }
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var echarts = __webpack_require__(1), zrUtil = __webpack_require__(0), env = __webpack_require__(7), TooltipContent = __webpack_require__(293), TooltipRichContent = __webpack_require__(294), formatUtil = __webpack_require__(9), numberUtil = __webpack_require__(4), graphic = __webpack_require__(2), findPointFromSeries = __webpack_require__(137), layoutUtil = __webpack_require__(10), Model = __webpack_require__(14), globalListener = __webpack_require__(138), axisHelper = __webpack_require__(26), axisPointerViewHelper = __webpack_require__(135), getTooltipRenderMode = __webpack_require__(3).getTooltipRenderMode, bind = zrUtil.bind, each = zrUtil.each, parsePercent = numberUtil.parsePercent, proxyRect = new graphic.Rect({
            shape: {
                x: -1,
                y: -1,
                width: 2,
                height: 2
            }
        }), _default = echarts.extendComponentView({
            type: "tooltip",
            init: function(ecModel, api) {
                if (!env.node) {
                    var tooltipContent, renderMode = ecModel.getComponent("tooltip").get("renderMode");
                    this._renderMode = getTooltipRenderMode(renderMode), "html" === this._renderMode ? (tooltipContent = new TooltipContent(api.getDom(), api), 
                    this._newLine = "<br/>") : (tooltipContent = new TooltipRichContent(api), this._newLine = "\n"), 
                    this._tooltipContent = tooltipContent;
                }
            },
            render: function(tooltipModel, ecModel, api) {
                if (!env.node) {
                    this.group.removeAll(), this._tooltipModel = tooltipModel, this._ecModel = ecModel, 
                    this._api = api, this._lastDataByCoordSys = null, this._alwaysShowContent = tooltipModel.get("alwaysShowContent");
                    var tooltipContent = this._tooltipContent;
                    tooltipContent.update(), tooltipContent.setEnterable(tooltipModel.get("enterable")), 
                    this._initGlobalListener(), this._keepShow();
                }
            },
            _initGlobalListener: function() {
                var triggerOn = this._tooltipModel.get("triggerOn");
                globalListener.register("itemTooltip", this._api, bind(function(currTrigger, e, dispatchAction) {
                    "none" !== triggerOn && (triggerOn.indexOf(currTrigger) >= 0 ? this._tryShow(e, dispatchAction) : "leave" === currTrigger && this._hide(dispatchAction));
                }, this));
            },
            _keepShow: function() {
                var tooltipModel = this._tooltipModel, ecModel = this._ecModel, api = this._api;
                if (null != this._lastX && null != this._lastY && "none" !== tooltipModel.get("triggerOn")) {
                    var self = this;
                    clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {
                        !api.isDisposed() && self.manuallyShowTip(tooltipModel, ecModel, api, {
                            x: self._lastX,
                            y: self._lastY
                        });
                    });
                }
            },
            manuallyShowTip: function(tooltipModel, ecModel, api, payload) {
                if (payload.from !== this.uid && !env.node) {
                    var dispatchAction = makeDispatchAction(payload, api);
                    this._ticket = "";
                    var dataByCoordSys = payload.dataByCoordSys;
                    if (payload.tooltip && null != payload.x && null != payload.y) {
                        var el = proxyRect;
                        el.position = [ payload.x, payload.y ], el.update(), el.tooltip = payload.tooltip, 
                        this._tryShow({
                            offsetX: payload.x,
                            offsetY: payload.y,
                            target: el
                        }, dispatchAction);
                    } else if (dataByCoordSys) this._tryShow({
                        offsetX: payload.x,
                        offsetY: payload.y,
                        position: payload.position,
                        event: {},
                        dataByCoordSys: payload.dataByCoordSys,
                        tooltipOption: payload.tooltipOption
                    }, dispatchAction); else if (null != payload.seriesIndex) {
                        if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) return;
                        var pointInfo = findPointFromSeries(payload, ecModel), cx = pointInfo.point[0], cy = pointInfo.point[1];
                        null != cx && null != cy && this._tryShow({
                            offsetX: cx,
                            offsetY: cy,
                            position: payload.position,
                            target: pointInfo.el,
                            event: {}
                        }, dispatchAction);
                    } else null != payload.x && null != payload.y && (api.dispatchAction({
                        type: "updateAxisPointer",
                        x: payload.x,
                        y: payload.y
                    }), this._tryShow({
                        offsetX: payload.x,
                        offsetY: payload.y,
                        position: payload.position,
                        target: api.getZr().findHover(payload.x, payload.y).target,
                        event: {}
                    }, dispatchAction));
                }
            },
            manuallyHideTip: function(tooltipModel, ecModel, api, payload) {
                var tooltipContent = this._tooltipContent;
                !this._alwaysShowContent && this._tooltipModel && tooltipContent.hideLater(this._tooltipModel.get("hideDelay")), 
                this._lastX = this._lastY = null, payload.from !== this.uid && this._hide(makeDispatchAction(payload, api));
            },
            _manuallyAxisShowTip: function(tooltipModel, ecModel, api, payload) {
                var seriesIndex = payload.seriesIndex, dataIndex = payload.dataIndex, coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
                if (null != seriesIndex && null != dataIndex && null != coordSysAxesInfo) {
                    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
                    if (seriesModel) if ("axis" === (tooltipModel = buildTooltipModel([ seriesModel.getData().getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model, tooltipModel ])).get("trigger")) return api.dispatchAction({
                        type: "updateAxisPointer",
                        seriesIndex: seriesIndex,
                        dataIndex: dataIndex,
                        position: payload.position
                    }), !0;
                }
            },
            _tryShow: function(e, dispatchAction) {
                var el = e.target;
                if (this._tooltipModel) {
                    this._lastX = e.offsetX, this._lastY = e.offsetY;
                    var dataByCoordSys = e.dataByCoordSys;
                    dataByCoordSys && dataByCoordSys.length ? this._showAxisTooltip(dataByCoordSys, e) : el && null != el.dataIndex ? (this._lastDataByCoordSys = null, 
                    this._showSeriesItemTooltip(e, el, dispatchAction)) : el && el.tooltip ? (this._lastDataByCoordSys = null, 
                    this._showComponentItemTooltip(e, el, dispatchAction)) : (this._lastDataByCoordSys = null, 
                    this._hide(dispatchAction));
                }
            },
            _showOrMove: function(tooltipModel, cb) {
                var delay = tooltipModel.get("showDelay");
                cb = zrUtil.bind(cb, this), clearTimeout(this._showTimout), delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();
            },
            _showAxisTooltip: function(dataByCoordSys, e) {
                var ecModel = this._ecModel, globalTooltipModel = this._tooltipModel, point = [ e.offsetX, e.offsetY ], singleDefaultHTML = [], singleParamsList = [], singleTooltipModel = buildTooltipModel([ e.tooltipOption, globalTooltipModel ]), renderMode = this._renderMode, newLine = this._newLine, markers = {};
                each(dataByCoordSys, function(itemCoordSys) {
                    each(itemCoordSys.dataByAxis, function(item) {
                        var axisModel = ecModel.getComponent(item.axisDim + "Axis", item.axisIndex), axisValue = item.value, seriesDefaultHTML = [];
                        if (axisModel && null != axisValue) {
                            var valueLabel = axisPointerViewHelper.getValueLabel(axisValue, axisModel.axis, ecModel, item.seriesDataIndices, item.valueLabelOpt);
                            zrUtil.each(item.seriesDataIndices, function(idxItem) {
                                var series = ecModel.getSeriesByIndex(idxItem.seriesIndex), dataIndex = idxItem.dataIndexInside, dataParams = series && series.getDataParams(dataIndex);
                                if (dataParams.axisDim = item.axisDim, dataParams.axisIndex = item.axisIndex, dataParams.axisType = item.axisType, 
                                dataParams.axisId = item.axisId, dataParams.axisValue = axisHelper.getAxisRawValue(axisModel.axis, axisValue), 
                                dataParams.axisValueLabel = valueLabel, dataParams) {
                                    singleParamsList.push(dataParams);
                                    var html, seriesTooltip = series.formatTooltip(dataIndex, !0, null, renderMode);
                                    if (zrUtil.isObject(seriesTooltip)) {
                                        html = seriesTooltip.html;
                                        var newMarkers = seriesTooltip.markers;
                                        zrUtil.merge(markers, newMarkers);
                                    } else html = seriesTooltip;
                                    seriesDefaultHTML.push(html);
                                }
                            });
                            var firstLine = valueLabel;
                            "html" !== renderMode ? singleDefaultHTML.push(seriesDefaultHTML.join(newLine)) : singleDefaultHTML.push((firstLine ? formatUtil.encodeHTML(firstLine) + newLine : "") + seriesDefaultHTML.join(newLine));
                        }
                    });
                }, this), singleDefaultHTML.reverse(), singleDefaultHTML = singleDefaultHTML.join(this._newLine + this._newLine);
                var positionExpr = e.position;
                this._showOrMove(singleTooltipModel, function() {
                    this._updateContentNotChangedOnAxis(dataByCoordSys) ? this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, singleParamsList) : this._showTooltipContent(singleTooltipModel, singleDefaultHTML, singleParamsList, Math.random(), point[0], point[1], positionExpr, void 0, markers);
                });
            },
            _showSeriesItemTooltip: function(e, el, dispatchAction) {
                var ecModel = this._ecModel, seriesIndex = el.seriesIndex, seriesModel = ecModel.getSeriesByIndex(seriesIndex), dataModel = el.dataModel || seriesModel, dataIndex = el.dataIndex, dataType = el.dataType, data = dataModel.getData(), tooltipModel = buildTooltipModel([ data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model, this._tooltipModel ]), tooltipTrigger = tooltipModel.get("trigger");
                if (null == tooltipTrigger || "item" === tooltipTrigger) {
                    var defaultHtml, markers, params = dataModel.getDataParams(dataIndex, dataType), seriesTooltip = dataModel.formatTooltip(dataIndex, !1, dataType, this._renderMode);
                    zrUtil.isObject(seriesTooltip) ? (defaultHtml = seriesTooltip.html, markers = seriesTooltip.markers) : (defaultHtml = seriesTooltip, 
                    markers = null);
                    var asyncTicket = "item_" + dataModel.name + "_" + dataIndex;
                    this._showOrMove(tooltipModel, function() {
                        this._showTooltipContent(tooltipModel, defaultHtml, params, asyncTicket, e.offsetX, e.offsetY, e.position, e.target, markers);
                    }), dispatchAction({
                        type: "showTip",
                        dataIndexInside: dataIndex,
                        dataIndex: data.getRawIndex(dataIndex),
                        seriesIndex: seriesIndex,
                        from: this.uid
                    });
                }
            },
            _showComponentItemTooltip: function(e, el, dispatchAction) {
                var tooltipOpt = el.tooltip;
                if ("string" == typeof tooltipOpt) {
                    tooltipOpt = {
                        content: tooltipOpt,
                        formatter: tooltipOpt
                    };
                }
                var subTooltipModel = new Model(tooltipOpt, this._tooltipModel, this._ecModel), defaultHtml = subTooltipModel.get("content"), asyncTicket = Math.random();
                this._showOrMove(subTooltipModel, function() {
                    this._showTooltipContent(subTooltipModel, defaultHtml, subTooltipModel.get("formatterParams") || {}, asyncTicket, e.offsetX, e.offsetY, e.position, el);
                }), dispatchAction({
                    type: "showTip",
                    from: this.uid
                });
            },
            _showTooltipContent: function(tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el, markers) {
                if (this._ticket = "", tooltipModel.get("showContent") && tooltipModel.get("show")) {
                    var tooltipContent = this._tooltipContent, formatter = tooltipModel.get("formatter");
                    positionExpr = positionExpr || tooltipModel.get("position");
                    var html = defaultHtml;
                    if (formatter && "string" == typeof formatter) html = formatUtil.formatTpl(formatter, params, !0); else if ("function" == typeof formatter) {
                        var callback = bind(function(cbTicket, html) {
                            cbTicket === this._ticket && (tooltipContent.setContent(html, markers, tooltipModel), 
                            this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el));
                        }, this);
                        this._ticket = asyncTicket, html = formatter(params, asyncTicket, callback);
                    }
                    tooltipContent.setContent(html, markers, tooltipModel), tooltipContent.show(tooltipModel), 
                    this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
                }
            },
            _updatePosition: function(tooltipModel, positionExpr, x, y, content, params, el) {
                var viewWidth = this._api.getWidth(), viewHeight = this._api.getHeight();
                positionExpr = positionExpr || tooltipModel.get("position");
                var contentSize = content.getSize(), align = tooltipModel.get("align"), vAlign = tooltipModel.get("verticalAlign"), rect = el && el.getBoundingRect().clone();
                if (el && rect.applyTransform(el.transform), "function" == typeof positionExpr && (positionExpr = positionExpr([ x, y ], params, content.el, rect, {
                    viewSize: [ viewWidth, viewHeight ],
                    contentSize: contentSize.slice()
                })), zrUtil.isArray(positionExpr)) x = parsePercent(positionExpr[0], viewWidth), 
                y = parsePercent(positionExpr[1], viewHeight); else if (zrUtil.isObject(positionExpr)) {
                    positionExpr.width = contentSize[0], positionExpr.height = contentSize[1];
                    var layoutRect = layoutUtil.getLayoutRect(positionExpr, {
                        width: viewWidth,
                        height: viewHeight
                    });
                    x = layoutRect.x, y = layoutRect.y, align = null, vAlign = null;
                } else if ("string" == typeof positionExpr && el) {
                    var pos = function(position, rect, contentSize) {
                        var domWidth = contentSize[0], domHeight = contentSize[1], x = 0, y = 0, rectWidth = rect.width, rectHeight = rect.height;
                        switch (position) {
                          case "inside":
                            x = rect.x + rectWidth / 2 - domWidth / 2, y = rect.y + rectHeight / 2 - domHeight / 2;
                            break;

                          case "top":
                            x = rect.x + rectWidth / 2 - domWidth / 2, y = rect.y - domHeight - 5;
                            break;

                          case "bottom":
                            x = rect.x + rectWidth / 2 - domWidth / 2, y = rect.y + rectHeight + 5;
                            break;

                          case "left":
                            x = rect.x - domWidth - 5, y = rect.y + rectHeight / 2 - domHeight / 2;
                            break;

                          case "right":
                            x = rect.x + rectWidth + 5, y = rect.y + rectHeight / 2 - domHeight / 2;
                        }
                        return [ x, y ];
                    }(positionExpr, rect, contentSize);
                    x = pos[0], y = pos[1];
                } else {
                    pos = function(x, y, content, viewWidth, viewHeight, gapH, gapV) {
                        var size = content.getOuterSize(), width = size.width, height = size.height;
                        null != gapH && (x + width + gapH > viewWidth ? x -= width + gapH : x += gapH);
                        null != gapV && (y + height + gapV > viewHeight ? y -= height + gapV : y += gapV);
                        return [ x, y ];
                    }(x, y, content, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);
                    x = pos[0], y = pos[1];
                }
                if (align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : "right" === align ? contentSize[0] : 0), 
                vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : "bottom" === vAlign ? contentSize[1] : 0), 
                tooltipModel.get("confine")) {
                    pos = function(x, y, content, viewWidth, viewHeight) {
                        var size = content.getOuterSize(), width = size.width, height = size.height;
                        return x = Math.min(x + width, viewWidth) - width, y = Math.min(y + height, viewHeight) - height, 
                        x = Math.max(x, 0), y = Math.max(y, 0), [ x, y ];
                    }(x, y, content, viewWidth, viewHeight);
                    x = pos[0], y = pos[1];
                }
                content.moveTo(x, y);
            },
            _updateContentNotChangedOnAxis: function(dataByCoordSys) {
                var lastCoordSys = this._lastDataByCoordSys, contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;
                return contentNotChanged && each(lastCoordSys, function(lastItemCoordSys, indexCoordSys) {
                    var lastDataByAxis = lastItemCoordSys.dataByAxis || {}, thisDataByAxis = (dataByCoordSys[indexCoordSys] || {}).dataByAxis || [];
                    (contentNotChanged &= lastDataByAxis.length === thisDataByAxis.length) && each(lastDataByAxis, function(lastItem, indexAxis) {
                        var thisItem = thisDataByAxis[indexAxis] || {}, lastIndices = lastItem.seriesDataIndices || [], newIndices = thisItem.seriesDataIndices || [];
                        (contentNotChanged &= lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length) && each(lastIndices, function(lastIdxItem, j) {
                            var newIdxItem = newIndices[j];
                            contentNotChanged &= lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;
                        });
                    });
                }), this._lastDataByCoordSys = dataByCoordSys, !!contentNotChanged;
            },
            _hide: function(dispatchAction) {
                this._lastDataByCoordSys = null, dispatchAction({
                    type: "hideTip",
                    from: this.uid
                });
            },
            dispose: function(ecModel, api) {
                env.node || (this._tooltipContent.hide(), globalListener.unregister("itemTooltip", api));
            }
        });
        function buildTooltipModel(modelCascade) {
            for (var resultModel = modelCascade.pop(); modelCascade.length; ) {
                var tooltipOpt = modelCascade.pop();
                tooltipOpt && (Model.isInstance(tooltipOpt) && (tooltipOpt = tooltipOpt.get("tooltip", !0)), 
                "string" == typeof tooltipOpt && (tooltipOpt = {
                    formatter: tooltipOpt
                }), resultModel = new Model(tooltipOpt, resultModel, resultModel.ecModel));
            }
            return resultModel;
        }
        function makeDispatchAction(payload, api) {
            return payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);
        }
        function isCenterAlign(align) {
            return "center" === align || "middle" === align;
        }
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), zrColor = __webpack_require__(20), eventUtil = __webpack_require__(15), env = __webpack_require__(7), formatUtil = __webpack_require__(9), each = zrUtil.each, toCamelCase = formatUtil.toCamelCase, vendors = [ "", "-webkit-", "-moz-", "-o-" ];
        function assembleCssText(tooltipModel) {
            var cssText = [], transitionDuration = tooltipModel.get("transitionDuration"), backgroundColor = tooltipModel.get("backgroundColor"), textStyleModel = tooltipModel.getModel("textStyle"), padding = tooltipModel.get("padding");
            return transitionDuration && cssText.push(function(duration) {
                var transitionText = "left " + duration + "s cubic-bezier(0.23, 1, 0.32, 1),top " + duration + "s cubic-bezier(0.23, 1, 0.32, 1)";
                return zrUtil.map(vendors, function(vendorPrefix) {
                    return vendorPrefix + "transition:" + transitionText;
                }).join(";");
            }(transitionDuration)), backgroundColor && (env.canvasSupported ? cssText.push("background-Color:" + backgroundColor) : (cssText.push("background-Color:#" + zrColor.toHex(backgroundColor)), 
            cssText.push("filter:alpha(opacity=70)"))), each([ "width", "color", "radius" ], function(name) {
                var borderName = "border-" + name, camelCase = toCamelCase(borderName), val = tooltipModel.get(camelCase);
                null != val && cssText.push(borderName + ":" + val + ("color" === name ? "" : "px"));
            }), cssText.push(function(textStyleModel) {
                var cssText = [], fontSize = textStyleModel.get("fontSize"), color = textStyleModel.getTextColor();
                return color && cssText.push("color:" + color), cssText.push("font:" + textStyleModel.getFont()), 
                fontSize && cssText.push("line-height:" + Math.round(3 * fontSize / 2) + "px"), 
                each([ "decoration", "align" ], function(name) {
                    var val = textStyleModel.get(name);
                    val && cssText.push("text-" + name + ":" + val);
                }), cssText.join(";");
            }(textStyleModel)), null != padding && cssText.push("padding:" + formatUtil.normalizeCssArray(padding).join("px ") + "px"), 
            cssText.join(";") + ";";
        }
        function TooltipContent(container, api) {
            if (env.wxa) return null;
            var el = document.createElement("div"), zr = this._zr = api.getZr();
            this.el = el, this._x = api.getWidth() / 2, this._y = api.getHeight() / 2, container.appendChild(el), 
            this._container = container, this._show = !1, this._hideTimeout;
            var self = this;
            el.onmouseenter = function() {
                self._enterable && (clearTimeout(self._hideTimeout), self._show = !0), self._inContent = !0;
            }, el.onmousemove = function(e) {
                if (e = e || window.event, !self._enterable) {
                    var handler = zr.handler;
                    eventUtil.normalizeEvent(container, e, !0), handler.dispatch("mousemove", e);
                }
            }, el.onmouseleave = function() {
                self._enterable && self._show && self.hideLater(self._hideDelay), self._inContent = !1;
            };
        }
        TooltipContent.prototype = {
            constructor: TooltipContent,
            _enterable: !0,
            update: function() {
                var container = this._container, stl = container.currentStyle || document.defaultView.getComputedStyle(container), domStyle = container.style;
                "absolute" !== domStyle.position && "absolute" !== stl.position && (domStyle.position = "relative");
            },
            show: function(tooltipModel) {
                clearTimeout(this._hideTimeout);
                var el = this.el;
                el.style.cssText = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + assembleCssText(tooltipModel) + ";left:" + this._x + "px;top:" + this._y + "px;" + (tooltipModel.get("extraCssText") || ""), 
                el.style.display = el.innerHTML ? "block" : "none", el.style.pointerEvents = this._enterable ? "auto" : "none", 
                this._show = !0;
            },
            setContent: function(content) {
                this.el.innerHTML = null == content ? "" : content;
            },
            setEnterable: function(enterable) {
                this._enterable = enterable;
            },
            getSize: function() {
                var el = this.el;
                return [ el.clientWidth, el.clientHeight ];
            },
            moveTo: function(x, y) {
                var viewportRootOffset, zr = this._zr;
                zr && zr.painter && (viewportRootOffset = zr.painter.getViewportRootOffset()) && (x += viewportRootOffset.offsetLeft, 
                y += viewportRootOffset.offsetTop);
                var style = this.el.style;
                style.left = x + "px", style.top = y + "px", this._x = x, this._y = y;
            },
            hide: function() {
                this.el.style.display = "none", this._show = !1;
            },
            hideLater: function(time) {
                !this._show || this._inContent && this._enterable || (time ? (this._hideDelay = time, 
                this._show = !1, this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time)) : this.hide());
            },
            isShow: function() {
                return this._show;
            },
            getOuterSize: function() {
                var width = this.el.clientWidth, height = this.el.clientHeight;
                if (document.defaultView && document.defaultView.getComputedStyle) {
                    var stl = document.defaultView.getComputedStyle(this.el);
                    stl && (width += parseInt(stl.borderLeftWidth, 10) + parseInt(stl.borderRightWidth, 10), 
                    height += parseInt(stl.borderTopWidth, 10) + parseInt(stl.borderBottomWidth, 10));
                }
                return {
                    width: width,
                    height: height
                };
            }
        };
        var _default = TooltipContent;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), Text = __webpack_require__(58);
        function TooltipRichContent(api) {
            this._zr = api.getZr(), this._show = !1, this._hideTimeout;
        }
        TooltipRichContent.prototype = {
            constructor: TooltipRichContent,
            _enterable: !0,
            update: function() {},
            show: function(tooltipModel) {
                this._hideTimeout && clearTimeout(this._hideTimeout), this.el.attr("show", !0), 
                this._show = !0;
            },
            setContent: function(content, markerRich, tooltipModel) {
                this.el && this._zr.remove(this.el);
                for (var markers = {}, text = content, startId = text.indexOf("{marker"); startId >= 0; ) {
                    var endId = text.indexOf("|}"), name = text.substr(startId + "{marker".length, endId - startId - "{marker".length);
                    name.indexOf("sub") > -1 ? markers["marker" + name] = {
                        textWidth: 4,
                        textHeight: 4,
                        textBorderRadius: 2,
                        textBackgroundColor: markerRich[name],
                        textOffset: [ 3, 0 ]
                    } : markers["marker" + name] = {
                        textWidth: 10,
                        textHeight: 10,
                        textBorderRadius: 5,
                        textBackgroundColor: markerRich[name]
                    }, startId = (text = text.substr(endId + 1)).indexOf("{marker");
                }
                this.el = new Text({
                    style: {
                        rich: markers,
                        text: content,
                        textLineHeight: 20,
                        textBackgroundColor: tooltipModel.get("backgroundColor"),
                        textBorderRadius: tooltipModel.get("borderRadius"),
                        textFill: tooltipModel.get("textStyle.color"),
                        textPadding: tooltipModel.get("padding")
                    },
                    z: tooltipModel.get("z")
                }), this._zr.add(this.el);
                var self = this;
                this.el.on("mouseover", function() {
                    self._enterable && (clearTimeout(self._hideTimeout), self._show = !0), self._inContent = !0;
                }), this.el.on("mouseout", function() {
                    self._enterable && self._show && self.hideLater(self._hideDelay), self._inContent = !1;
                });
            },
            setEnterable: function(enterable) {
                this._enterable = enterable;
            },
            getSize: function() {
                var bounding = this.el.getBoundingRect();
                return [ bounding.width, bounding.height ];
            },
            moveTo: function(x, y) {
                this.el && this.el.attr("position", [ x, y ]);
            },
            hide: function() {
                this.el && this.el.hide(), this._show = !1;
            },
            hideLater: function(time) {
                !this._show || this._inContent && this._enterable || (time ? (this._hideDelay = time, 
                this._show = !1, this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time)) : this.hide());
            },
            isShow: function() {
                return this._show;
            },
            getOuterSize: function() {
                var size = this.getSize();
                return {
                    width: size[0],
                    height: size[1]
                };
            }
        };
        var _default = TooltipRichContent;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), echarts = __webpack_require__(1), graphic = __webpack_require__(2), getLayoutRect = __webpack_require__(10).getLayoutRect;
        echarts.extendComponentModel({
            type: "title",
            layoutMode: {
                type: "box",
                ignoreSize: !0
            },
            defaultOption: {
                zlevel: 0,
                z: 6,
                show: !0,
                text: "",
                target: "blank",
                subtext: "",
                subtarget: "blank",
                left: 0,
                top: 0,
                backgroundColor: "rgba(0,0,0,0)",
                borderColor: "#ccc",
                borderWidth: 0,
                padding: 5,
                itemGap: 10,
                textStyle: {
                    fontSize: 18,
                    fontWeight: "bolder",
                    color: "#333"
                },
                subtextStyle: {
                    color: "#aaa"
                }
            }
        }), echarts.extendComponentView({
            type: "title",
            render: function(titleModel, ecModel, api) {
                if (this.group.removeAll(), titleModel.get("show")) {
                    var group = this.group, textStyleModel = titleModel.getModel("textStyle"), subtextStyleModel = titleModel.getModel("subtextStyle"), textAlign = titleModel.get("textAlign"), textVerticalAlign = zrUtil.retrieve2(titleModel.get("textBaseline"), titleModel.get("textVerticalAlign")), textEl = new graphic.Text({
                        style: graphic.setTextStyle({}, textStyleModel, {
                            text: titleModel.get("text"),
                            textFill: textStyleModel.getTextColor()
                        }, {
                            disableBox: !0
                        }),
                        z2: 10
                    }), textRect = textEl.getBoundingRect(), subText = titleModel.get("subtext"), subTextEl = new graphic.Text({
                        style: graphic.setTextStyle({}, subtextStyleModel, {
                            text: subText,
                            textFill: subtextStyleModel.getTextColor(),
                            y: textRect.height + titleModel.get("itemGap"),
                            textVerticalAlign: "top"
                        }, {
                            disableBox: !0
                        }),
                        z2: 10
                    }), link = titleModel.get("link"), sublink = titleModel.get("sublink"), triggerEvent = titleModel.get("triggerEvent", !0);
                    textEl.silent = !link && !triggerEvent, subTextEl.silent = !sublink && !triggerEvent, 
                    link && textEl.on("click", function() {
                        window.open(link, "_" + titleModel.get("target"));
                    }), sublink && subTextEl.on("click", function() {
                        window.open(sublink, "_" + titleModel.get("subtarget"));
                    }), textEl.eventData = subTextEl.eventData = triggerEvent ? {
                        componentType: "title",
                        componentIndex: titleModel.componentIndex
                    } : null, group.add(textEl), subText && group.add(subTextEl);
                    var groupRect = group.getBoundingRect(), layoutOption = titleModel.getBoxLayoutParams();
                    layoutOption.width = groupRect.width, layoutOption.height = groupRect.height;
                    var layoutRect = getLayoutRect(layoutOption, {
                        width: api.getWidth(),
                        height: api.getHeight()
                    }, titleModel.get("padding"));
                    textAlign || ("middle" === (textAlign = titleModel.get("left") || titleModel.get("right")) && (textAlign = "center"), 
                    "right" === textAlign ? layoutRect.x += layoutRect.width : "center" === textAlign && (layoutRect.x += layoutRect.width / 2)), 
                    textVerticalAlign || ("center" === (textVerticalAlign = titleModel.get("top") || titleModel.get("bottom")) && (textVerticalAlign = "middle"), 
                    "bottom" === textVerticalAlign ? layoutRect.y += layoutRect.height : "middle" === textVerticalAlign && (layoutRect.y += layoutRect.height / 2), 
                    textVerticalAlign = textVerticalAlign || "top"), group.attr("position", [ layoutRect.x, layoutRect.y ]);
                    var alignStyle = {
                        textAlign: textAlign,
                        textVerticalAlign: textVerticalAlign
                    };
                    textEl.setStyle(alignStyle), subTextEl.setStyle(alignStyle), groupRect = group.getBoundingRect();
                    var padding = layoutRect.margin, style = titleModel.getItemStyle([ "color", "opacity" ]);
                    style.fill = titleModel.get("backgroundColor");
                    var rect = new graphic.Rect({
                        shape: {
                            x: groupRect.x - padding[3],
                            y: groupRect.y - padding[0],
                            width: groupRect.width + padding[1] + padding[3],
                            height: groupRect.height + padding[0] + padding[2],
                            r: titleModel.get("borderRadius")
                        },
                        style: style,
                        subPixelOptimize: !0,
                        silent: !0
                    });
                    group.add(rect);
                }
            }
        });
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(297), __webpack_require__(301);
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(139), __webpack_require__(46), __webpack_require__(48), __webpack_require__(299), 
        __webpack_require__(300), __webpack_require__(140), __webpack_require__(141);
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), numberUtil = __webpack_require__(4), helper = __webpack_require__(72), sliderMove = __webpack_require__(47), each = zrUtil.each, asc = numberUtil.asc, AxisProxy = function(dimName, axisIndex, dataZoomModel, ecModel) {
            this._dimName = dimName, this._axisIndex = axisIndex, this._valueWindow, this._percentWindow, 
            this._dataExtent, this._minMaxSpan, this.ecModel = ecModel, this._dataZoomModel = dataZoomModel;
        };
        function setAxisModel(axisProxy, isRestore) {
            var axisModel = axisProxy.getAxisModel(), percentWindow = axisProxy._percentWindow, valueWindow = axisProxy._valueWindow;
            if (percentWindow) {
                var precision = numberUtil.getPixelPrecision(valueWindow, [ 0, 500 ]);
                precision = Math.min(precision, 20);
                var useOrigin = isRestore || 0 === percentWindow[0] && 100 === percentWindow[1];
                axisModel.setRange(useOrigin ? null : +valueWindow[0].toFixed(precision), useOrigin ? null : +valueWindow[1].toFixed(precision));
            }
        }
        AxisProxy.prototype = {
            constructor: AxisProxy,
            hostedBy: function(dataZoomModel) {
                return this._dataZoomModel === dataZoomModel;
            },
            getDataValueWindow: function() {
                return this._valueWindow.slice();
            },
            getDataPercentWindow: function() {
                return this._percentWindow.slice();
            },
            getTargetSeriesModels: function() {
                var seriesModels = [], ecModel = this.ecModel;
                return ecModel.eachSeries(function(seriesModel) {
                    if (helper.isCoordSupported(seriesModel.get("coordinateSystem"))) {
                        var dimName = this._dimName, axisModel = ecModel.queryComponents({
                            mainType: dimName + "Axis",
                            index: seriesModel.get(dimName + "AxisIndex"),
                            id: seriesModel.get(dimName + "AxisId")
                        })[0];
                        this._axisIndex === (axisModel && axisModel.componentIndex) && seriesModels.push(seriesModel);
                    }
                }, this), seriesModels;
            },
            getAxisModel: function() {
                return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
            },
            getOtherAxisModel: function() {
                var otherAxisDim, coordSysIndexName, foundOtherAxisModel, axisDim = this._dimName, ecModel = this.ecModel, axisModel = this.getAxisModel();
                return "x" === axisDim || "y" === axisDim ? (coordSysIndexName = "gridIndex", otherAxisDim = "x" === axisDim ? "y" : "x") : (coordSysIndexName = "polarIndex", 
                otherAxisDim = "angle" === axisDim ? "radius" : "angle"), ecModel.eachComponent(otherAxisDim + "Axis", function(otherAxisModel) {
                    (otherAxisModel.get(coordSysIndexName) || 0) === (axisModel.get(coordSysIndexName) || 0) && (foundOtherAxisModel = otherAxisModel);
                }), foundOtherAxisModel;
            },
            getMinMaxSpan: function() {
                return zrUtil.clone(this._minMaxSpan);
            },
            calculateDataWindow: function(opt) {
                var hasPropModeValue, dataExtent = this._dataExtent, scale = this.getAxisModel().axis.scale, rangePropMode = this._dataZoomModel.getRangePropMode(), percentExtent = [ 0, 100 ], percentWindow = [], valueWindow = [];
                each([ "start", "end" ], function(prop, idx) {
                    var boundPercent = opt[prop], boundValue = opt[prop + "Value"];
                    "percent" === rangePropMode[idx] ? (null == boundPercent && (boundPercent = percentExtent[idx]), 
                    boundValue = scale.parse(numberUtil.linearMap(boundPercent, percentExtent, dataExtent))) : (hasPropModeValue = !0, 
                    boundValue = null == boundValue ? dataExtent[idx] : scale.parse(boundValue), boundPercent = numberUtil.linearMap(boundValue, dataExtent, percentExtent)), 
                    valueWindow[idx] = boundValue, percentWindow[idx] = boundPercent;
                }), asc(valueWindow), asc(percentWindow);
                var spans = this._minMaxSpan;
                function restrictSet(fromWindow, toWindow, fromExtent, toExtent, toValue) {
                    var suffix = toValue ? "Span" : "ValueSpan";
                    sliderMove(0, fromWindow, fromExtent, "all", spans["min" + suffix], spans["max" + suffix]);
                    for (var i = 0; i < 2; i++) toWindow[i] = numberUtil.linearMap(fromWindow[i], fromExtent, toExtent, !0), 
                    toValue && (toWindow[i] = scale.parse(toWindow[i]));
                }
                return hasPropModeValue ? restrictSet(valueWindow, percentWindow, dataExtent, percentExtent, !1) : restrictSet(percentWindow, valueWindow, percentExtent, dataExtent, !0), 
                {
                    valueWindow: valueWindow,
                    percentWindow: percentWindow
                };
            },
            reset: function(dataZoomModel) {
                if (dataZoomModel === this._dataZoomModel) {
                    var targetSeries = this.getTargetSeriesModels();
                    this._dataExtent = function(axisProxy, axisDim, seriesModels) {
                        var dataExtent = [ 1 / 0, -1 / 0 ];
                        each(seriesModels, function(seriesModel) {
                            var seriesData = seriesModel.getData();
                            seriesData && each(seriesData.mapDimension(axisDim, !0), function(dim) {
                                var seriesExtent = seriesData.getApproximateExtent(dim);
                                seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]), seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);
                            });
                        }), dataExtent[1] < dataExtent[0] && (dataExtent = [ NaN, NaN ]);
                        return function(axisProxy, dataExtent) {
                            var axisModel = axisProxy.getAxisModel(), min = axisModel.getMin(!0), isCategoryAxis = "category" === axisModel.get("type"), axisDataLen = isCategoryAxis && axisModel.getCategories().length;
                            null != min && "dataMin" !== min && "function" != typeof min ? dataExtent[0] = min : isCategoryAxis && (dataExtent[0] = axisDataLen > 0 ? 0 : NaN);
                            var max = axisModel.getMax(!0);
                            null != max && "dataMax" !== max && "function" != typeof max ? dataExtent[1] = max : isCategoryAxis && (dataExtent[1] = axisDataLen > 0 ? axisDataLen - 1 : NaN), 
                            axisModel.get("scale", !0) || (dataExtent[0] > 0 && (dataExtent[0] = 0), dataExtent[1] < 0 && (dataExtent[1] = 0));
                        }(axisProxy, dataExtent), dataExtent;
                    }(this, this._dimName, targetSeries), function(axisProxy) {
                        var minMaxSpan = axisProxy._minMaxSpan = {}, dataZoomModel = axisProxy._dataZoomModel, dataExtent = axisProxy._dataExtent;
                        each([ "min", "max" ], function(minMax) {
                            var percentSpan = dataZoomModel.get(minMax + "Span"), valueSpan = dataZoomModel.get(minMax + "ValueSpan");
                            null != valueSpan && (valueSpan = axisProxy.getAxisModel().axis.scale.parse(valueSpan)), 
                            null != valueSpan ? percentSpan = numberUtil.linearMap(dataExtent[0] + valueSpan, dataExtent, [ 0, 100 ], !0) : null != percentSpan && (valueSpan = numberUtil.linearMap(percentSpan, [ 0, 100 ], dataExtent, !0) - dataExtent[0]), 
                            minMaxSpan[minMax + "Span"] = percentSpan, minMaxSpan[minMax + "ValueSpan"] = valueSpan;
                        });
                    }(this);
                    var dataWindow = this.calculateDataWindow(dataZoomModel.option);
                    this._valueWindow = dataWindow.valueWindow, this._percentWindow = dataWindow.percentWindow, 
                    setAxisModel(this);
                }
            },
            restore: function(dataZoomModel) {
                dataZoomModel === this._dataZoomModel && (this._valueWindow = this._percentWindow = null, 
                setAxisModel(this, !0));
            },
            filterData: function(dataZoomModel, api) {
                if (dataZoomModel === this._dataZoomModel) {
                    var axisDim = this._dimName, seriesModels = this.getTargetSeriesModels(), filterMode = dataZoomModel.get("filterMode"), valueWindow = this._valueWindow;
                    "none" !== filterMode && each(seriesModels, function(seriesModel) {
                        var seriesData = seriesModel.getData(), dataDims = seriesData.mapDimension(axisDim, !0);
                        dataDims.length && ("weakFilter" === filterMode ? seriesData.filterSelf(function(dataIndex) {
                            for (var leftOut, rightOut, hasValue, i = 0; i < dataDims.length; i++) {
                                var value = seriesData.get(dataDims[i], dataIndex), thisHasValue = !isNaN(value), thisLeftOut = value < valueWindow[0], thisRightOut = value > valueWindow[1];
                                if (thisHasValue && !thisLeftOut && !thisRightOut) return !0;
                                thisHasValue && (hasValue = !0), thisLeftOut && (leftOut = !0), thisRightOut && (rightOut = !0);
                            }
                            return hasValue && leftOut && rightOut;
                        }) : each(dataDims, function(dim) {
                            if ("empty" === filterMode) seriesModel.setData(seriesData = seriesData.map(dim, function(value) {
                                return function(value) {
                                    return value >= valueWindow[0] && value <= valueWindow[1];
                                }(value) ? value : NaN;
                            })); else {
                                var range = {};
                                range[dim] = valueWindow, seriesData.selectRange(range);
                            }
                        }), each(dataDims, function(dim) {
                            seriesData.setApproximateExtent(valueWindow, dim);
                        }));
                    });
                }
            }
        };
        var _default = AxisProxy;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var _default = __webpack_require__(46).extend({
            type: "dataZoom.slider",
            layoutMode: "box",
            defaultOption: {
                show: !0,
                right: "ph",
                top: "ph",
                width: "ph",
                height: "ph",
                left: null,
                bottom: null,
                backgroundColor: "rgba(47,69,84,0)",
                dataBackground: {
                    lineStyle: {
                        color: "#2f4554",
                        width: .5,
                        opacity: .3
                    },
                    areaStyle: {
                        color: "rgba(47,69,84,0.3)",
                        opacity: .3
                    }
                },
                borderColor: "#ddd",
                fillerColor: "rgba(167,183,204,0.4)",
                handleIcon: "M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z",
                handleSize: "100%",
                handleStyle: {
                    color: "#a7b7cc"
                },
                labelPrecision: null,
                labelFormatter: null,
                showDetail: !0,
                showDataShadow: "auto",
                realtime: !0,
                zoomLock: !1,
                textStyle: {
                    color: "#333"
                }
            }
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), eventTool = __webpack_require__(15), graphic = __webpack_require__(2), throttle = __webpack_require__(31), DataZoomView = __webpack_require__(48), numberUtil = __webpack_require__(4), layout = __webpack_require__(10), sliderMove = __webpack_require__(47), Rect = graphic.Rect, linearMap = numberUtil.linearMap, asc = numberUtil.asc, bind = zrUtil.bind, each = zrUtil.each, HORIZONTAL = "horizontal", LABEL_GAP = 5, SHOW_DATA_SHADOW_SERIES_TYPE = [ "line", "bar", "candlestick", "scatter" ], SliderZoomView = DataZoomView.extend({
            type: "dataZoom.slider",
            init: function(ecModel, api) {
                this._displayables = {}, this._orient, this._range, this._handleEnds, this._size, 
                this._handleWidth, this._handleHeight, this._location, this._dragging, this._dataShadowInfo, 
                this.api = api;
            },
            render: function(dataZoomModel, ecModel, api, payload) {
                SliderZoomView.superApply(this, "render", arguments), throttle.createOrUpdate(this, "_dispatchZoomAction", this.dataZoomModel.get("throttle"), "fixRate"), 
                this._orient = dataZoomModel.get("orient"), !1 !== this.dataZoomModel.get("show") ? (payload && "dataZoom" === payload.type && payload.from === this.uid || this._buildView(), 
                this._updateView()) : this.group.removeAll();
            },
            remove: function() {
                SliderZoomView.superApply(this, "remove", arguments), throttle.clear(this, "_dispatchZoomAction");
            },
            dispose: function() {
                SliderZoomView.superApply(this, "dispose", arguments), throttle.clear(this, "_dispatchZoomAction");
            },
            _buildView: function() {
                var thisGroup = this.group;
                thisGroup.removeAll(), this._resetLocation(), this._resetInterval();
                var barGroup = this._displayables.barGroup = new graphic.Group();
                this._renderBackground(), this._renderHandle(), this._renderDataShadow(), thisGroup.add(barGroup), 
                this._positionGroup();
            },
            _resetLocation: function() {
                var dataZoomModel = this.dataZoomModel, api = this.api, coordRect = this._findCoordRect(), ecSize = {
                    width: api.getWidth(),
                    height: api.getHeight()
                }, positionInfo = this._orient === HORIZONTAL ? {
                    right: ecSize.width - coordRect.x - coordRect.width,
                    top: ecSize.height - 30 - 7,
                    width: coordRect.width,
                    height: 30
                } : {
                    right: 7,
                    top: coordRect.y,
                    width: 30,
                    height: coordRect.height
                }, layoutParams = layout.getLayoutParams(dataZoomModel.option);
                zrUtil.each([ "right", "top", "width", "height" ], function(name) {
                    "ph" === layoutParams[name] && (layoutParams[name] = positionInfo[name]);
                });
                var layoutRect = layout.getLayoutRect(layoutParams, ecSize, dataZoomModel.padding);
                this._location = {
                    x: layoutRect.x,
                    y: layoutRect.y
                }, this._size = [ layoutRect.width, layoutRect.height ], "vertical" === this._orient && this._size.reverse();
            },
            _positionGroup: function() {
                var thisGroup = this.group, location = this._location, orient = this._orient, targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel(), inverse = targetAxisModel && targetAxisModel.get("inverse"), barGroup = this._displayables.barGroup, otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse;
                barGroup.attr(orient !== HORIZONTAL || inverse ? orient === HORIZONTAL && inverse ? {
                    scale: otherAxisInverse ? [ -1, 1 ] : [ -1, -1 ]
                } : "vertical" !== orient || inverse ? {
                    scale: otherAxisInverse ? [ -1, -1 ] : [ -1, 1 ],
                    rotation: Math.PI / 2
                } : {
                    scale: otherAxisInverse ? [ 1, -1 ] : [ 1, 1 ],
                    rotation: Math.PI / 2
                } : {
                    scale: otherAxisInverse ? [ 1, 1 ] : [ 1, -1 ]
                });
                var rect = thisGroup.getBoundingRect([ barGroup ]);
                thisGroup.attr("position", [ location.x - rect.x, location.y - rect.y ]);
            },
            _getViewExtent: function() {
                return [ 0, this._size[0] ];
            },
            _renderBackground: function() {
                var dataZoomModel = this.dataZoomModel, size = this._size, barGroup = this._displayables.barGroup;
                barGroup.add(new Rect({
                    silent: !0,
                    shape: {
                        x: 0,
                        y: 0,
                        width: size[0],
                        height: size[1]
                    },
                    style: {
                        fill: dataZoomModel.get("backgroundColor")
                    },
                    z2: -40
                })), barGroup.add(new Rect({
                    shape: {
                        x: 0,
                        y: 0,
                        width: size[0],
                        height: size[1]
                    },
                    style: {
                        fill: "transparent"
                    },
                    z2: 0,
                    onclick: zrUtil.bind(this._onClickPanelClick, this)
                }));
            },
            _renderDataShadow: function() {
                var info = this._dataShadowInfo = this._prepareDataShadowInfo();
                if (info) {
                    var size = this._size, seriesModel = info.series, data = seriesModel.getRawData(), otherDim = seriesModel.getShadowDim ? seriesModel.getShadowDim() : info.otherDim;
                    if (null != otherDim) {
                        var otherDataExtent = data.getDataExtent(otherDim), otherOffset = .3 * (otherDataExtent[1] - otherDataExtent[0]);
                        otherDataExtent = [ otherDataExtent[0] - otherOffset, otherDataExtent[1] + otherOffset ];
                        var lastIsEmpty, otherShadowExtent = [ 0, size[1] ], thisShadowExtent = [ 0, size[0] ], areaPoints = [ [ size[0], 0 ], [ 0, 0 ] ], linePoints = [], step = thisShadowExtent[1] / (data.count() - 1), thisCoord = 0, stride = Math.round(data.count() / size[0]);
                        data.each([ otherDim ], function(value, index) {
                            if (stride > 0 && index % stride) thisCoord += step; else {
                                var isEmpty = null == value || isNaN(value) || "" === value, otherCoord = isEmpty ? 0 : linearMap(value, otherDataExtent, otherShadowExtent, !0);
                                isEmpty && !lastIsEmpty && index ? (areaPoints.push([ areaPoints[areaPoints.length - 1][0], 0 ]), 
                                linePoints.push([ linePoints[linePoints.length - 1][0], 0 ])) : !isEmpty && lastIsEmpty && (areaPoints.push([ thisCoord, 0 ]), 
                                linePoints.push([ thisCoord, 0 ])), areaPoints.push([ thisCoord, otherCoord ]), 
                                linePoints.push([ thisCoord, otherCoord ]), thisCoord += step, lastIsEmpty = isEmpty;
                            }
                        });
                        var dataZoomModel = this.dataZoomModel;
                        this._displayables.barGroup.add(new graphic.Polygon({
                            shape: {
                                points: areaPoints
                            },
                            style: zrUtil.defaults({
                                fill: dataZoomModel.get("dataBackgroundColor")
                            }, dataZoomModel.getModel("dataBackground.areaStyle").getAreaStyle()),
                            silent: !0,
                            z2: -20
                        })), this._displayables.barGroup.add(new graphic.Polyline({
                            shape: {
                                points: linePoints
                            },
                            style: dataZoomModel.getModel("dataBackground.lineStyle").getLineStyle(),
                            silent: !0,
                            z2: -19
                        }));
                    }
                }
            },
            _prepareDataShadowInfo: function() {
                var dataZoomModel = this.dataZoomModel, showDataShadow = dataZoomModel.get("showDataShadow");
                if (!1 !== showDataShadow) {
                    var result, ecModel = this.ecModel;
                    return dataZoomModel.eachTargetAxis(function(dimNames, axisIndex) {
                        var seriesModels = dataZoomModel.getAxisProxy(dimNames.name, axisIndex).getTargetSeriesModels();
                        zrUtil.each(seriesModels, function(seriesModel) {
                            if (!(result || !0 !== showDataShadow && zrUtil.indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get("type")) < 0)) {
                                var otherAxisInverse, thisAxis = ecModel.getComponent(dimNames.axis, axisIndex).axis, otherDim = function(thisDim) {
                                    return {
                                        x: "y",
                                        y: "x",
                                        radius: "angle",
                                        angle: "radius"
                                    }[thisDim];
                                }(dimNames.name), coordSys = seriesModel.coordinateSystem;
                                null != otherDim && coordSys.getOtherAxis && (otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse), 
                                otherDim = seriesModel.getData().mapDimension(otherDim), result = {
                                    thisAxis: thisAxis,
                                    series: seriesModel,
                                    thisDim: dimNames.name,
                                    otherDim: otherDim,
                                    otherAxisInverse: otherAxisInverse
                                };
                            }
                        }, this);
                    }, this), result;
                }
            },
            _renderHandle: function() {
                var displaybles = this._displayables, handles = displaybles.handles = [], handleLabels = displaybles.handleLabels = [], barGroup = this._displayables.barGroup, size = this._size, dataZoomModel = this.dataZoomModel;
                barGroup.add(displaybles.filler = new Rect({
                    draggable: !0,
                    cursor: getCursor(this._orient),
                    drift: bind(this._onDragMove, this, "all"),
                    onmousemove: function(e) {
                        eventTool.stop(e.event);
                    },
                    ondragstart: bind(this._showDataInfo, this, !0),
                    ondragend: bind(this._onDragEnd, this),
                    onmouseover: bind(this._showDataInfo, this, !0),
                    onmouseout: bind(this._showDataInfo, this, !1),
                    style: {
                        fill: dataZoomModel.get("fillerColor"),
                        textPosition: "inside"
                    }
                })), barGroup.add(new Rect({
                    silent: !0,
                    subPixelOptimize: !0,
                    shape: {
                        x: 0,
                        y: 0,
                        width: size[0],
                        height: size[1]
                    },
                    style: {
                        stroke: dataZoomModel.get("dataBackgroundColor") || dataZoomModel.get("borderColor"),
                        lineWidth: 1,
                        fill: "rgba(0,0,0,0)"
                    }
                })), each([ 0, 1 ], function(handleIndex) {
                    var path = graphic.createIcon(dataZoomModel.get("handleIcon"), {
                        cursor: getCursor(this._orient),
                        draggable: !0,
                        drift: bind(this._onDragMove, this, handleIndex),
                        onmousemove: function(e) {
                            eventTool.stop(e.event);
                        },
                        ondragend: bind(this._onDragEnd, this),
                        onmouseover: bind(this._showDataInfo, this, !0),
                        onmouseout: bind(this._showDataInfo, this, !1)
                    }, {
                        x: -1,
                        y: 0,
                        width: 2,
                        height: 2
                    }), bRect = path.getBoundingRect();
                    this._handleHeight = numberUtil.parsePercent(dataZoomModel.get("handleSize"), this._size[1]), 
                    this._handleWidth = bRect.width / bRect.height * this._handleHeight, path.setStyle(dataZoomModel.getModel("handleStyle").getItemStyle());
                    var handleColor = dataZoomModel.get("handleColor");
                    null != handleColor && (path.style.fill = handleColor), barGroup.add(handles[handleIndex] = path);
                    var textStyleModel = dataZoomModel.textStyleModel;
                    this.group.add(handleLabels[handleIndex] = new graphic.Text({
                        silent: !0,
                        invisible: !0,
                        style: {
                            x: 0,
                            y: 0,
                            text: "",
                            textVerticalAlign: "middle",
                            textAlign: "center",
                            textFill: textStyleModel.getTextColor(),
                            textFont: textStyleModel.getFont()
                        },
                        z2: 10
                    }));
                }, this);
            },
            _resetInterval: function() {
                var range = this._range = this.dataZoomModel.getPercentRange(), viewExtent = this._getViewExtent();
                this._handleEnds = [ linearMap(range[0], [ 0, 100 ], viewExtent, !0), linearMap(range[1], [ 0, 100 ], viewExtent, !0) ];
            },
            _updateInterval: function(handleIndex, delta) {
                var dataZoomModel = this.dataZoomModel, handleEnds = this._handleEnds, viewExtend = this._getViewExtent(), minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan(), percentExtent = [ 0, 100 ];
                sliderMove(delta, handleEnds, viewExtend, dataZoomModel.get("zoomLock") ? "all" : handleIndex, null != minMaxSpan.minSpan ? linearMap(minMaxSpan.minSpan, percentExtent, viewExtend, !0) : null, null != minMaxSpan.maxSpan ? linearMap(minMaxSpan.maxSpan, percentExtent, viewExtend, !0) : null);
                var lastRange = this._range, range = this._range = asc([ linearMap(handleEnds[0], viewExtend, percentExtent, !0), linearMap(handleEnds[1], viewExtend, percentExtent, !0) ]);
                return !lastRange || lastRange[0] !== range[0] || lastRange[1] !== range[1];
            },
            _updateView: function(nonRealtime) {
                var displaybles = this._displayables, handleEnds = this._handleEnds, handleInterval = asc(handleEnds.slice()), size = this._size;
                each([ 0, 1 ], function(handleIndex) {
                    var handle = displaybles.handles[handleIndex], handleHeight = this._handleHeight;
                    handle.attr({
                        scale: [ handleHeight / 2, handleHeight / 2 ],
                        position: [ handleEnds[handleIndex], size[1] / 2 - handleHeight / 2 ]
                    });
                }, this), displaybles.filler.setShape({
                    x: handleInterval[0],
                    y: 0,
                    width: handleInterval[1] - handleInterval[0],
                    height: size[1]
                }), this._updateDataInfo(nonRealtime);
            },
            _updateDataInfo: function(nonRealtime) {
                var dataZoomModel = this.dataZoomModel, displaybles = this._displayables, handleLabels = displaybles.handleLabels, orient = this._orient, labelTexts = [ "", "" ];
                if (dataZoomModel.get("showDetail")) {
                    var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
                    if (axisProxy) {
                        var axis = axisProxy.getAxisModel().axis, range = this._range, dataInterval = nonRealtime ? axisProxy.calculateDataWindow({
                            start: range[0],
                            end: range[1]
                        }).valueWindow : axisProxy.getDataValueWindow();
                        labelTexts = [ this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis) ];
                    }
                }
                var orderedHandleEnds = asc(this._handleEnds.slice());
                function setLabel(handleIndex) {
                    var barTransform = graphic.getTransform(displaybles.handles[handleIndex].parent, this.group), direction = graphic.transformDirection(0 === handleIndex ? "right" : "left", barTransform), offset = this._handleWidth / 2 + LABEL_GAP, textPoint = graphic.applyTransform([ orderedHandleEnds[handleIndex] + (0 === handleIndex ? -offset : offset), this._size[1] / 2 ], barTransform);
                    handleLabels[handleIndex].setStyle({
                        x: textPoint[0],
                        y: textPoint[1],
                        textVerticalAlign: orient === HORIZONTAL ? "middle" : direction,
                        textAlign: orient === HORIZONTAL ? direction : "center",
                        text: labelTexts[handleIndex]
                    });
                }
                setLabel.call(this, 0), setLabel.call(this, 1);
            },
            _formatLabel: function(value, axis) {
                var dataZoomModel = this.dataZoomModel, labelFormatter = dataZoomModel.get("labelFormatter"), labelPrecision = dataZoomModel.get("labelPrecision");
                null != labelPrecision && "auto" !== labelPrecision || (labelPrecision = axis.getPixelPrecision());
                var valueStr = null == value || isNaN(value) ? "" : "category" === axis.type || "time" === axis.type ? axis.scale.getLabel(Math.round(value)) : value.toFixed(Math.min(labelPrecision, 20));
                return zrUtil.isFunction(labelFormatter) ? labelFormatter(value, valueStr) : zrUtil.isString(labelFormatter) ? labelFormatter.replace("{value}", valueStr) : valueStr;
            },
            _showDataInfo: function(showOrHide) {
                showOrHide = this._dragging || showOrHide;
                var handleLabels = this._displayables.handleLabels;
                handleLabels[0].attr("invisible", !showOrHide), handleLabels[1].attr("invisible", !showOrHide);
            },
            _onDragMove: function(handleIndex, dx, dy) {
                this._dragging = !0;
                var barTransform = this._displayables.barGroup.getLocalTransform(), vertex = graphic.applyTransform([ dx, dy ], barTransform, !0), changed = this._updateInterval(handleIndex, vertex[0]), realtime = this.dataZoomModel.get("realtime");
                this._updateView(!realtime), changed && realtime && this._dispatchZoomAction();
            },
            _onDragEnd: function() {
                this._dragging = !1, this._showDataInfo(!1), !this.dataZoomModel.get("realtime") && this._dispatchZoomAction();
            },
            _onClickPanelClick: function(e) {
                var size = this._size, localPoint = this._displayables.barGroup.transformCoordToLocal(e.offsetX, e.offsetY);
                if (!(localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1])) {
                    var handleEnds = this._handleEnds, center = (handleEnds[0] + handleEnds[1]) / 2, changed = this._updateInterval("all", localPoint[0] - center);
                    this._updateView(), changed && this._dispatchZoomAction();
                }
            },
            _dispatchZoomAction: function() {
                var range = this._range;
                this.api.dispatchAction({
                    type: "dataZoom",
                    from: this.uid,
                    dataZoomId: this.dataZoomModel.id,
                    start: range[0],
                    end: range[1]
                });
            },
            _findCoordRect: function() {
                var rect;
                if (each(this.getTargetCoordInfo(), function(coordInfoList) {
                    if (!rect && coordInfoList.length) {
                        var coordSys = coordInfoList[0].model.coordinateSystem;
                        rect = coordSys.getRect && coordSys.getRect();
                    }
                }), !rect) {
                    var width = this.api.getWidth(), height = this.api.getHeight();
                    rect = {
                        x: .2 * width,
                        y: .2 * height,
                        width: .6 * width,
                        height: .6 * height
                    };
                }
                return rect;
            }
        });
        function getCursor(orient) {
            return "vertical" === orient ? "ns-resize" : "ew-resize";
        }
        var _default = SliderZoomView;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(139), __webpack_require__(46), __webpack_require__(48), __webpack_require__(302), 
        __webpack_require__(303), __webpack_require__(140), __webpack_require__(141);
    }, function(module, exports, __webpack_require__) {
        var _default = __webpack_require__(46).extend({
            type: "dataZoom.inside",
            defaultOption: {
                disabled: !1,
                zoomLock: !1,
                zoomOnMouseWheel: !0,
                moveOnMouseMove: !0,
                moveOnMouseWheel: !1,
                preventDefaultMouseMove: !0
            }
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), DataZoomView = __webpack_require__(48), sliderMove = __webpack_require__(47), roams = __webpack_require__(304), bind = zrUtil.bind, InsideZoomView = DataZoomView.extend({
            type: "dataZoom.inside",
            init: function(ecModel, api) {
                this._range;
            },
            render: function(dataZoomModel, ecModel, api, payload) {
                InsideZoomView.superApply(this, "render", arguments), this._range = dataZoomModel.getPercentRange(), 
                zrUtil.each(this.getTargetCoordInfo(), function(coordInfoList, coordSysName) {
                    var allCoordIds = zrUtil.map(coordInfoList, function(coordInfo) {
                        return roams.generateCoordId(coordInfo.model);
                    });
                    zrUtil.each(coordInfoList, function(coordInfo) {
                        var coordModel = coordInfo.model, getRange = {};
                        zrUtil.each([ "pan", "zoom", "scrollMove" ], function(eventName) {
                            getRange[eventName] = bind(roamHandlers[eventName], this, coordInfo, coordSysName);
                        }, this), roams.register(api, {
                            coordId: roams.generateCoordId(coordModel),
                            allCoordIds: allCoordIds,
                            containsPoint: function(e, x, y) {
                                return coordModel.coordinateSystem.containPoint([ x, y ]);
                            },
                            dataZoomId: dataZoomModel.id,
                            dataZoomModel: dataZoomModel,
                            getRange: getRange
                        });
                    }, this);
                }, this);
            },
            dispose: function() {
                roams.unregister(this.api, this.dataZoomModel.id), InsideZoomView.superApply(this, "dispose", arguments), 
                this._range = null;
            }
        }), roamHandlers = {
            zoom: function(coordInfo, coordSysName, controller, e) {
                var lastRange = this._range, range = lastRange.slice(), axisModel = coordInfo.axisModels[0];
                if (axisModel) {
                    var directionInfo = getDirectionInfo[coordSysName](null, [ e.originX, e.originY ], axisModel, controller, coordInfo), percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0], scale = Math.max(1 / e.scale, 0);
                    range[0] = (range[0] - percentPoint) * scale + percentPoint, range[1] = (range[1] - percentPoint) * scale + percentPoint;
                    var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
                    return sliderMove(0, range, [ 0, 100 ], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan), 
                    this._range = range, lastRange[0] !== range[0] || lastRange[1] !== range[1] ? range : void 0;
                }
            },
            pan: makeMover(function(range, axisModel, coordInfo, coordSysName, controller, e) {
                var directionInfo = getDirectionInfo[coordSysName]([ e.oldX, e.oldY ], [ e.newX, e.newY ], axisModel, controller, coordInfo);
                return directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;
            }),
            scrollMove: makeMover(function(range, axisModel, coordInfo, coordSysName, controller, e) {
                return getDirectionInfo[coordSysName]([ 0, 0 ], [ e.scrollDelta, e.scrollDelta ], axisModel, controller, coordInfo).signal * (range[1] - range[0]) * e.scrollDelta;
            })
        };
        function makeMover(getPercentDelta) {
            return function(coordInfo, coordSysName, controller, e) {
                var lastRange = this._range, range = lastRange.slice(), axisModel = coordInfo.axisModels[0];
                if (axisModel) {
                    var percentDelta = getPercentDelta(range, axisModel, coordInfo, coordSysName, controller, e);
                    return sliderMove(percentDelta, range, [ 0, 100 ], "all"), this._range = range, 
                    lastRange[0] !== range[0] || lastRange[1] !== range[1] ? range : void 0;
                }
            };
        }
        var getDirectionInfo = {
            grid: function(oldPoint, newPoint, axisModel, controller, coordInfo) {
                var axis = axisModel.axis, ret = {}, rect = coordInfo.model.coordinateSystem.getRect();
                return oldPoint = oldPoint || [ 0, 0 ], "x" === axis.dim ? (ret.pixel = newPoint[0] - oldPoint[0], 
                ret.pixelLength = rect.width, ret.pixelStart = rect.x, ret.signal = axis.inverse ? 1 : -1) : (ret.pixel = newPoint[1] - oldPoint[1], 
                ret.pixelLength = rect.height, ret.pixelStart = rect.y, ret.signal = axis.inverse ? -1 : 1), 
                ret;
            },
            polar: function(oldPoint, newPoint, axisModel, controller, coordInfo) {
                var axis = axisModel.axis, ret = {}, polar = coordInfo.model.coordinateSystem, radiusExtent = polar.getRadiusAxis().getExtent(), angleExtent = polar.getAngleAxis().getExtent();
                return oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [ 0, 0 ], newPoint = polar.pointToCoord(newPoint), 
                "radiusAxis" === axisModel.mainType ? (ret.pixel = newPoint[0] - oldPoint[0], ret.pixelLength = radiusExtent[1] - radiusExtent[0], 
                ret.pixelStart = radiusExtent[0], ret.signal = axis.inverse ? 1 : -1) : (ret.pixel = newPoint[1] - oldPoint[1], 
                ret.pixelLength = angleExtent[1] - angleExtent[0], ret.pixelStart = angleExtent[0], 
                ret.signal = axis.inverse ? -1 : 1), ret;
            },
            singleAxis: function(oldPoint, newPoint, axisModel, controller, coordInfo) {
                var axis = axisModel.axis, rect = coordInfo.model.coordinateSystem.getRect(), ret = {};
                return oldPoint = oldPoint || [ 0, 0 ], "horizontal" === axis.orient ? (ret.pixel = newPoint[0] - oldPoint[0], 
                ret.pixelLength = rect.width, ret.pixelStart = rect.x, ret.signal = axis.inverse ? 1 : -1) : (ret.pixel = newPoint[1] - oldPoint[1], 
                ret.pixelLength = rect.height, ret.pixelStart = rect.y, ret.signal = axis.inverse ? -1 : 1), 
                ret;
            }
        }, _default = InsideZoomView;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), RoamController = __webpack_require__(305), throttleUtil = __webpack_require__(31), ATTR = "\0_ec_dataZoom_roams";
        function giveStore(api) {
            var zr = api.getZr();
            return zr[ATTR] || (zr[ATTR] = {});
        }
        function cleanStore(store) {
            zrUtil.each(store, function(record, coordId) {
                record.count || (record.controller.dispose(), delete store[coordId]);
            });
        }
        function dispatchAction(api, batch) {
            api.dispatchAction({
                type: "dataZoom",
                batch: batch
            });
        }
        exports.register = function(api, dataZoomInfo) {
            var store = giveStore(api), theDataZoomId = dataZoomInfo.dataZoomId, theCoordId = dataZoomInfo.coordId;
            zrUtil.each(store, function(record, coordId) {
                var dataZoomInfos = record.dataZoomInfos;
                dataZoomInfos[theDataZoomId] && zrUtil.indexOf(dataZoomInfo.allCoordIds, theCoordId) < 0 && (delete dataZoomInfos[theDataZoomId], 
                record.count--);
            }), cleanStore(store);
            var record = store[theCoordId];
            record || ((record = store[theCoordId] = {
                coordId: theCoordId,
                dataZoomInfos: {},
                count: 0
            }).controller = function(api, newRecord) {
                var controller = new RoamController(api.getZr());
                return zrUtil.each([ "pan", "zoom", "scrollMove" ], function(eventName) {
                    controller.on(eventName, function(event) {
                        var batch = [];
                        zrUtil.each(newRecord.dataZoomInfos, function(info) {
                            if (event.isAvailableBehavior(info.dataZoomModel.option)) {
                                var method = (info.getRange || {})[eventName], range = method && method(newRecord.controller, event);
                                !info.dataZoomModel.get("disabled", !0) && range && batch.push({
                                    dataZoomId: info.dataZoomId,
                                    start: range[0],
                                    end: range[1]
                                });
                            }
                        }), batch.length && newRecord.dispatchAction(batch);
                    });
                }), controller;
            }(api, record), record.dispatchAction = zrUtil.curry(dispatchAction, api)), !record.dataZoomInfos[theDataZoomId] && record.count++, 
            record.dataZoomInfos[theDataZoomId] = dataZoomInfo;
            var controllerParams = function(dataZoomInfos) {
                var controlType, typePriority = {
                    type_true: 2,
                    type_move: 1,
                    type_false: 0,
                    type_undefined: -1
                }, preventDefaultMouseMove = !0;
                return zrUtil.each(dataZoomInfos, function(dataZoomInfo) {
                    var dataZoomModel = dataZoomInfo.dataZoomModel, oneType = !dataZoomModel.get("disabled", !0) && (!dataZoomModel.get("zoomLock", !0) || "move");
                    typePriority["type_" + oneType] > typePriority["type_" + controlType] && (controlType = oneType), 
                    preventDefaultMouseMove &= dataZoomModel.get("preventDefaultMouseMove", !0);
                }), {
                    controlType: controlType,
                    opt: {
                        zoomOnMouseWheel: !0,
                        moveOnMouseMove: !0,
                        moveOnMouseWheel: !0,
                        preventDefaultMouseMove: !!preventDefaultMouseMove
                    }
                };
            }(record.dataZoomInfos);
            record.controller.enable(controllerParams.controlType, controllerParams.opt), record.controller.setPointerChecker(dataZoomInfo.containsPoint), 
            throttleUtil.createOrUpdate(record, "dispatchAction", dataZoomInfo.dataZoomModel.get("throttle", !0), "fixRate");
        }, exports.unregister = function(api, dataZoomId) {
            var store = giveStore(api);
            zrUtil.each(store, function(record) {
                record.controller.dispose();
                var dataZoomInfos = record.dataZoomInfos;
                dataZoomInfos[dataZoomId] && (delete dataZoomInfos[dataZoomId], record.count--);
            }), cleanStore(store);
        }, exports.generateCoordId = function(coordModel) {
            return coordModel.type + "\0_" + coordModel.id;
        };
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), Eventful = __webpack_require__(23), eventTool = __webpack_require__(15), interactionMutex = __webpack_require__(306);
        function RoamController(zr) {
            this.pointerChecker, this._zr = zr, this._opt = {};
            var bind = zrUtil.bind, mousedownHandler = bind(mousedown, this), mousemoveHandler = bind(mousemove, this), mouseupHandler = bind(mouseup, this), mousewheelHandler = bind(mousewheel, this), pinchHandler = bind(pinch, this);
            Eventful.call(this), this.setPointerChecker = function(pointerChecker) {
                this.pointerChecker = pointerChecker;
            }, this.enable = function(controlType, opt) {
                this.disable(), this._opt = zrUtil.defaults(zrUtil.clone(opt) || {}, {
                    zoomOnMouseWheel: !0,
                    moveOnMouseMove: !0,
                    moveOnMouseWheel: !1,
                    preventDefaultMouseMove: !0
                }), null == controlType && (controlType = !0), !0 !== controlType && "move" !== controlType && "pan" !== controlType || (zr.on("mousedown", mousedownHandler), 
                zr.on("mousemove", mousemoveHandler), zr.on("mouseup", mouseupHandler)), !0 !== controlType && "scale" !== controlType && "zoom" !== controlType || (zr.on("mousewheel", mousewheelHandler), 
                zr.on("pinch", pinchHandler));
            }, this.disable = function() {
                zr.off("mousedown", mousedownHandler), zr.off("mousemove", mousemoveHandler), zr.off("mouseup", mouseupHandler), 
                zr.off("mousewheel", mousewheelHandler), zr.off("pinch", pinchHandler);
            }, this.dispose = this.disable, this.isDragging = function() {
                return this._dragging;
            }, this.isPinching = function() {
                return this._pinching;
            };
        }
        function mousedown(e) {
            if (!(eventTool.isMiddleOrRightButtonOnMouseUpDown(e) || e.target && e.target.draggable)) {
                var x = e.offsetX, y = e.offsetY;
                this.pointerChecker && this.pointerChecker(e, x, y) && (this._x = x, this._y = y, 
                this._dragging = !0);
            }
        }
        function mousemove(e) {
            if (this._dragging && isAvailableBehavior("moveOnMouseMove", e, this._opt) && "pinch" !== e.gestureEvent && !interactionMutex.isTaken(this._zr, "globalPan")) {
                var x = e.offsetX, y = e.offsetY, oldX = this._x, oldY = this._y, dx = x - oldX, dy = y - oldY;
                this._x = x, this._y = y, this._opt.preventDefaultMouseMove && eventTool.stop(e.event), 
                trigger(this, "pan", "moveOnMouseMove", e, {
                    dx: dx,
                    dy: dy,
                    oldX: oldX,
                    oldY: oldY,
                    newX: x,
                    newY: y
                });
            }
        }
        function mouseup(e) {
            eventTool.isMiddleOrRightButtonOnMouseUpDown(e) || (this._dragging = !1);
        }
        function mousewheel(e) {
            var shouldZoom = isAvailableBehavior("zoomOnMouseWheel", e, this._opt), shouldMove = isAvailableBehavior("moveOnMouseWheel", e, this._opt), wheelDelta = e.wheelDelta, absWheelDeltaDelta = Math.abs(wheelDelta), originX = e.offsetX, originY = e.offsetY;
            if (0 !== wheelDelta && (shouldZoom || shouldMove)) {
                if (shouldZoom) {
                    var factor = absWheelDeltaDelta > 3 ? 1.4 : absWheelDeltaDelta > 1 ? 1.2 : 1.1;
                    checkPointerAndTrigger(this, "zoom", "zoomOnMouseWheel", e, {
                        scale: wheelDelta > 0 ? factor : 1 / factor,
                        originX: originX,
                        originY: originY
                    });
                }
                if (shouldMove) {
                    var absDelta = Math.abs(wheelDelta);
                    checkPointerAndTrigger(this, "scrollMove", "moveOnMouseWheel", e, {
                        scrollDelta: (wheelDelta > 0 ? 1 : -1) * (absDelta > 3 ? .4 : absDelta > 1 ? .15 : .05),
                        originX: originX,
                        originY: originY
                    });
                }
            }
        }
        function pinch(e) {
            interactionMutex.isTaken(this._zr, "globalPan") || checkPointerAndTrigger(this, "zoom", null, e, {
                scale: e.pinchScale > 1 ? 1.1 : 1 / 1.1,
                originX: e.pinchX,
                originY: e.pinchY
            });
        }
        function checkPointerAndTrigger(controller, eventName, behaviorToCheck, e, contollerEvent) {
            controller.pointerChecker && controller.pointerChecker(e, contollerEvent.originX, contollerEvent.originY) && (eventTool.stop(e.event), 
            trigger(controller, eventName, behaviorToCheck, e, contollerEvent));
        }
        function trigger(controller, eventName, behaviorToCheck, e, contollerEvent) {
            contollerEvent.isAvailableBehavior = zrUtil.bind(isAvailableBehavior, null, behaviorToCheck, e), 
            controller.trigger(eventName, contollerEvent);
        }
        function isAvailableBehavior(behaviorToCheck, e, settings) {
            var setting = settings[behaviorToCheck];
            return !behaviorToCheck || setting && (!zrUtil.isString(setting) || e.event[setting + "Key"]);
        }
        zrUtil.mixin(RoamController, Eventful);
        var _default = RoamController;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var ATTR = "\0_ec_interaction_mutex";
        function getStore(zr) {
            return zr[ATTR] || (zr[ATTR] = {});
        }
        __webpack_require__(1).registerAction({
            type: "takeGlobalCursor",
            event: "globalCursorTaken",
            update: "update"
        }, function() {}), exports.take = function(zr, resourceKey, userKey) {
            getStore(zr)[resourceKey] = userKey;
        }, exports.release = function(zr, resourceKey, userKey) {
            var store = getStore(zr);
            store[resourceKey] === userKey && (store[resourceKey] = null);
        }, exports.isTaken = function(zr, resourceKey) {
            return !!getStore(zr)[resourceKey];
        };
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(308), __webpack_require__(311);
    }, function(module, exports, __webpack_require__) {
        var echarts = __webpack_require__(1), preprocessor = __webpack_require__(142);
        __webpack_require__(143), __webpack_require__(144), __webpack_require__(309), __webpack_require__(310), 
        __webpack_require__(150), echarts.registerPreprocessor(preprocessor);
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), VisualMapModel = __webpack_require__(146), numberUtil = __webpack_require__(4), DEFAULT_BAR_BOUND = [ 20, 140 ], ContinuousModel = VisualMapModel.extend({
            type: "visualMap.continuous",
            defaultOption: {
                align: "auto",
                calculable: !1,
                range: null,
                realtime: !0,
                itemHeight: null,
                itemWidth: null,
                hoverLink: !0,
                hoverLinkDataSize: null,
                hoverLinkOnHandle: null
            },
            optionUpdated: function(newOption, isInit) {
                ContinuousModel.superApply(this, "optionUpdated", arguments), this.resetExtent(), 
                this.resetVisual(function(mappingOption) {
                    mappingOption.mappingMethod = "linear", mappingOption.dataExtent = this.getExtent();
                }), this._resetRange();
            },
            resetItemSize: function() {
                ContinuousModel.superApply(this, "resetItemSize", arguments);
                var itemSize = this.itemSize;
                "horizontal" === this._orient && itemSize.reverse(), (null == itemSize[0] || isNaN(itemSize[0])) && (itemSize[0] = DEFAULT_BAR_BOUND[0]), 
                (null == itemSize[1] || isNaN(itemSize[1])) && (itemSize[1] = DEFAULT_BAR_BOUND[1]);
            },
            _resetRange: function() {
                var dataExtent = this.getExtent(), range = this.option.range;
                !range || range.auto ? (dataExtent.auto = 1, this.option.range = dataExtent) : zrUtil.isArray(range) && (range[0] > range[1] && range.reverse(), 
                range[0] = Math.max(range[0], dataExtent[0]), range[1] = Math.min(range[1], dataExtent[1]));
            },
            completeVisualOption: function() {
                VisualMapModel.prototype.completeVisualOption.apply(this, arguments), zrUtil.each(this.stateList, function(state) {
                    var symbolSize = this.option.controller[state].symbolSize;
                    symbolSize && symbolSize[0] !== symbolSize[1] && (symbolSize[0] = 0);
                }, this);
            },
            setSelected: function(selected) {
                this.option.range = selected.slice(), this._resetRange();
            },
            getSelected: function() {
                var dataExtent = this.getExtent(), dataInterval = numberUtil.asc((this.get("range") || []).slice());
                return dataInterval[0] > dataExtent[1] && (dataInterval[0] = dataExtent[1]), dataInterval[1] > dataExtent[1] && (dataInterval[1] = dataExtent[1]), 
                dataInterval[0] < dataExtent[0] && (dataInterval[0] = dataExtent[0]), dataInterval[1] < dataExtent[0] && (dataInterval[1] = dataExtent[0]), 
                dataInterval;
            },
            getValueState: function(value) {
                var range = this.option.range, dataExtent = this.getExtent();
                return (range[0] <= dataExtent[0] || range[0] <= value) && (range[1] >= dataExtent[1] || value <= range[1]) ? "inRange" : "outOfRange";
            },
            findTargetDataIndices: function(range) {
                var result = [];
                return this.eachTargetSeries(function(seriesModel) {
                    var dataIndices = [], data = seriesModel.getData();
                    data.each(this.getDataDimension(data), function(value, dataIndex) {
                        range[0] <= value && value <= range[1] && dataIndices.push(dataIndex);
                    }, this), result.push({
                        seriesId: seriesModel.id,
                        dataIndex: dataIndices
                    });
                }, this), result;
            },
            getVisualMeta: function(getColorVisual) {
                var oVals = getColorStopValues(this, "outOfRange", this.getExtent()), iVals = getColorStopValues(this, "inRange", this.option.range.slice()), stops = [];
                function setStop(value, valueState) {
                    stops.push({
                        value: value,
                        color: getColorVisual(value, valueState)
                    });
                }
                for (var iIdx = 0, oIdx = 0, iLen = iVals.length, oLen = oVals.length; oIdx < oLen && (!iVals.length || oVals[oIdx] <= iVals[0]); oIdx++) oVals[oIdx] < iVals[iIdx] && setStop(oVals[oIdx], "outOfRange");
                for (var first = 1; iIdx < iLen; iIdx++, first = 0) first && stops.length && setStop(iVals[iIdx], "outOfRange"), 
                setStop(iVals[iIdx], "inRange");
                for (first = 1; oIdx < oLen; oIdx++) (!iVals.length || iVals[iVals.length - 1] < oVals[oIdx]) && (first && (stops.length && setStop(stops[stops.length - 1].value, "outOfRange"), 
                first = 0), setStop(oVals[oIdx], "outOfRange"));
                var stopsLen = stops.length;
                return {
                    stops: stops,
                    outerColors: [ stopsLen ? stops[0].color : "transparent", stopsLen ? stops[stopsLen - 1].color : "transparent" ]
                };
            }
        });
        function getColorStopValues(visualMapModel, valueState, dataExtent) {
            if (dataExtent[0] === dataExtent[1]) return dataExtent.slice();
            for (var step = (dataExtent[1] - dataExtent[0]) / 200, value = dataExtent[0], stopValues = [], i = 0; i <= 200 && value < dataExtent[1]; i++) stopValues.push(value), 
            value += step;
            return stopValues.push(dataExtent[1]), stopValues;
        }
        var _default = ContinuousModel;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), LinearGradient = __webpack_require__(60), eventTool = __webpack_require__(15), VisualMapView = __webpack_require__(148), graphic = __webpack_require__(2), numberUtil = __webpack_require__(4), sliderMove = __webpack_require__(47), helper = __webpack_require__(149), modelUtil = __webpack_require__(3), linearMap = numberUtil.linearMap, each = zrUtil.each, mathMin = Math.min, mathMax = Math.max, HOVER_LINK_SIZE = 12, HOVER_LINK_OUT = 6, ContinuousView = VisualMapView.extend({
            type: "visualMap.continuous",
            init: function() {
                ContinuousView.superApply(this, "init", arguments), this._shapes = {}, this._dataInterval = [], 
                this._handleEnds = [], this._orient, this._useHandle, this._hoverLinkDataIndices = [], 
                this._dragging, this._hovering;
            },
            doRender: function(visualMapModel, ecModel, api, payload) {
                payload && "selectDataRange" === payload.type && payload.from === this.uid || this._buildView();
            },
            _buildView: function() {
                this.group.removeAll();
                var visualMapModel = this.visualMapModel, thisGroup = this.group;
                this._orient = visualMapModel.get("orient"), this._useHandle = visualMapModel.get("calculable"), 
                this._resetInterval(), this._renderBar(thisGroup);
                var dataRangeText = visualMapModel.get("text");
                this._renderEndsText(thisGroup, dataRangeText, 0), this._renderEndsText(thisGroup, dataRangeText, 1), 
                this._updateView(!0), this.renderBackground(thisGroup), this._updateView(), this._enableHoverLinkToSeries(), 
                this._enableHoverLinkFromSeries(), this.positionGroup(thisGroup);
            },
            _renderEndsText: function(group, dataRangeText, endsIndex) {
                if (dataRangeText) {
                    var text = dataRangeText[1 - endsIndex];
                    text = null != text ? text + "" : "";
                    var visualMapModel = this.visualMapModel, textGap = visualMapModel.get("textGap"), itemSize = visualMapModel.itemSize, barGroup = this._shapes.barGroup, position = this._applyTransform([ itemSize[0] / 2, 0 === endsIndex ? -textGap : itemSize[1] + textGap ], barGroup), align = this._applyTransform(0 === endsIndex ? "bottom" : "top", barGroup), orient = this._orient, textStyleModel = this.visualMapModel.textStyleModel;
                    this.group.add(new graphic.Text({
                        style: {
                            x: position[0],
                            y: position[1],
                            textVerticalAlign: "horizontal" === orient ? "middle" : align,
                            textAlign: "horizontal" === orient ? align : "center",
                            text: text,
                            textFont: textStyleModel.getFont(),
                            textFill: textStyleModel.getTextColor()
                        }
                    }));
                }
            },
            _renderBar: function(targetGroup) {
                var visualMapModel = this.visualMapModel, shapes = this._shapes, itemSize = visualMapModel.itemSize, orient = this._orient, useHandle = this._useHandle, itemAlign = helper.getItemAlign(visualMapModel, this.api, itemSize), barGroup = shapes.barGroup = this._createBarGroup(itemAlign);
                barGroup.add(shapes.outOfRange = createPolygon()), barGroup.add(shapes.inRange = createPolygon(null, useHandle ? getCursor(this._orient) : null, zrUtil.bind(this._dragHandle, this, "all", !1), zrUtil.bind(this._dragHandle, this, "all", !0)));
                var textRect = visualMapModel.textStyleModel.getTextRect("国"), textSize = mathMax(textRect.width, textRect.height);
                useHandle && (shapes.handleThumbs = [], shapes.handleLabels = [], shapes.handleLabelPoints = [], 
                this._createHandle(barGroup, 0, itemSize, textSize, orient, itemAlign), this._createHandle(barGroup, 1, itemSize, textSize, orient, itemAlign)), 
                this._createIndicator(barGroup, itemSize, textSize, orient), targetGroup.add(barGroup);
            },
            _createHandle: function(barGroup, handleIndex, itemSize, textSize, orient) {
                var onDrift = zrUtil.bind(this._dragHandle, this, handleIndex, !1), onDragEnd = zrUtil.bind(this._dragHandle, this, handleIndex, !0), handleThumb = createPolygon(function(handleIndex, textSize) {
                    return 0 === handleIndex ? [ [ 0, 0 ], [ textSize, 0 ], [ textSize, -textSize ] ] : [ [ 0, 0 ], [ textSize, 0 ], [ textSize, textSize ] ];
                }(handleIndex, textSize), getCursor(this._orient), onDrift, onDragEnd);
                handleThumb.position[0] = itemSize[0], barGroup.add(handleThumb);
                var textStyleModel = this.visualMapModel.textStyleModel, handleLabel = new graphic.Text({
                    draggable: !0,
                    drift: onDrift,
                    onmousemove: function(e) {
                        eventTool.stop(e.event);
                    },
                    ondragend: onDragEnd,
                    style: {
                        x: 0,
                        y: 0,
                        text: "",
                        textFont: textStyleModel.getFont(),
                        textFill: textStyleModel.getTextColor()
                    }
                });
                this.group.add(handleLabel);
                var handleLabelPoint = [ "horizontal" === orient ? textSize / 2 : 1.5 * textSize, "horizontal" === orient ? 0 === handleIndex ? -1.5 * textSize : 1.5 * textSize : 0 === handleIndex ? -textSize / 2 : textSize / 2 ], shapes = this._shapes;
                shapes.handleThumbs[handleIndex] = handleThumb, shapes.handleLabelPoints[handleIndex] = handleLabelPoint, 
                shapes.handleLabels[handleIndex] = handleLabel;
            },
            _createIndicator: function(barGroup, itemSize, textSize, orient) {
                var indicator = createPolygon([ [ 0, 0 ] ], "move");
                indicator.position[0] = itemSize[0], indicator.attr({
                    invisible: !0,
                    silent: !0
                }), barGroup.add(indicator);
                var textStyleModel = this.visualMapModel.textStyleModel, indicatorLabel = new graphic.Text({
                    silent: !0,
                    invisible: !0,
                    style: {
                        x: 0,
                        y: 0,
                        text: "",
                        textFont: textStyleModel.getFont(),
                        textFill: textStyleModel.getTextColor()
                    }
                });
                this.group.add(indicatorLabel);
                var indicatorLabelPoint = [ "horizontal" === orient ? textSize / 2 : HOVER_LINK_OUT + 3, 0 ], shapes = this._shapes;
                shapes.indicator = indicator, shapes.indicatorLabel = indicatorLabel, shapes.indicatorLabelPoint = indicatorLabelPoint;
            },
            _dragHandle: function(handleIndex, isEnd, dx, dy) {
                if (this._useHandle) {
                    if (this._dragging = !isEnd, !isEnd) {
                        var vertex = this._applyTransform([ dx, dy ], this._shapes.barGroup, !0);
                        this._updateInterval(handleIndex, vertex[1]), this._updateView();
                    }
                    isEnd === !this.visualMapModel.get("realtime") && this.api.dispatchAction({
                        type: "selectDataRange",
                        from: this.uid,
                        visualMapId: this.visualMapModel.id,
                        selected: this._dataInterval.slice()
                    }), isEnd ? !this._hovering && this._clearHoverLinkToSeries() : useHoverLinkOnHandle(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[handleIndex], !1);
                }
            },
            _resetInterval: function() {
                var visualMapModel = this.visualMapModel, dataInterval = this._dataInterval = visualMapModel.getSelected(), dataExtent = visualMapModel.getExtent(), sizeExtent = [ 0, visualMapModel.itemSize[1] ];
                this._handleEnds = [ linearMap(dataInterval[0], dataExtent, sizeExtent, !0), linearMap(dataInterval[1], dataExtent, sizeExtent, !0) ];
            },
            _updateInterval: function(handleIndex, delta) {
                delta = delta || 0;
                var visualMapModel = this.visualMapModel, handleEnds = this._handleEnds, sizeExtent = [ 0, visualMapModel.itemSize[1] ];
                sliderMove(delta, handleEnds, sizeExtent, handleIndex, 0);
                var dataExtent = visualMapModel.getExtent();
                this._dataInterval = [ linearMap(handleEnds[0], sizeExtent, dataExtent, !0), linearMap(handleEnds[1], sizeExtent, dataExtent, !0) ];
            },
            _updateView: function(forSketch) {
                var visualMapModel = this.visualMapModel, dataExtent = visualMapModel.getExtent(), shapes = this._shapes, outOfRangeHandleEnds = [ 0, visualMapModel.itemSize[1] ], inRangeHandleEnds = forSketch ? outOfRangeHandleEnds : this._handleEnds, visualInRange = this._createBarVisual(this._dataInterval, dataExtent, inRangeHandleEnds, "inRange"), visualOutOfRange = this._createBarVisual(dataExtent, dataExtent, outOfRangeHandleEnds, "outOfRange");
                shapes.inRange.setStyle({
                    fill: visualInRange.barColor,
                    opacity: visualInRange.opacity
                }).setShape("points", visualInRange.barPoints), shapes.outOfRange.setStyle({
                    fill: visualOutOfRange.barColor,
                    opacity: visualOutOfRange.opacity
                }).setShape("points", visualOutOfRange.barPoints), this._updateHandle(inRangeHandleEnds, visualInRange);
            },
            _createBarVisual: function(dataInterval, dataExtent, handleEnds, forceState) {
                var opts = {
                    forceState: forceState,
                    convertOpacityToAlpha: !0
                }, colorStops = this._makeColorGradient(dataInterval, opts), symbolSizes = [ this.getControllerVisual(dataInterval[0], "symbolSize", opts), this.getControllerVisual(dataInterval[1], "symbolSize", opts) ], barPoints = this._createBarPoints(handleEnds, symbolSizes);
                return {
                    barColor: new LinearGradient(0, 0, 0, 1, colorStops),
                    barPoints: barPoints,
                    handlesColor: [ colorStops[0].color, colorStops[colorStops.length - 1].color ]
                };
            },
            _makeColorGradient: function(dataInterval, opts) {
                var colorStops = [], step = (dataInterval[1] - dataInterval[0]) / 100;
                colorStops.push({
                    color: this.getControllerVisual(dataInterval[0], "color", opts),
                    offset: 0
                });
                for (var i = 1; i < 100; i++) {
                    var currValue = dataInterval[0] + step * i;
                    if (currValue > dataInterval[1]) break;
                    colorStops.push({
                        color: this.getControllerVisual(currValue, "color", opts),
                        offset: i / 100
                    });
                }
                return colorStops.push({
                    color: this.getControllerVisual(dataInterval[1], "color", opts),
                    offset: 1
                }), colorStops;
            },
            _createBarPoints: function(handleEnds, symbolSizes) {
                var itemSize = this.visualMapModel.itemSize;
                return [ [ itemSize[0] - symbolSizes[0], handleEnds[0] ], [ itemSize[0], handleEnds[0] ], [ itemSize[0], handleEnds[1] ], [ itemSize[0] - symbolSizes[1], handleEnds[1] ] ];
            },
            _createBarGroup: function(itemAlign) {
                var orient = this._orient, inverse = this.visualMapModel.get("inverse");
                return new graphic.Group("horizontal" !== orient || inverse ? "horizontal" === orient && inverse ? {
                    scale: "bottom" === itemAlign ? [ -1, 1 ] : [ 1, 1 ],
                    rotation: -Math.PI / 2
                } : "vertical" !== orient || inverse ? {
                    scale: "left" === itemAlign ? [ 1, 1 ] : [ -1, 1 ]
                } : {
                    scale: "left" === itemAlign ? [ 1, -1 ] : [ -1, -1 ]
                } : {
                    scale: "bottom" === itemAlign ? [ 1, 1 ] : [ -1, 1 ],
                    rotation: Math.PI / 2
                });
            },
            _updateHandle: function(handleEnds, visualInRange) {
                if (this._useHandle) {
                    var shapes = this._shapes, visualMapModel = this.visualMapModel, handleThumbs = shapes.handleThumbs, handleLabels = shapes.handleLabels;
                    each([ 0, 1 ], function(handleIndex) {
                        var handleThumb = handleThumbs[handleIndex];
                        handleThumb.setStyle("fill", visualInRange.handlesColor[handleIndex]), handleThumb.position[1] = handleEnds[handleIndex];
                        var textPoint = graphic.applyTransform(shapes.handleLabelPoints[handleIndex], graphic.getTransform(handleThumb, this.group));
                        handleLabels[handleIndex].setStyle({
                            x: textPoint[0],
                            y: textPoint[1],
                            text: visualMapModel.formatValueText(this._dataInterval[handleIndex]),
                            textVerticalAlign: "middle",
                            textAlign: this._applyTransform("horizontal" === this._orient ? 0 === handleIndex ? "bottom" : "top" : "left", shapes.barGroup)
                        });
                    }, this);
                }
            },
            _showIndicator: function(cursorValue, textValue, rangeSymbol, halfHoverLinkSize) {
                var visualMapModel = this.visualMapModel, dataExtent = visualMapModel.getExtent(), itemSize = visualMapModel.itemSize, sizeExtent = [ 0, itemSize[1] ], pos = linearMap(cursorValue, dataExtent, sizeExtent, !0), shapes = this._shapes, indicator = shapes.indicator;
                if (indicator) {
                    indicator.position[1] = pos, indicator.attr("invisible", !1), indicator.setShape("points", function(isRange, halfHoverLinkSize, pos, extentMax) {
                        return isRange ? [ [ 0, -mathMin(halfHoverLinkSize, mathMax(pos, 0)) ], [ HOVER_LINK_OUT, 0 ], [ 0, mathMin(halfHoverLinkSize, mathMax(extentMax - pos, 0)) ] ] : [ [ 0, 0 ], [ 5, -5 ], [ 5, 5 ] ];
                    }(!!rangeSymbol, halfHoverLinkSize, pos, itemSize[1]));
                    var color = this.getControllerVisual(cursorValue, "color", {
                        convertOpacityToAlpha: !0
                    });
                    indicator.setStyle("fill", color);
                    var textPoint = graphic.applyTransform(shapes.indicatorLabelPoint, graphic.getTransform(indicator, this.group)), indicatorLabel = shapes.indicatorLabel;
                    indicatorLabel.attr("invisible", !1);
                    var align = this._applyTransform("left", shapes.barGroup), orient = this._orient;
                    indicatorLabel.setStyle({
                        text: (rangeSymbol || "") + visualMapModel.formatValueText(textValue),
                        textVerticalAlign: "horizontal" === orient ? align : "middle",
                        textAlign: "horizontal" === orient ? "center" : align,
                        x: textPoint[0],
                        y: textPoint[1]
                    });
                }
            },
            _enableHoverLinkToSeries: function() {
                var self = this;
                this._shapes.barGroup.on("mousemove", function(e) {
                    if (self._hovering = !0, !self._dragging) {
                        var itemSize = self.visualMapModel.itemSize, pos = self._applyTransform([ e.offsetX, e.offsetY ], self._shapes.barGroup, !0, !0);
                        pos[1] = mathMin(mathMax(0, pos[1]), itemSize[1]), self._doHoverLinkToSeries(pos[1], 0 <= pos[0] && pos[0] <= itemSize[0]);
                    }
                }).on("mouseout", function() {
                    self._hovering = !1, !self._dragging && self._clearHoverLinkToSeries();
                });
            },
            _enableHoverLinkFromSeries: function() {
                var zr = this.api.getZr();
                this.visualMapModel.option.hoverLink ? (zr.on("mouseover", this._hoverLinkFromSeriesMouseOver, this), 
                zr.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries();
            },
            _doHoverLinkToSeries: function(cursorPos, hoverOnBar) {
                var visualMapModel = this.visualMapModel, itemSize = visualMapModel.itemSize;
                if (visualMapModel.option.hoverLink) {
                    var sizeExtent = [ 0, itemSize[1] ], dataExtent = visualMapModel.getExtent();
                    cursorPos = mathMin(mathMax(sizeExtent[0], cursorPos), sizeExtent[1]);
                    var halfHoverLinkSize = function(visualMapModel, dataExtent, sizeExtent) {
                        var halfHoverLinkSize = HOVER_LINK_SIZE / 2, hoverLinkDataSize = visualMapModel.get("hoverLinkDataSize");
                        hoverLinkDataSize && (halfHoverLinkSize = linearMap(hoverLinkDataSize, dataExtent, sizeExtent, !0) / 2);
                        return halfHoverLinkSize;
                    }(visualMapModel, dataExtent, sizeExtent), hoverRange = [ cursorPos - halfHoverLinkSize, cursorPos + halfHoverLinkSize ], cursorValue = linearMap(cursorPos, sizeExtent, dataExtent, !0), valueRange = [ linearMap(hoverRange[0], sizeExtent, dataExtent, !0), linearMap(hoverRange[1], sizeExtent, dataExtent, !0) ];
                    hoverRange[0] < sizeExtent[0] && (valueRange[0] = -1 / 0), hoverRange[1] > sizeExtent[1] && (valueRange[1] = 1 / 0), 
                    hoverOnBar && (valueRange[0] === -1 / 0 ? this._showIndicator(cursorValue, valueRange[1], "< ", halfHoverLinkSize) : valueRange[1] === 1 / 0 ? this._showIndicator(cursorValue, valueRange[0], "> ", halfHoverLinkSize) : this._showIndicator(cursorValue, cursorValue, "≈ ", halfHoverLinkSize));
                    var oldBatch = this._hoverLinkDataIndices, newBatch = [];
                    (hoverOnBar || useHoverLinkOnHandle(visualMapModel)) && (newBatch = this._hoverLinkDataIndices = visualMapModel.findTargetDataIndices(valueRange));
                    var resultBatches = modelUtil.compressBatches(oldBatch, newBatch);
                    this._dispatchHighDown("downplay", helper.makeHighDownBatch(resultBatches[0], visualMapModel)), 
                    this._dispatchHighDown("highlight", helper.makeHighDownBatch(resultBatches[1], visualMapModel));
                }
            },
            _hoverLinkFromSeriesMouseOver: function(e) {
                var el = e.target, visualMapModel = this.visualMapModel;
                if (el && null != el.dataIndex) {
                    var dataModel = this.ecModel.getSeriesByIndex(el.seriesIndex);
                    if (visualMapModel.isTargetSeries(dataModel)) {
                        var data = dataModel.getData(el.dataType), value = data.get(visualMapModel.getDataDimension(data), el.dataIndex, !0);
                        isNaN(value) || this._showIndicator(value, value);
                    }
                }
            },
            _hideIndicator: function() {
                var shapes = this._shapes;
                shapes.indicator && shapes.indicator.attr("invisible", !0), shapes.indicatorLabel && shapes.indicatorLabel.attr("invisible", !0);
            },
            _clearHoverLinkToSeries: function() {
                this._hideIndicator();
                var indices = this._hoverLinkDataIndices;
                this._dispatchHighDown("downplay", helper.makeHighDownBatch(indices, this.visualMapModel)), 
                indices.length = 0;
            },
            _clearHoverLinkFromSeries: function() {
                this._hideIndicator();
                var zr = this.api.getZr();
                zr.off("mouseover", this._hoverLinkFromSeriesMouseOver), zr.off("mouseout", this._hideIndicator);
            },
            _applyTransform: function(vertex, element, inverse, global) {
                var transform = graphic.getTransform(element, global ? null : this.group);
                return graphic[zrUtil.isArray(vertex) ? "applyTransform" : "transformDirection"](vertex, transform, inverse);
            },
            _dispatchHighDown: function(type, batch) {
                batch && batch.length && this.api.dispatchAction({
                    type: type,
                    batch: batch
                });
            },
            dispose: function() {
                this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
            },
            remove: function() {
                this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
            }
        });
        function createPolygon(points, cursor, onDrift, onDragEnd) {
            return new graphic.Polygon({
                shape: {
                    points: points
                },
                draggable: !!onDrift,
                cursor: cursor,
                drift: onDrift,
                onmousemove: function(e) {
                    eventTool.stop(e.event);
                },
                ondragend: onDragEnd
            });
        }
        function useHoverLinkOnHandle(visualMapModel) {
            var hoverLinkOnHandle = visualMapModel.get("hoverLinkOnHandle");
            return !!(null == hoverLinkOnHandle ? visualMapModel.get("realtime") : hoverLinkOnHandle);
        }
        function getCursor(orient) {
            return "vertical" === orient ? "ns-resize" : "ew-resize";
        }
        var _default = ContinuousView;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var echarts = __webpack_require__(1), preprocessor = __webpack_require__(142);
        __webpack_require__(143), __webpack_require__(144), __webpack_require__(312), __webpack_require__(313), 
        __webpack_require__(150), echarts.registerPreprocessor(preprocessor);
    }, function(module, exports, __webpack_require__) {
        __webpack_require__(5).__DEV__;
        var zrUtil = __webpack_require__(0), VisualMapModel = __webpack_require__(146), VisualMapping = __webpack_require__(34), visualDefault = __webpack_require__(147), reformIntervals = __webpack_require__(4).reformIntervals, PiecewiseModel = VisualMapModel.extend({
            type: "visualMap.piecewise",
            defaultOption: {
                selected: null,
                minOpen: !1,
                maxOpen: !1,
                align: "auto",
                itemWidth: 20,
                itemHeight: 14,
                itemSymbol: "roundRect",
                pieceList: null,
                categories: null,
                splitNumber: 5,
                selectedMode: "multiple",
                itemGap: 10,
                hoverLink: !0,
                showLabel: null
            },
            optionUpdated: function(newOption, isInit) {
                PiecewiseModel.superApply(this, "optionUpdated", arguments), this._pieceList = [], 
                this.resetExtent();
                var mode = this._mode = this._determineMode();
                resetMethods[this._mode].call(this), this._resetSelected(newOption, isInit);
                var categories = this.option.categories;
                this.resetVisual(function(mappingOption, state) {
                    "categories" === mode ? (mappingOption.mappingMethod = "category", mappingOption.categories = zrUtil.clone(categories)) : (mappingOption.dataExtent = this.getExtent(), 
                    mappingOption.mappingMethod = "piecewise", mappingOption.pieceList = zrUtil.map(this._pieceList, function(piece) {
                        piece = zrUtil.clone(piece);
                        return "inRange" !== state && (piece.visual = null), piece;
                    }));
                });
            },
            completeVisualOption: function() {
                var option = this.option, visualTypesInPieces = {}, visualTypes = VisualMapping.listVisualTypes(), isCategory = this.isCategory();
                function has(obj, state, visualType) {
                    return obj && obj[state] && (zrUtil.isObject(obj[state]) ? obj[state].hasOwnProperty(visualType) : obj[state] === visualType);
                }
                zrUtil.each(option.pieces, function(piece) {
                    zrUtil.each(visualTypes, function(visualType) {
                        piece.hasOwnProperty(visualType) && (visualTypesInPieces[visualType] = 1);
                    });
                }), zrUtil.each(visualTypesInPieces, function(v, visualType) {
                    var exists = 0;
                    zrUtil.each(this.stateList, function(state) {
                        exists |= has(option, state, visualType) || has(option.target, state, visualType);
                    }, this), !exists && zrUtil.each(this.stateList, function(state) {
                        (option[state] || (option[state] = {}))[visualType] = visualDefault.get(visualType, "inRange" === state ? "active" : "inactive", isCategory);
                    });
                }, this), VisualMapModel.prototype.completeVisualOption.apply(this, arguments);
            },
            _resetSelected: function(newOption, isInit) {
                var thisOption = this.option, pieceList = this._pieceList, selected = (isInit ? thisOption : newOption).selected || {};
                if (thisOption.selected = selected, zrUtil.each(pieceList, function(piece, index) {
                    var key = this.getSelectedMapKey(piece);
                    selected.hasOwnProperty(key) || (selected[key] = !0);
                }, this), "single" === thisOption.selectedMode) {
                    var hasSel = !1;
                    zrUtil.each(pieceList, function(piece, index) {
                        var key = this.getSelectedMapKey(piece);
                        selected[key] && (hasSel ? selected[key] = !1 : hasSel = !0);
                    }, this);
                }
            },
            getSelectedMapKey: function(piece) {
                return "categories" === this._mode ? piece.value + "" : piece.index + "";
            },
            getPieceList: function() {
                return this._pieceList;
            },
            _determineMode: function() {
                var option = this.option;
                return option.pieces && option.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
            },
            setSelected: function(selected) {
                this.option.selected = zrUtil.clone(selected);
            },
            getValueState: function(value) {
                var index = VisualMapping.findPieceIndex(value, this._pieceList);
                return null != index && this.option.selected[this.getSelectedMapKey(this._pieceList[index])] ? "inRange" : "outOfRange";
            },
            findTargetDataIndices: function(pieceIndex) {
                var result = [];
                return this.eachTargetSeries(function(seriesModel) {
                    var dataIndices = [], data = seriesModel.getData();
                    data.each(this.getDataDimension(data), function(value, dataIndex) {
                        VisualMapping.findPieceIndex(value, this._pieceList) === pieceIndex && dataIndices.push(dataIndex);
                    }, this), result.push({
                        seriesId: seriesModel.id,
                        dataIndex: dataIndices
                    });
                }, this), result;
            },
            getRepresentValue: function(piece) {
                var representValue;
                if (this.isCategory()) representValue = piece.value; else if (null != piece.value) representValue = piece.value; else {
                    var pieceInterval = piece.interval || [];
                    representValue = pieceInterval[0] === -1 / 0 && pieceInterval[1] === 1 / 0 ? 0 : (pieceInterval[0] + pieceInterval[1]) / 2;
                }
                return representValue;
            },
            getVisualMeta: function(getColorVisual) {
                if (!this.isCategory()) {
                    var stops = [], outerColors = [], visualMapModel = this, pieceList = this._pieceList.slice();
                    if (pieceList.length) {
                        var edge = pieceList[0].interval[0];
                        edge !== -1 / 0 && pieceList.unshift({
                            interval: [ -1 / 0, edge ]
                        }), (edge = pieceList[pieceList.length - 1].interval[1]) !== 1 / 0 && pieceList.push({
                            interval: [ edge, 1 / 0 ]
                        });
                    } else pieceList.push({
                        interval: [ -1 / 0, 1 / 0 ]
                    });
                    var curr = -1 / 0;
                    return zrUtil.each(pieceList, function(piece) {
                        var interval = piece.interval;
                        interval && (interval[0] > curr && setStop([ curr, interval[0] ], "outOfRange"), 
                        setStop(interval.slice()), curr = interval[1]);
                    }, this), {
                        stops: stops,
                        outerColors: outerColors
                    };
                }
                function setStop(interval, valueState) {
                    var representValue = visualMapModel.getRepresentValue({
                        interval: interval
                    });
                    valueState || (valueState = visualMapModel.getValueState(representValue));
                    var color = getColorVisual(representValue, valueState);
                    interval[0] === -1 / 0 ? outerColors[0] = color : interval[1] === 1 / 0 ? outerColors[1] = color : stops.push({
                        value: interval[0],
                        color: color
                    }, {
                        value: interval[1],
                        color: color
                    });
                }
            }
        }), resetMethods = {
            splitNumber: function() {
                var thisOption = this.option, pieceList = this._pieceList, precision = Math.min(thisOption.precision, 20), dataExtent = this.getExtent(), splitNumber = thisOption.splitNumber;
                splitNumber = Math.max(parseInt(splitNumber, 10), 1), thisOption.splitNumber = splitNumber;
                for (var splitStep = (dataExtent[1] - dataExtent[0]) / splitNumber; +splitStep.toFixed(precision) !== splitStep && precision < 5; ) precision++;
                thisOption.precision = precision, splitStep = +splitStep.toFixed(precision);
                var index = 0;
                thisOption.minOpen && pieceList.push({
                    index: index++,
                    interval: [ -1 / 0, dataExtent[0] ],
                    close: [ 0, 0 ]
                });
                for (var curr = dataExtent[0], len = index + splitNumber; index < len; curr += splitStep) {
                    var max = index === splitNumber - 1 ? dataExtent[1] : curr + splitStep;
                    pieceList.push({
                        index: index++,
                        interval: [ curr, max ],
                        close: [ 1, 1 ]
                    });
                }
                thisOption.maxOpen && pieceList.push({
                    index: index++,
                    interval: [ dataExtent[1], 1 / 0 ],
                    close: [ 0, 0 ]
                }), reformIntervals(pieceList), zrUtil.each(pieceList, function(piece) {
                    piece.text = this.formatValueText(piece.interval);
                }, this);
            },
            categories: function() {
                var thisOption = this.option;
                zrUtil.each(thisOption.categories, function(cate) {
                    this._pieceList.push({
                        text: this.formatValueText(cate, !0),
                        value: cate
                    });
                }, this), normalizeReverse(thisOption, this._pieceList);
            },
            pieces: function() {
                var thisOption = this.option, pieceList = this._pieceList;
                zrUtil.each(thisOption.pieces, function(pieceListItem, index) {
                    zrUtil.isObject(pieceListItem) || (pieceListItem = {
                        value: pieceListItem
                    });
                    var item = {
                        text: "",
                        index: index
                    };
                    if (null != pieceListItem.label && (item.text = pieceListItem.label), pieceListItem.hasOwnProperty("value")) {
                        var value = item.value = pieceListItem.value;
                        item.interval = [ value, value ], item.close = [ 1, 1 ];
                    } else {
                        for (var interval = item.interval = [], close = item.close = [ 0, 0 ], closeList = [ 1, 0, 1 ], infinityList = [ -1 / 0, 1 / 0 ], useMinMax = [], lg = 0; lg < 2; lg++) {
                            for (var names = [ [ "gte", "gt", "min" ], [ "lte", "lt", "max" ] ][lg], i = 0; i < 3 && null == interval[lg]; i++) interval[lg] = pieceListItem[names[i]], 
                            close[lg] = closeList[i], useMinMax[lg] = 2 === i;
                            null == interval[lg] && (interval[lg] = infinityList[lg]);
                        }
                        useMinMax[0] && interval[1] === 1 / 0 && (close[0] = 0), useMinMax[1] && interval[0] === -1 / 0 && (close[1] = 0), 
                        interval[0] === interval[1] && close[0] && close[1] && (item.value = interval[0]);
                    }
                    item.visual = VisualMapping.retrieveVisuals(pieceListItem), pieceList.push(item);
                }, this), normalizeReverse(thisOption, pieceList), reformIntervals(pieceList), zrUtil.each(pieceList, function(piece) {
                    var close = piece.close, edgeSymbols = [ [ "<", "≤" ][close[1]], [ ">", "≥" ][close[0]] ];
                    piece.text = piece.text || this.formatValueText(null != piece.value ? piece.value : piece.interval, !1, edgeSymbols);
                }, this);
            }
        };
        function normalizeReverse(thisOption, pieceList) {
            var inverse = thisOption.inverse;
            ("vertical" === thisOption.orient ? !inverse : inverse) && pieceList.reverse();
        }
        var _default = PiecewiseModel;
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), VisualMapView = __webpack_require__(148), graphic = __webpack_require__(2), createSymbol = __webpack_require__(16).createSymbol, layout = __webpack_require__(10), helper = __webpack_require__(149), _default = VisualMapView.extend({
            type: "visualMap.piecewise",
            doRender: function() {
                var thisGroup = this.group;
                thisGroup.removeAll();
                var visualMapModel = this.visualMapModel, textGap = visualMapModel.get("textGap"), textStyleModel = visualMapModel.textStyleModel, textFont = textStyleModel.getFont(), textFill = textStyleModel.getTextColor(), itemAlign = this._getItemAlign(), itemSize = visualMapModel.itemSize, viewData = this._getViewData(), endsText = viewData.endsText, showLabel = zrUtil.retrieve(visualMapModel.get("showLabel", !0), !endsText);
                endsText && this._renderEndsText(thisGroup, endsText[0], itemSize, showLabel, itemAlign), 
                zrUtil.each(viewData.viewPieceList, function(item) {
                    var piece = item.piece, itemGroup = new graphic.Group();
                    itemGroup.onclick = zrUtil.bind(this._onItemClick, this, piece), this._enableHoverLink(itemGroup, item.indexInModelPieceList);
                    var representValue = visualMapModel.getRepresentValue(piece);
                    if (this._createItemSymbol(itemGroup, representValue, [ 0, 0, itemSize[0], itemSize[1] ]), 
                    showLabel) {
                        var visualState = this.visualMapModel.getValueState(representValue);
                        itemGroup.add(new graphic.Text({
                            style: {
                                x: "right" === itemAlign ? -textGap : itemSize[0] + textGap,
                                y: itemSize[1] / 2,
                                text: piece.text,
                                textVerticalAlign: "middle",
                                textAlign: itemAlign,
                                textFont: textFont,
                                textFill: textFill,
                                opacity: "outOfRange" === visualState ? .5 : 1
                            }
                        }));
                    }
                    thisGroup.add(itemGroup);
                }, this), endsText && this._renderEndsText(thisGroup, endsText[1], itemSize, showLabel, itemAlign), 
                layout.box(visualMapModel.get("orient"), thisGroup, visualMapModel.get("itemGap")), 
                this.renderBackground(thisGroup), this.positionGroup(thisGroup);
            },
            _enableHoverLink: function(itemGroup, pieceIndex) {
                function onHoverLink(method) {
                    var visualMapModel = this.visualMapModel;
                    visualMapModel.option.hoverLink && this.api.dispatchAction({
                        type: method,
                        batch: helper.makeHighDownBatch(visualMapModel.findTargetDataIndices(pieceIndex), visualMapModel)
                    });
                }
                itemGroup.on("mouseover", zrUtil.bind(onHoverLink, this, "highlight")).on("mouseout", zrUtil.bind(onHoverLink, this, "downplay"));
            },
            _getItemAlign: function() {
                var visualMapModel = this.visualMapModel, modelOption = visualMapModel.option;
                if ("vertical" === modelOption.orient) return helper.getItemAlign(visualMapModel, this.api, visualMapModel.itemSize);
                var align = modelOption.align;
                return align && "auto" !== align || (align = "left"), align;
            },
            _renderEndsText: function(group, text, itemSize, showLabel, itemAlign) {
                if (text) {
                    var itemGroup = new graphic.Group(), textStyleModel = this.visualMapModel.textStyleModel;
                    itemGroup.add(new graphic.Text({
                        style: {
                            x: showLabel ? "right" === itemAlign ? itemSize[0] : 0 : itemSize[0] / 2,
                            y: itemSize[1] / 2,
                            textVerticalAlign: "middle",
                            textAlign: showLabel ? itemAlign : "center",
                            text: text,
                            textFont: textStyleModel.getFont(),
                            textFill: textStyleModel.getTextColor()
                        }
                    })), group.add(itemGroup);
                }
            },
            _getViewData: function() {
                var visualMapModel = this.visualMapModel, viewPieceList = zrUtil.map(visualMapModel.getPieceList(), function(piece, index) {
                    return {
                        piece: piece,
                        indexInModelPieceList: index
                    };
                }), endsText = visualMapModel.get("text"), orient = visualMapModel.get("orient"), inverse = visualMapModel.get("inverse");
                return ("horizontal" === orient ? inverse : !inverse) ? viewPieceList.reverse() : endsText && (endsText = endsText.slice().reverse()), 
                {
                    viewPieceList: viewPieceList,
                    endsText: endsText
                };
            },
            _createItemSymbol: function(group, representValue, shapeParam) {
                group.add(createSymbol(this.getControllerVisual(representValue, "symbol"), shapeParam[0], shapeParam[1], shapeParam[2], shapeParam[3], this.getControllerVisual(representValue, "color")));
            },
            _onItemClick: function(piece) {
                var visualMapModel = this.visualMapModel, option = visualMapModel.option, selected = zrUtil.clone(option.selected), newKey = visualMapModel.getSelectedMapKey(piece);
                "single" === option.selectedMode ? (selected[newKey] = !0, zrUtil.each(selected, function(o, key) {
                    selected[key] = key === newKey;
                })) : selected[newKey] = !selected[newKey], this.api.dispatchAction({
                    type: "selectDataRange",
                    from: this.uid,
                    visualMapId: this.visualMapModel.id,
                    selected: selected
                });
            }
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var echarts = __webpack_require__(1);
        __webpack_require__(315), __webpack_require__(316), echarts.registerPreprocessor(function(opt) {
            opt.markPoint = opt.markPoint || {};
        });
    }, function(module, exports, __webpack_require__) {
        var _default = __webpack_require__(73).extend({
            type: "markPoint",
            defaultOption: {
                zlevel: 0,
                z: 5,
                symbol: "pin",
                symbolSize: 50,
                tooltip: {
                    trigger: "item"
                },
                label: {
                    show: !0,
                    position: "inside"
                },
                itemStyle: {
                    borderWidth: 2
                },
                emphasis: {
                    label: {
                        show: !0
                    }
                }
            }
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), SymbolDraw = __webpack_require__(44), numberUtil = __webpack_require__(4), List = __webpack_require__(25), markerHelper = __webpack_require__(74);
        function updateMarkerLayout(mpData, seriesModel, api) {
            var coordSys = seriesModel.coordinateSystem;
            mpData.each(function(idx) {
                var point, itemModel = mpData.getItemModel(idx), xPx = numberUtil.parsePercent(itemModel.get("x"), api.getWidth()), yPx = numberUtil.parsePercent(itemModel.get("y"), api.getHeight());
                if (isNaN(xPx) || isNaN(yPx)) {
                    if (seriesModel.getMarkerPosition) point = seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions, idx)); else if (coordSys) {
                        var x = mpData.get(coordSys.dimensions[0], idx), y = mpData.get(coordSys.dimensions[1], idx);
                        point = coordSys.dataToPoint([ x, y ]);
                    }
                } else point = [ xPx, yPx ];
                isNaN(xPx) || (point[0] = xPx), isNaN(yPx) || (point[1] = yPx), mpData.setItemLayout(idx, point);
            });
        }
        var _default = __webpack_require__(75).extend({
            type: "markPoint",
            updateTransform: function(markPointModel, ecModel, api) {
                ecModel.eachSeries(function(seriesModel) {
                    var mpModel = seriesModel.markPointModel;
                    mpModel && (updateMarkerLayout(mpModel.getData(), seriesModel, api), this.markerGroupMap.get(seriesModel.id).updateLayout(mpModel));
                }, this);
            },
            renderSeries: function(seriesModel, mpModel, ecModel, api) {
                var coordSys = seriesModel.coordinateSystem, seriesId = seriesModel.id, seriesData = seriesModel.getData(), symbolDrawMap = this.markerGroupMap, symbolDraw = symbolDrawMap.get(seriesId) || symbolDrawMap.set(seriesId, new SymbolDraw()), mpData = function(coordSys, seriesModel, mpModel) {
                    var coordDimsInfos;
                    coordDimsInfos = coordSys ? zrUtil.map(coordSys && coordSys.dimensions, function(coordDim) {
                        var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {};
                        return zrUtil.defaults({
                            name: coordDim
                        }, info);
                    }) : [ {
                        name: "value",
                        type: "float"
                    } ];
                    var mpData = new List(coordDimsInfos, mpModel), dataOpt = zrUtil.map(mpModel.get("data"), zrUtil.curry(markerHelper.dataTransform, seriesModel));
                    coordSys && (dataOpt = zrUtil.filter(dataOpt, zrUtil.curry(markerHelper.dataFilter, coordSys)));
                    return mpData.initData(dataOpt, null, coordSys ? markerHelper.dimValueGetter : function(item) {
                        return item.value;
                    }), mpData;
                }(coordSys, seriesModel, mpModel);
                mpModel.setData(mpData), updateMarkerLayout(mpModel.getData(), seriesModel, api), 
                mpData.each(function(idx) {
                    var itemModel = mpData.getItemModel(idx), symbol = itemModel.getShallow("symbol"), symbolSize = itemModel.getShallow("symbolSize"), isFnSymbol = zrUtil.isFunction(symbol), isFnSymbolSize = zrUtil.isFunction(symbolSize);
                    if (isFnSymbol || isFnSymbolSize) {
                        var rawIdx = mpModel.getRawValue(idx), dataParams = mpModel.getDataParams(idx);
                        isFnSymbol && (symbol = symbol(rawIdx, dataParams)), isFnSymbolSize && (symbolSize = symbolSize(rawIdx, dataParams));
                    }
                    mpData.setItemVisual(idx, {
                        symbol: symbol,
                        symbolSize: symbolSize,
                        color: itemModel.get("itemStyle.color") || seriesData.getVisual("color")
                    });
                }), symbolDraw.updateData(mpData), this.group.add(symbolDraw.group), mpData.eachItemGraphicEl(function(el) {
                    el.traverse(function(child) {
                        child.dataModel = mpModel;
                    });
                }), symbolDraw.__keep = !0, symbolDraw.group.silent = mpModel.get("silent") || seriesModel.get("silent");
            }
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var echarts = __webpack_require__(1);
        __webpack_require__(318), __webpack_require__(319), echarts.registerPreprocessor(function(opt) {
            opt.markLine = opt.markLine || {};
        });
    }, function(module, exports, __webpack_require__) {
        var _default = __webpack_require__(73).extend({
            type: "markLine",
            defaultOption: {
                zlevel: 0,
                z: 5,
                symbol: [ "circle", "arrow" ],
                symbolSize: [ 8, 16 ],
                precision: 2,
                tooltip: {
                    trigger: "item"
                },
                label: {
                    show: !0,
                    position: "end"
                },
                lineStyle: {
                    type: "dashed"
                },
                emphasis: {
                    label: {
                        show: !0
                    },
                    lineStyle: {
                        width: 3
                    }
                },
                animationEasing: "linear"
            }
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), List = __webpack_require__(25), numberUtil = __webpack_require__(4), markerHelper = __webpack_require__(74), LineDraw = __webpack_require__(130), MarkerView = __webpack_require__(75), getStackedDimension = __webpack_require__(19).getStackedDimension, markLineTransform = function(seriesModel, coordSys, mlModel, item) {
            var data = seriesModel.getData(), mlType = item.type;
            if (!zrUtil.isArray(item) && ("min" === mlType || "max" === mlType || "average" === mlType || "median" === mlType || null != item.xAxis || null != item.yAxis)) {
                var valueAxis, value;
                if (null != item.yAxis || null != item.xAxis) valueAxis = coordSys.getAxis(null != item.yAxis ? "y" : "x"), 
                value = zrUtil.retrieve(item.yAxis, item.xAxis); else {
                    var axisInfo = markerHelper.getAxisInfo(item, data, coordSys, seriesModel);
                    valueAxis = axisInfo.valueAxis;
                    var valueDataDim = getStackedDimension(data, axisInfo.valueDataDim);
                    value = markerHelper.numCalculate(data, valueDataDim, mlType);
                }
                var valueIndex = "x" === valueAxis.dim ? 0 : 1, baseIndex = 1 - valueIndex, mlFrom = zrUtil.clone(item), mlTo = {};
                mlFrom.type = null, mlFrom.coord = [], mlTo.coord = [], mlFrom.coord[baseIndex] = -1 / 0, 
                mlTo.coord[baseIndex] = 1 / 0;
                var precision = mlModel.get("precision");
                precision >= 0 && "number" == typeof value && (value = +value.toFixed(Math.min(precision, 20))), 
                mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value, item = [ mlFrom, mlTo, {
                    type: mlType,
                    valueIndex: item.valueIndex,
                    value: value
                } ];
            }
            return (item = [ markerHelper.dataTransform(seriesModel, item[0]), markerHelper.dataTransform(seriesModel, item[1]), zrUtil.extend({}, item[2]) ])[2].type = item[2].type || "", 
            zrUtil.merge(item[2], item[0]), zrUtil.merge(item[2], item[1]), item;
        };
        function isInifinity(val) {
            return !isNaN(val) && !isFinite(val);
        }
        function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
            var otherDimIndex = 1 - dimIndex, dimName = coordSys.dimensions[dimIndex];
            return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]) && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);
        }
        function markLineFilter(coordSys, item) {
            if ("cartesian2d" === coordSys.type) {
                var fromCoord = item[0].coord, toCoord = item[1].coord;
                if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) return !0;
            }
            return markerHelper.dataFilter(coordSys, item[0]) && markerHelper.dataFilter(coordSys, item[1]);
        }
        function updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api) {
            var point, coordSys = seriesModel.coordinateSystem, itemModel = data.getItemModel(idx), xPx = numberUtil.parsePercent(itemModel.get("x"), api.getWidth()), yPx = numberUtil.parsePercent(itemModel.get("y"), api.getHeight());
            if (isNaN(xPx) || isNaN(yPx)) {
                if (seriesModel.getMarkerPosition) point = seriesModel.getMarkerPosition(data.getValues(data.dimensions, idx)); else {
                    var dims = coordSys.dimensions, x = data.get(dims[0], idx), y = data.get(dims[1], idx);
                    point = coordSys.dataToPoint([ x, y ]);
                }
                if ("cartesian2d" === coordSys.type) {
                    var xAxis = coordSys.getAxis("x"), yAxis = coordSys.getAxis("y");
                    dims = coordSys.dimensions;
                    isInifinity(data.get(dims[0], idx)) ? point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]) : isInifinity(data.get(dims[1], idx)) && (point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]));
                }
                isNaN(xPx) || (point[0] = xPx), isNaN(yPx) || (point[1] = yPx);
            } else point = [ xPx, yPx ];
            data.setItemLayout(idx, point);
        }
        var _default = MarkerView.extend({
            type: "markLine",
            updateTransform: function(markLineModel, ecModel, api) {
                ecModel.eachSeries(function(seriesModel) {
                    var mlModel = seriesModel.markLineModel;
                    if (mlModel) {
                        var mlData = mlModel.getData(), fromData = mlModel.__from, toData = mlModel.__to;
                        fromData.each(function(idx) {
                            updateSingleMarkerEndLayout(fromData, idx, !0, seriesModel, api), updateSingleMarkerEndLayout(toData, idx, !1, seriesModel, api);
                        }), mlData.each(function(idx) {
                            mlData.setItemLayout(idx, [ fromData.getItemLayout(idx), toData.getItemLayout(idx) ]);
                        }), this.markerGroupMap.get(seriesModel.id).updateLayout();
                    }
                }, this);
            },
            renderSeries: function(seriesModel, mlModel, ecModel, api) {
                var coordSys = seriesModel.coordinateSystem, seriesId = seriesModel.id, seriesData = seriesModel.getData(), lineDrawMap = this.markerGroupMap, lineDraw = lineDrawMap.get(seriesId) || lineDrawMap.set(seriesId, new LineDraw());
                this.group.add(lineDraw.group);
                var mlData = function(coordSys, seriesModel, mlModel) {
                    var coordDimsInfos;
                    coordDimsInfos = coordSys ? zrUtil.map(coordSys && coordSys.dimensions, function(coordDim) {
                        var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {};
                        return zrUtil.defaults({
                            name: coordDim
                        }, info);
                    }) : [ {
                        name: "value",
                        type: "float"
                    } ];
                    var fromData = new List(coordDimsInfos, mlModel), toData = new List(coordDimsInfos, mlModel), lineData = new List([], mlModel), optData = zrUtil.map(mlModel.get("data"), zrUtil.curry(markLineTransform, seriesModel, coordSys, mlModel));
                    coordSys && (optData = zrUtil.filter(optData, zrUtil.curry(markLineFilter, coordSys)));
                    var dimValueGetter = coordSys ? markerHelper.dimValueGetter : function(item) {
                        return item.value;
                    };
                    return fromData.initData(zrUtil.map(optData, function(item) {
                        return item[0];
                    }), null, dimValueGetter), toData.initData(zrUtil.map(optData, function(item) {
                        return item[1];
                    }), null, dimValueGetter), lineData.initData(zrUtil.map(optData, function(item) {
                        return item[2];
                    })), lineData.hasItemOption = !0, {
                        from: fromData,
                        to: toData,
                        line: lineData
                    };
                }(coordSys, seriesModel, mlModel), fromData = mlData.from, toData = mlData.to, lineData = mlData.line;
                mlModel.__from = fromData, mlModel.__to = toData, mlModel.setData(lineData);
                var symbolType = mlModel.get("symbol"), symbolSize = mlModel.get("symbolSize");
                function updateDataVisualAndLayout(data, idx, isFrom) {
                    var itemModel = data.getItemModel(idx);
                    updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api), data.setItemVisual(idx, {
                        symbolSize: itemModel.get("symbolSize") || symbolSize[isFrom ? 0 : 1],
                        symbol: itemModel.get("symbol", !0) || symbolType[isFrom ? 0 : 1],
                        color: itemModel.get("itemStyle.color") || seriesData.getVisual("color")
                    });
                }
                zrUtil.isArray(symbolType) || (symbolType = [ symbolType, symbolType ]), "number" == typeof symbolSize && (symbolSize = [ symbolSize, symbolSize ]), 
                mlData.from.each(function(idx) {
                    updateDataVisualAndLayout(fromData, idx, !0), updateDataVisualAndLayout(toData, idx, !1);
                }), lineData.each(function(idx) {
                    var lineColor = lineData.getItemModel(idx).get("lineStyle.color");
                    lineData.setItemVisual(idx, {
                        color: lineColor || fromData.getItemVisual(idx, "color")
                    }), lineData.setItemLayout(idx, [ fromData.getItemLayout(idx), toData.getItemLayout(idx) ]), 
                    lineData.setItemVisual(idx, {
                        fromSymbolSize: fromData.getItemVisual(idx, "symbolSize"),
                        fromSymbol: fromData.getItemVisual(idx, "symbol"),
                        toSymbolSize: toData.getItemVisual(idx, "symbolSize"),
                        toSymbol: toData.getItemVisual(idx, "symbol")
                    });
                }), lineDraw.updateData(lineData), mlData.line.eachItemGraphicEl(function(el, idx) {
                    el.traverse(function(child) {
                        child.dataModel = mlModel;
                    });
                }), lineDraw.__keep = !0, lineDraw.group.silent = mlModel.get("silent") || seriesModel.get("silent");
            }
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var echarts = __webpack_require__(1);
        __webpack_require__(321), __webpack_require__(322), echarts.registerPreprocessor(function(opt) {
            opt.markArea = opt.markArea || {};
        });
    }, function(module, exports, __webpack_require__) {
        var _default = __webpack_require__(73).extend({
            type: "markArea",
            defaultOption: {
                zlevel: 0,
                z: 1,
                tooltip: {
                    trigger: "item"
                },
                animation: !1,
                label: {
                    show: !0,
                    position: "top"
                },
                itemStyle: {
                    borderWidth: 0
                },
                emphasis: {
                    label: {
                        show: !0,
                        position: "top"
                    }
                }
            }
        });
        module.exports = _default;
    }, function(module, exports, __webpack_require__) {
        var zrUtil = __webpack_require__(0), colorUtil = __webpack_require__(20), List = __webpack_require__(25), numberUtil = __webpack_require__(4), graphic = __webpack_require__(2), markerHelper = __webpack_require__(74), markAreaTransform = function(seriesModel, coordSys, maModel, item) {
            var lt = markerHelper.dataTransform(seriesModel, item[0]), rb = markerHelper.dataTransform(seriesModel, item[1]), retrieve = zrUtil.retrieve, ltCoord = lt.coord, rbCoord = rb.coord;
            ltCoord[0] = retrieve(ltCoord[0], -1 / 0), ltCoord[1] = retrieve(ltCoord[1], -1 / 0), 
            rbCoord[0] = retrieve(rbCoord[0], 1 / 0), rbCoord[1] = retrieve(rbCoord[1], 1 / 0);
            var result = zrUtil.mergeAll([ {}, lt, rb ]);
            return result.coord = [ lt.coord, rb.coord ], result.x0 = lt.x, result.y0 = lt.y, 
            result.x1 = rb.x, result.y1 = rb.y, result;
        };
        function isInifinity(val) {
            return !isNaN(val) && !isFinite(val);
        }
        function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
            var otherDimIndex = 1 - dimIndex;
            return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]);
        }
        function markAreaFilter(coordSys, item) {
            var fromCoord = item.coord[0], toCoord = item.coord[1];
            return !("cartesian2d" !== coordSys.type || !fromCoord || !toCoord || !ifMarkLineHasOnlyDim(1, fromCoord, toCoord) && !ifMarkLineHasOnlyDim(0, fromCoord, toCoord)) || (markerHelper.dataFilter(coordSys, {
                coord: fromCoord,
                x: item.x0,
                y: item.y0
            }) || markerHelper.dataFilter(coordSys, {
                coord: toCoord,
                x: item.x1,
                y: item.y1
            }));
        }
        function getSingleMarkerEndPoint(data, idx, dims, seriesModel, api) {
            var point, coordSys = seriesModel.coordinateSystem, itemModel = data.getItemModel(idx), xPx = numberUtil.parsePercent(itemModel.get(dims[0]), api.getWidth()), yPx = numberUtil.parsePercent(itemModel.get(dims[1]), api.getHeight());
            if (isNaN(xPx) || isNaN(yPx)) {
                if (seriesModel.getMarkerPosition) point = seriesModel.getMarkerPosition(data.getValues(dims, idx)); else {
                    var pt = [ x = data.get(dims[0], idx), y = data.get(dims[1], idx) ];
                    coordSys.clampData && coordSys.clampData(pt, pt), point = coordSys.dataToPoint(pt, !0);
                }
                if ("cartesian2d" === coordSys.type) {
                    var xAxis = coordSys.getAxis("x"), yAxis = coordSys.getAxis("y"), x = data.get(dims[0], idx), y = data.get(dims[1], idx);
                    isInifinity(x) ? point[0] = xAxis.toGlobalCoord(xAxis.getExtent()["x0" === dims[0] ? 0 : 1]) : isInifinity(y) && (point[1] = yAxis.toGlobalCoord(yAxis.getExtent()["y0" === dims[1] ? 0 : 1]));
                }
                isNaN(xPx) || (point[0] = xPx), isNaN(yPx) || (point[1] = yPx);
            } else point = [ xPx, yPx ];
            return point;
        }
        var dimPermutations = [ [ "x0", "y0" ], [ "x1", "y0" ], [ "x1", "y1" ], [ "x0", "y1" ] ];
        __webpack_require__(75).extend({
            type: "markArea",
            updateTransform: function(markAreaModel, ecModel, api) {
                ecModel.eachSeries(function(seriesModel) {
                    var maModel = seriesModel.markAreaModel;
                    if (maModel) {
                        var areaData = maModel.getData();
                        areaData.each(function(idx) {
                            var points = zrUtil.map(dimPermutations, function(dim) {
                                return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);
                            });
                            areaData.setItemLayout(idx, points), areaData.getItemGraphicEl(idx).setShape("points", points);
                        });
                    }
                }, this);
            },
            renderSeries: function(seriesModel, maModel, ecModel, api) {
                var coordSys = seriesModel.coordinateSystem, seriesId = seriesModel.id, seriesData = seriesModel.getData(), areaGroupMap = this.markerGroupMap, polygonGroup = areaGroupMap.get(seriesId) || areaGroupMap.set(seriesId, {
                    group: new graphic.Group()
                });
                this.group.add(polygonGroup.group), polygonGroup.__keep = !0;
                var areaData = function(coordSys, seriesModel, maModel) {
                    var coordDimsInfos, areaData;
                    coordSys ? (coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function(coordDim) {
                        var data = seriesModel.getData(), info = data.getDimensionInfo(data.mapDimension(coordDim)) || {};
                        return zrUtil.defaults({
                            name: coordDim
                        }, info);
                    }), areaData = new List(zrUtil.map([ "x0", "y0", "x1", "y1" ], function(dim, idx) {
                        return {
                            name: dim,
                            type: coordDimsInfos[idx % 2].type
                        };
                    }), maModel)) : areaData = new List(coordDimsInfos = [ {
                        name: "value",
                        type: "float"
                    } ], maModel);
                    var optData = zrUtil.map(maModel.get("data"), zrUtil.curry(markAreaTransform, seriesModel, coordSys, maModel));
                    coordSys && (optData = zrUtil.filter(optData, zrUtil.curry(markAreaFilter, coordSys)));
                    var dimValueGetter = coordSys ? function(item, dimName, dataIndex, dimIndex) {
                        return item.coord[Math.floor(dimIndex / 2)][dimIndex % 2];
                    } : function(item) {
                        return item.value;
                    };
                    return areaData.initData(optData, null, dimValueGetter), areaData.hasItemOption = !0, 
                    areaData;
                }(coordSys, seriesModel, maModel);
                maModel.setData(areaData), areaData.each(function(idx) {
                    areaData.setItemLayout(idx, zrUtil.map(dimPermutations, function(dim) {
                        return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);
                    })), areaData.setItemVisual(idx, {
                        color: seriesData.getVisual("color")
                    });
                }), areaData.diff(polygonGroup.__data).add(function(idx) {
                    var polygon = new graphic.Polygon({
                        shape: {
                            points: areaData.getItemLayout(idx)
                        }
                    });
                    areaData.setItemGraphicEl(idx, polygon), polygonGroup.group.add(polygon);
                }).update(function(newIdx, oldIdx) {
                    var polygon = polygonGroup.__data.getItemGraphicEl(oldIdx);
                    graphic.updateProps(polygon, {
                        shape: {
                            points: areaData.getItemLayout(newIdx)
                        }
                    }, maModel, newIdx), polygonGroup.group.add(polygon), areaData.setItemGraphicEl(newIdx, polygon);
                }).remove(function(idx) {
                    var polygon = polygonGroup.__data.getItemGraphicEl(idx);
                    polygonGroup.group.remove(polygon);
                }).execute(), areaData.eachItemGraphicEl(function(polygon, idx) {
                    var itemModel = areaData.getItemModel(idx), labelModel = itemModel.getModel("label"), labelHoverModel = itemModel.getModel("emphasis.label"), color = areaData.getItemVisual(idx, "color");
                    polygon.useStyle(zrUtil.defaults(itemModel.getModel("itemStyle").getItemStyle(), {
                        fill: colorUtil.modifyAlpha(color, .4),
                        stroke: color
                    })), polygon.hoverStyle = itemModel.getModel("emphasis.itemStyle").getItemStyle(), 
                    graphic.setLabelStyle(polygon.style, polygon.hoverStyle, labelModel, labelHoverModel, {
                        labelFetcher: maModel,
                        labelDataIndex: idx,
                        defaultText: areaData.getName(idx) || "",
                        isRectText: !0,
                        autoColor: color
                    }), graphic.setHoverStyle(polygon, {}), polygon.dataModel = maModel;
                }), polygonGroup.__data = areaData, polygonGroup.group.silent = maModel.get("silent") || seriesModel.get("silent");
            }
        });
    }, function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        var ascending = function(a, b) {
            return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
        }, bisector = function(compare) {
            return 1 === compare.length && (compare = function(f) {
                return function(d, x) {
                    return ascending(f(d), x);
                };
            }(compare)), {
                left: function(a, x, lo, hi) {
                    for (null == lo && (lo = 0), null == hi && (hi = a.length); lo < hi; ) {
                        var mid = lo + hi >>> 1;
                        compare(a[mid], x) < 0 ? lo = mid + 1 : hi = mid;
                    }
                    return lo;
                },
                right: function(a, x, lo, hi) {
                    for (null == lo && (lo = 0), null == hi && (hi = a.length); lo < hi; ) {
                        var mid = lo + hi >>> 1;
                        compare(a[mid], x) > 0 ? hi = mid : lo = mid + 1;
                    }
                    return lo;
                }
            };
        };
        var ascendingBisect = bisector(ascending), bisectRight = ascendingBisect.right, bisect = (ascendingBisect.left, 
        bisectRight);
        var number = function(x) {
            return null === x ? NaN : +x;
        }, array_array = Array.prototype, src_range = (array_array.slice, array_array.map, 
        function(start, stop, step) {
            start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, 
            start = 0, 1) : n < 3 ? 1 : +step;
            for (var i = -1, n = 0 | Math.max(0, Math.ceil((stop - start) / step)), range = new Array(n); ++i < n; ) range[i] = start + i * step;
            return range;
        }), e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2), ticks = function(start, stop, count) {
            var reverse, n, ticks, step, i = -1;
            if (count = +count, (start = +start) === (stop = +stop) && count > 0) return [ start ];
            if ((reverse = stop < start) && (n = start, start = stop, stop = n), 0 === (step = tickIncrement(start, stop, count)) || !isFinite(step)) return [];
            if (step > 0) for (start = Math.ceil(start / step), stop = Math.floor(stop / step), 
            ticks = new Array(n = Math.ceil(stop - start + 1)); ++i < n; ) ticks[i] = (start + i) * step; else for (start = Math.floor(start * step), 
            stop = Math.ceil(stop * step), ticks = new Array(n = Math.ceil(start - stop + 1)); ++i < n; ) ticks[i] = (start - i) / step;
            return reverse && ticks.reverse(), ticks;
        };
        function tickIncrement(start, stop, count) {
            var step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log(step) / Math.LN10), error = step / Math.pow(10, power);
            return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
        }
        function tickStep(start, stop, count) {
            var step0 = Math.abs(stop - start) / Math.max(0, count), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
            return error >= e10 ? step1 *= 10 : error >= e5 ? step1 *= 5 : error >= e2 && (step1 *= 2), 
            stop < start ? -step1 : step1;
        }
        var quantile = function(values, p, valueof) {
            if (null == valueof && (valueof = number), n = values.length) {
                if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
                if (p >= 1) return +valueof(values[n - 1], n - 1, values);
                var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values);
                return value0 + (+valueof(values[i0 + 1], i0 + 1, values) - value0) * (i - i0);
            }
        };
        function initRange(domain, range) {
            switch (arguments.length) {
              case 0:
                break;

              case 1:
                this.range(domain);
                break;

              default:
                this.range(range).domain(domain);
            }
            return this;
        }
        function initInterpolator(domain, interpolator) {
            switch (arguments.length) {
              case 0:
                break;

              case 1:
                this.interpolator(domain);
                break;

              default:
                this.interpolator(interpolator).domain(domain);
            }
            return this;
        }
        function Map() {}
        function map_map(object, f) {
            var map = new Map();
            if (object instanceof Map) object.each(function(value, key) {
                map.set(key, value);
            }); else if (Array.isArray(object)) {
                var o, i = -1, n = object.length;
                if (null == f) for (;++i < n; ) map.set(i, object[i]); else for (;++i < n; ) map.set(f(o = object[i], i, object), o);
            } else if (object) for (var key in object) map.set(key, object[key]);
            return map;
        }
        Map.prototype = map_map.prototype = {
            constructor: Map,
            has: function(key) {
                return "$" + key in this;
            },
            get: function(key) {
                return this["$" + key];
            },
            set: function(key, value) {
                return this["$" + key] = value, this;
            },
            remove: function(key) {
                var property = "$" + key;
                return property in this && delete this[property];
            },
            clear: function() {
                for (var property in this) "$" === property[0] && delete this[property];
            },
            keys: function() {
                var keys = [];
                for (var property in this) "$" === property[0] && keys.push(property.slice(1));
                return keys;
            },
            values: function() {
                var values = [];
                for (var property in this) "$" === property[0] && values.push(this[property]);
                return values;
            },
            entries: function() {
                var entries = [];
                for (var property in this) "$" === property[0] && entries.push({
                    key: property.slice(1),
                    value: this[property]
                });
                return entries;
            },
            size: function() {
                var size = 0;
                for (var property in this) "$" === property[0] && ++size;
                return size;
            },
            empty: function() {
                for (var property in this) if ("$" === property[0]) return !1;
                return !0;
            },
            each: function(f) {
                for (var property in this) "$" === property[0] && f(this[property], property.slice(1), this);
            }
        };
        var src_map = map_map;
        function Set() {}
        var proto = src_map.prototype;
        function set(object, f) {
            var set = new Set();
            if (object instanceof Set) object.each(function(value) {
                set.add(value);
            }); else if (object) {
                var i = -1, n = object.length;
                if (null == f) for (;++i < n; ) set.add(object[i]); else for (;++i < n; ) set.add(f(object[i], i, object));
            }
            return set;
        }
        Set.prototype = set.prototype = {
            constructor: Set,
            has: proto.has,
            add: function(value) {
                return this["$" + (value += "")] = value, this;
            },
            remove: proto.remove,
            clear: proto.clear,
            values: proto.keys,
            size: proto.size,
            empty: proto.empty,
            each: proto.each
        };
        var src_array_array = Array.prototype, array_map = src_array_array.map, array_slice = src_array_array.slice, implicit = {
            name: "implicit"
        };
        function ordinal() {
            var index = src_map(), domain = [], range = [], unknown = implicit;
            function scale(d) {
                var key = d + "", i = index.get(key);
                if (!i) {
                    if (unknown !== implicit) return unknown;
                    index.set(key, i = domain.push(d));
                }
                return range[(i - 1) % range.length];
            }
            return scale.domain = function(_) {
                if (!arguments.length) return domain.slice();
                domain = [], index = src_map();
                for (var d, key, i = -1, n = _.length; ++i < n; ) index.has(key = (d = _[i]) + "") || index.set(key, domain.push(d));
                return scale;
            }, scale.range = function(_) {
                return arguments.length ? (range = array_slice.call(_), scale) : range.slice();
            }, scale.unknown = function(_) {
                return arguments.length ? (unknown = _, scale) : unknown;
            }, scale.copy = function() {
                return ordinal(domain, range).unknown(unknown);
            }, initRange.apply(scale, arguments), scale;
        }
        function band() {
            var step, bandwidth, scale = ordinal().unknown(void 0), domain = scale.domain, ordinalRange = scale.range, range = [ 0, 1 ], round = !1, paddingInner = 0, paddingOuter = 0, align = .5;
            function rescale() {
                var n = domain().length, reverse = range[1] < range[0], start = range[reverse - 0], stop = range[1 - reverse];
                step = (stop - start) / Math.max(1, n - paddingInner + 2 * paddingOuter), round && (step = Math.floor(step)), 
                start += (stop - start - step * (n - paddingInner)) * align, bandwidth = step * (1 - paddingInner), 
                round && (start = Math.round(start), bandwidth = Math.round(bandwidth));
                var values = src_range(n).map(function(i) {
                    return start + step * i;
                });
                return ordinalRange(reverse ? values.reverse() : values);
            }
            return delete scale.unknown, scale.domain = function(_) {
                return arguments.length ? (domain(_), rescale()) : domain();
            }, scale.range = function(_) {
                return arguments.length ? (range = [ +_[0], +_[1] ], rescale()) : range.slice();
            }, scale.rangeRound = function(_) {
                return range = [ +_[0], +_[1] ], round = !0, rescale();
            }, scale.bandwidth = function() {
                return bandwidth;
            }, scale.step = function() {
                return step;
            }, scale.round = function(_) {
                return arguments.length ? (round = !!_, rescale()) : round;
            }, scale.padding = function(_) {
                return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
            }, scale.paddingInner = function(_) {
                return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
            }, scale.paddingOuter = function(_) {
                return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
            }, scale.align = function(_) {
                return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
            }, scale.copy = function() {
                return band(domain(), range).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
            }, initRange.apply(rescale(), arguments);
        }
        function point() {
            return function pointish(scale) {
                var copy = scale.copy;
                return scale.padding = scale.paddingOuter, delete scale.paddingInner, delete scale.paddingOuter, 
                scale.copy = function() {
                    return pointish(copy());
                }, scale;
            }(band.apply(null, arguments).paddingInner(1));
        }
        var define = function(constructor, factory, prototype) {
            constructor.prototype = factory.prototype = prototype, prototype.constructor = constructor;
        };
        function extend(parent, definition) {
            var prototype = Object.create(parent.prototype);
            for (var key in definition) prototype[key] = definition[key];
            return prototype;
        }
        function Color() {}
        var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex3 = /^#([0-9a-f]{3})$/, reHex6 = /^#([0-9a-f]{6})$/, reRgbInteger = new RegExp("^rgb\\(" + [ reI, reI, reI ] + "\\)$"), reRgbPercent = new RegExp("^rgb\\(" + [ reP, reP, reP ] + "\\)$"), reRgbaInteger = new RegExp("^rgba\\(" + [ reI, reI, reI, reN ] + "\\)$"), reRgbaPercent = new RegExp("^rgba\\(" + [ reP, reP, reP, reN ] + "\\)$"), reHslPercent = new RegExp("^hsl\\(" + [ reN, reP, reP ] + "\\)$"), reHslaPercent = new RegExp("^hsla\\(" + [ reN, reP, reP, reN ] + "\\)$"), named = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        };
        function color_color(format) {
            var m;
            return format = (format + "").trim().toLowerCase(), (m = reHex3.exec(format)) ? new Rgb((m = parseInt(m[1], 16)) >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | 240 & m, (15 & m) << 4 | 15 & m, 1) : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format)) ? new Rgb(255 * m[1] / 100, 255 * m[2] / 100, 255 * m[3] / 100, 1) : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format)) ? rgba(255 * m[1] / 100, 255 * m[2] / 100, 255 * m[3] / 100, m[4]) : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : "transparent" === format ? new Rgb(NaN, NaN, NaN, 0) : null;
        }
        function rgbn(n) {
            return new Rgb(n >> 16 & 255, n >> 8 & 255, 255 & n, 1);
        }
        function rgba(r, g, b, a) {
            return a <= 0 && (r = g = b = NaN), new Rgb(r, g, b, a);
        }
        function rgbConvert(o) {
            return o instanceof Color || (o = color_color(o)), o ? new Rgb((o = o.rgb()).r, o.g, o.b, o.opacity) : new Rgb();
        }
        function color_rgb(r, g, b, opacity) {
            return 1 === arguments.length ? rgbConvert(r) : new Rgb(r, g, b, null == opacity ? 1 : opacity);
        }
        function Rgb(r, g, b, opacity) {
            this.r = +r, this.g = +g, this.b = +b, this.opacity = +opacity;
        }
        function hex(value) {
            return ((value = Math.max(0, Math.min(255, Math.round(value) || 0))) < 16 ? "0" : "") + value.toString(16);
        }
        function hsla(h, s, l, a) {
            return a <= 0 ? h = s = l = NaN : l <= 0 || l >= 1 ? h = s = NaN : s <= 0 && (h = NaN), 
            new Hsl(h, s, l, a);
        }
        function hsl(h, s, l, opacity) {
            return 1 === arguments.length ? function(o) {
                if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
                if (o instanceof Color || (o = color_color(o)), !o) return new Hsl();
                if (o instanceof Hsl) return o;
                var r = (o = o.rgb()).r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), h = NaN, s = max - min, l = (max + min) / 2;
                return s ? (h = r === max ? (g - b) / s + 6 * (g < b) : g === max ? (b - r) / s + 2 : (r - g) / s + 4, 
                s /= l < .5 ? max + min : 2 - max - min, h *= 60) : s = l > 0 && l < 1 ? 0 : h, 
                new Hsl(h, s, l, o.opacity);
            }(h) : new Hsl(h, s, l, null == opacity ? 1 : opacity);
        }
        function Hsl(h, s, l, opacity) {
            this.h = +h, this.s = +s, this.l = +l, this.opacity = +opacity;
        }
        function hsl2rgb(h, m1, m2) {
            return 255 * (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1);
        }
        define(Color, color_color, {
            displayable: function() {
                return this.rgb().displayable();
            },
            hex: function() {
                return this.rgb().hex();
            },
            toString: function() {
                return this.rgb() + "";
            }
        }), define(Rgb, color_rgb, extend(Color, {
            brighter: function(k) {
                return k = null == k ? 1 / .7 : Math.pow(1 / .7, k), new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
            },
            darker: function(k) {
                return k = null == k ? .7 : Math.pow(.7, k), new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
            },
            rgb: function() {
                return this;
            },
            displayable: function() {
                return 0 <= this.r && this.r <= 255 && 0 <= this.g && this.g <= 255 && 0 <= this.b && this.b <= 255 && 0 <= this.opacity && this.opacity <= 1;
            },
            hex: function() {
                return "#" + hex(this.r) + hex(this.g) + hex(this.b);
            },
            toString: function() {
                var a = this.opacity;
                return (1 === (a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a))) ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (1 === a ? ")" : ", " + a + ")");
            }
        })), define(Hsl, hsl, extend(Color, {
            brighter: function(k) {
                return k = null == k ? 1 / .7 : Math.pow(1 / .7, k), new Hsl(this.h, this.s, this.l * k, this.opacity);
            },
            darker: function(k) {
                return k = null == k ? .7 : Math.pow(.7, k), new Hsl(this.h, this.s, this.l * k, this.opacity);
            },
            rgb: function() {
                var h = this.h % 360 + 360 * (this.h < 0), s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < .5 ? l : 1 - l) * s, m1 = 2 * l - m2;
                return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
            },
            displayable: function() {
                return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
            }
        }));
        var deg2rad = Math.PI / 180, rad2deg = 180 / Math.PI, Xn = .96422, Yn = 1, Zn = .82521, lab_t0 = 4 / 29, lab_t1 = 6 / 29, lab_t2 = 3 * lab_t1 * lab_t1, t3 = lab_t1 * lab_t1 * lab_t1;
        function labConvert(o) {
            if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
            if (o instanceof Hcl) {
                if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
                var h = o.h * deg2rad;
                return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
            }
            o instanceof Rgb || (o = rgbConvert(o));
            var x, z, r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y = xyz2lab((.2225045 * r + .7168786 * g + .0606169 * b) / Yn);
            return r === g && g === b ? x = z = y : (x = xyz2lab((.4360747 * r + .3850649 * g + .1430804 * b) / Xn), 
            z = xyz2lab((.0139322 * r + .0971045 * g + .7141733 * b) / Zn)), new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
        }
        function lab(l, a, b, opacity) {
            return 1 === arguments.length ? labConvert(l) : new Lab(l, a, b, null == opacity ? 1 : opacity);
        }
        function Lab(l, a, b, opacity) {
            this.l = +l, this.a = +a, this.b = +b, this.opacity = +opacity;
        }
        function xyz2lab(t) {
            return t > t3 ? Math.pow(t, 1 / 3) : t / lab_t2 + lab_t0;
        }
        function lab2xyz(t) {
            return t > lab_t1 ? t * t * t : lab_t2 * (t - lab_t0);
        }
        function lrgb2rgb(x) {
            return 255 * (x <= .0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - .055);
        }
        function rgb2lrgb(x) {
            return (x /= 255) <= .04045 ? x / 12.92 : Math.pow((x + .055) / 1.055, 2.4);
        }
        function hclConvert(o) {
            if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
            if (o instanceof Lab || (o = labConvert(o)), 0 === o.a && 0 === o.b) return new Hcl(NaN, 0, o.l, o.opacity);
            var h = Math.atan2(o.b, o.a) * rad2deg;
            return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
        }
        function hcl(h, c, l, opacity) {
            return 1 === arguments.length ? hclConvert(h) : new Hcl(h, c, l, null == opacity ? 1 : opacity);
        }
        function Hcl(h, c, l, opacity) {
            this.h = +h, this.c = +c, this.l = +l, this.opacity = +opacity;
        }
        define(Lab, lab, extend(Color, {
            brighter: function(k) {
                return new Lab(this.l + 18 * (null == k ? 1 : k), this.a, this.b, this.opacity);
            },
            darker: function(k) {
                return new Lab(this.l - 18 * (null == k ? 1 : k), this.a, this.b, this.opacity);
            },
            rgb: function() {
                var y = (this.l + 16) / 116, x = isNaN(this.a) ? y : y + this.a / 500, z = isNaN(this.b) ? y : y - this.b / 200;
                return new Rgb(lrgb2rgb(3.1338561 * (x = Xn * lab2xyz(x)) - 1.6168667 * (y = Yn * lab2xyz(y)) - .4906146 * (z = Zn * lab2xyz(z))), lrgb2rgb(-.9787684 * x + 1.9161415 * y + .033454 * z), lrgb2rgb(.0719453 * x - .2289914 * y + 1.4052427 * z), this.opacity);
            }
        })), define(Hcl, hcl, extend(Color, {
            brighter: function(k) {
                return new Hcl(this.h, this.c, this.l + 18 * (null == k ? 1 : k), this.opacity);
            },
            darker: function(k) {
                return new Hcl(this.h, this.c, this.l - 18 * (null == k ? 1 : k), this.opacity);
            },
            rgb: function() {
                return labConvert(this).rgb();
            }
        }));
        var A = -.14861, B = 1.78277, C = -.29227, D = -.90649, E = 1.97294, ED = E * D, EB = E * B, BC_DA = B * C - D * A;
        function cubehelix_cubehelix(h, s, l, opacity) {
            return 1 === arguments.length ? function(o) {
                if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
                o instanceof Rgb || (o = rgbConvert(o));
                var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k = (E * (g - l) - C * bl) / D, s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
                return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
            }(h) : new Cubehelix(h, s, l, null == opacity ? 1 : opacity);
        }
        function Cubehelix(h, s, l, opacity) {
            this.h = +h, this.s = +s, this.l = +l, this.opacity = +opacity;
        }
        function basis(t1, v0, v1, v2, v3) {
            var t2 = t1 * t1, t3 = t2 * t1;
            return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
        }
        define(Cubehelix, cubehelix_cubehelix, extend(Color, {
            brighter: function(k) {
                return k = null == k ? 1 / .7 : Math.pow(1 / .7, k), new Cubehelix(this.h, this.s, this.l * k, this.opacity);
            },
            darker: function(k) {
                return k = null == k ? .7 : Math.pow(.7, k), new Cubehelix(this.h, this.s, this.l * k, this.opacity);
            },
            rgb: function() {
                var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad, l = +this.l, a = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh = Math.cos(h), sinh = Math.sin(h);
                return new Rgb(255 * (l + a * (A * cosh + B * sinh)), 255 * (l + a * (C * cosh + D * sinh)), 255 * (l + a * (E * cosh)), this.opacity);
            }
        }));
        var src_constant = function(x) {
            return function() {
                return x;
            };
        };
        function linear(a, d) {
            return function(t) {
                return a + t * d;
            };
        }
        function color_hue(a, b) {
            var d = b - a;
            return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : src_constant(isNaN(a) ? b : a);
        }
        function gamma(y) {
            return 1 == (y = +y) ? nogamma : function(a, b) {
                return b - a ? function(a, b, y) {
                    return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
                        return Math.pow(a + t * b, y);
                    };
                }(a, b, y) : src_constant(isNaN(a) ? b : a);
            };
        }
        function nogamma(a, b) {
            var d = b - a;
            return d ? linear(a, d) : src_constant(isNaN(a) ? b : a);
        }
        var src_rgb = function rgbGamma(y) {
            var color = gamma(y);
            function rgb(start, end) {
                var r = color((start = color_rgb(start)).r, (end = color_rgb(end)).r), g = color(start.g, end.g), b = color(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
                return function(t) {
                    return start.r = r(t), start.g = g(t), start.b = b(t), start.opacity = opacity(t), 
                    start + "";
                };
            }
            return rgb.gamma = rgbGamma, rgb;
        }(1);
        function rgbSpline(spline) {
            return function(colors) {
                var i, color, n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n);
                for (i = 0; i < n; ++i) color = color_rgb(colors[i]), r[i] = color.r || 0, g[i] = color.g || 0, 
                b[i] = color.b || 0;
                return r = spline(r), g = spline(g), b = spline(b), color.opacity = 1, function(t) {
                    return color.r = r(t), color.g = g(t), color.b = b(t), color + "";
                };
            };
        }
        rgbSpline(function(values) {
            var n = values.length - 1;
            return function(t) {
                var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
                return basis((t - i / n) * n, v0, v1, v2, v3);
            };
        }), rgbSpline(function(values) {
            var n = values.length;
            return function(t) {
                var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
                return basis((t - i / n) * n, v0, v1, v2, v3);
            };
        });
        var src_number = function(a, b) {
            return b -= a = +a, function(t) {
                return a + b * t;
            };
        }, reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
        var cssNode, cssRoot, cssView, svgNode, src_value = function(a, b) {
            var c, t = typeof b;
            return null == b || "boolean" === t ? src_constant(b) : ("number" === t ? src_number : "string" === t ? (c = color_color(b)) ? (b = c, 
            src_rgb) : function(a, b) {
                var am, bm, bs, bi = reA.lastIndex = reB.lastIndex = 0, i = -1, s = [], q = [];
                for (a += "", b += ""; (am = reA.exec(a)) && (bm = reB.exec(b)); ) (bs = bm.index) > bi && (bs = b.slice(bi, bs), 
                s[i] ? s[i] += bs : s[++i] = bs), (am = am[0]) === (bm = bm[0]) ? s[i] ? s[i] += bm : s[++i] = bm : (s[++i] = null, 
                q.push({
                    i: i,
                    x: src_number(am, bm)
                })), bi = reB.lastIndex;
                return bi < b.length && (bs = b.slice(bi), s[i] ? s[i] += bs : s[++i] = bs), s.length < 2 ? q[0] ? function(b) {
                    return function(t) {
                        return b(t) + "";
                    };
                }(q[0].x) : function(b) {
                    return function() {
                        return b;
                    };
                }(b) : (b = q.length, function(t) {
                    for (var o, i = 0; i < b; ++i) s[(o = q[i]).i] = o.x(t);
                    return s.join("");
                });
            } : b instanceof color_color ? src_rgb : b instanceof Date ? function(a, b) {
                var d = new Date();
                return b -= a = +a, function(t) {
                    return d.setTime(a + b * t), d;
                };
            } : Array.isArray(b) ? function(a, b) {
                var i, nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb);
                for (i = 0; i < na; ++i) x[i] = src_value(a[i], b[i]);
                for (;i < nb; ++i) c[i] = b[i];
                return function(t) {
                    for (i = 0; i < na; ++i) c[i] = x[i](t);
                    return c;
                };
            } : "function" != typeof b.valueOf && "function" != typeof b.toString || isNaN(b) ? function(a, b) {
                var k, i = {}, c = {};
                for (k in null !== a && "object" == typeof a || (a = {}), null !== b && "object" == typeof b || (b = {}), 
                b) k in a ? i[k] = src_value(a[k], b[k]) : c[k] = b[k];
                return function(t) {
                    for (k in i) c[k] = i[k](t);
                    return c;
                };
            } : src_number)(a, b);
        }, src_round = function(a, b) {
            return b -= a = +a, function(t) {
                return Math.round(a + b * t);
            };
        }, degrees = 180 / Math.PI, decompose_identity = {
            translateX: 0,
            translateY: 0,
            rotate: 0,
            skewX: 0,
            scaleX: 1,
            scaleY: 1
        }, decompose = function(a, b, c, d, e, f) {
            var scaleX, scaleY, skewX;
            return (scaleX = Math.sqrt(a * a + b * b)) && (a /= scaleX, b /= scaleX), (skewX = a * c + b * d) && (c -= a * skewX, 
            d -= b * skewX), (scaleY = Math.sqrt(c * c + d * d)) && (c /= scaleY, d /= scaleY, 
            skewX /= scaleY), a * d < b * c && (a = -a, b = -b, skewX = -skewX, scaleX = -scaleX), 
            {
                translateX: e,
                translateY: f,
                rotate: Math.atan2(b, a) * degrees,
                skewX: Math.atan(skewX) * degrees,
                scaleX: scaleX,
                scaleY: scaleY
            };
        };
        function interpolateTransform(parse, pxComma, pxParen, degParen) {
            function pop(s) {
                return s.length ? s.pop() + " " : "";
            }
            return function(a, b) {
                var s = [], q = [];
                return a = parse(a), b = parse(b), function(xa, ya, xb, yb, s, q) {
                    if (xa !== xb || ya !== yb) {
                        var i = s.push("translate(", null, pxComma, null, pxParen);
                        q.push({
                            i: i - 4,
                            x: src_number(xa, xb)
                        }, {
                            i: i - 2,
                            x: src_number(ya, yb)
                        });
                    } else (xb || yb) && s.push("translate(" + xb + pxComma + yb + pxParen);
                }(a.translateX, a.translateY, b.translateX, b.translateY, s, q), function(a, b, s, q) {
                    a !== b ? (a - b > 180 ? b += 360 : b - a > 180 && (a += 360), q.push({
                        i: s.push(pop(s) + "rotate(", null, degParen) - 2,
                        x: src_number(a, b)
                    })) : b && s.push(pop(s) + "rotate(" + b + degParen);
                }(a.rotate, b.rotate, s, q), function(a, b, s, q) {
                    a !== b ? q.push({
                        i: s.push(pop(s) + "skewX(", null, degParen) - 2,
                        x: src_number(a, b)
                    }) : b && s.push(pop(s) + "skewX(" + b + degParen);
                }(a.skewX, b.skewX, s, q), function(xa, ya, xb, yb, s, q) {
                    if (xa !== xb || ya !== yb) {
                        var i = s.push(pop(s) + "scale(", null, ",", null, ")");
                        q.push({
                            i: i - 4,
                            x: src_number(xa, xb)
                        }, {
                            i: i - 2,
                            x: src_number(ya, yb)
                        });
                    } else 1 === xb && 1 === yb || s.push(pop(s) + "scale(" + xb + "," + yb + ")");
                }(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q), a = b = null, function(t) {
                    for (var o, i = -1, n = q.length; ++i < n; ) s[(o = q[i]).i] = o.x(t);
                    return s.join("");
                };
            };
        }
        interpolateTransform(function(value) {
            return "none" === value ? decompose_identity : (cssNode || (cssNode = document.createElement("DIV"), 
            cssRoot = document.documentElement, cssView = document.defaultView), cssNode.style.transform = value, 
            value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform"), 
            cssRoot.removeChild(cssNode), value = value.slice(7, -1).split(","), decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]));
        }, "px, ", "px)", "deg)"), interpolateTransform(function(value) {
            return null == value ? decompose_identity : (svgNode || (svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g")), 
            svgNode.setAttribute("transform", value), (value = svgNode.transform.baseVal.consolidate()) ? (value = value.matrix, 
            decompose(value.a, value.b, value.c, value.d, value.e, value.f)) : decompose_identity);
        }, ", ", ")", ")"), Math.SQRT2;
        function hsl_hsl(hue) {
            return function(start, end) {
                var h = hue((start = hsl(start)).h, (end = hsl(end)).h), s = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
                return function(t) {
                    return start.h = h(t), start.s = s(t), start.l = l(t), start.opacity = opacity(t), 
                    start + "";
                };
            };
        }
        hsl_hsl(color_hue), hsl_hsl(nogamma);
        function hcl_hcl(hue) {
            return function(start, end) {
                var h = hue((start = hcl(start)).h, (end = hcl(end)).h), c = nogamma(start.c, end.c), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
                return function(t) {
                    return start.h = h(t), start.c = c(t), start.l = l(t), start.opacity = opacity(t), 
                    start + "";
                };
            };
        }
        hcl_hcl(color_hue), hcl_hcl(nogamma);
        function src_cubehelix_cubehelix(hue) {
            return function cubehelixGamma(y) {
                function cubehelix(start, end) {
                    var h = hue((start = cubehelix_cubehelix(start)).h, (end = cubehelix_cubehelix(end)).h), s = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
                    return function(t) {
                        return start.h = h(t), start.s = s(t), start.l = l(Math.pow(t, y)), start.opacity = opacity(t), 
                        start + "";
                    };
                }
                return y = +y, cubehelix.gamma = cubehelixGamma, cubehelix;
            }(1);
        }
        src_cubehelix_cubehelix(color_hue), src_cubehelix_cubehelix(nogamma);
        var d3_scale_src_constant = function(x) {
            return function() {
                return x;
            };
        }, d3_scale_src_number = function(x) {
            return +x;
        }, unit = [ 0, 1 ];
        function continuous_identity(x) {
            return x;
        }
        function normalize(a, b) {
            return (b -= a = +a) ? function(x) {
                return (x - a) / b;
            } : d3_scale_src_constant(isNaN(b) ? NaN : .5);
        }
        function clamper(domain) {
            var t, a = domain[0], b = domain[domain.length - 1];
            return a > b && (t = a, a = b, b = t), function(x) {
                return Math.max(a, Math.min(b, x));
            };
        }
        function bimap(domain, range, interpolate) {
            var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
            return d1 < d0 ? (d0 = normalize(d1, d0), r0 = interpolate(r1, r0)) : (d0 = normalize(d0, d1), 
            r0 = interpolate(r0, r1)), function(x) {
                return r0(d0(x));
            };
        }
        function polymap(domain, range, interpolate) {
            var j = Math.min(domain.length, range.length) - 1, d = new Array(j), r = new Array(j), i = -1;
            for (domain[j] < domain[0] && (domain = domain.slice().reverse(), range = range.slice().reverse()); ++i < j; ) d[i] = normalize(domain[i], domain[i + 1]), 
            r[i] = interpolate(range[i], range[i + 1]);
            return function(x) {
                var i = bisect(domain, x, 1, j) - 1;
                return r[i](d[i](x));
            };
        }
        function copy(source, target) {
            return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
        }
        function transformer() {
            var transform, untransform, unknown, piecewise, output, input, domain = unit, range = unit, interpolate = src_value, clamp = continuous_identity;
            function rescale() {
                return piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap, 
                output = input = null, scale;
            }
            function scale(x) {
                return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
            }
            return scale.invert = function(y) {
                return clamp(untransform((input || (input = piecewise(range, domain.map(transform), src_number)))(y)));
            }, scale.domain = function(_) {
                return arguments.length ? (domain = array_map.call(_, d3_scale_src_number), clamp === continuous_identity || (clamp = clamper(domain)), 
                rescale()) : domain.slice();
            }, scale.range = function(_) {
                return arguments.length ? (range = array_slice.call(_), rescale()) : range.slice();
            }, scale.rangeRound = function(_) {
                return range = array_slice.call(_), interpolate = src_round, rescale();
            }, scale.clamp = function(_) {
                return arguments.length ? (clamp = _ ? clamper(domain) : continuous_identity, scale) : clamp !== continuous_identity;
            }, scale.interpolate = function(_) {
                return arguments.length ? (interpolate = _, rescale()) : interpolate;
            }, scale.unknown = function(_) {
                return arguments.length ? (unknown = _, scale) : unknown;
            }, function(t, u) {
                return transform = t, untransform = u, rescale();
            };
        }
        function continuous(transform, untransform) {
            return transformer()(transform, untransform);
        }
        var formatDecimal = function(x, p) {
            if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null;
            var i, coefficient = x.slice(0, i);
            return [ coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient, +x.slice(i + 1) ];
        }, src_exponent = function(x) {
            return (x = formatDecimal(Math.abs(x))) ? x[1] : NaN;
        }, re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
        function formatSpecifier(specifier) {
            return new FormatSpecifier(specifier);
        }
        function FormatSpecifier(specifier) {
            if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
            var match;
            this.fill = match[1] || " ", this.align = match[2] || ">", this.sign = match[3] || "-", 
            this.symbol = match[4] || "", this.zero = !!match[5], this.width = match[6] && +match[6], 
            this.comma = !!match[7], this.precision = match[8] && +match[8].slice(1), this.trim = !!match[9], 
            this.type = match[10] || "";
        }
        formatSpecifier.prototype = FormatSpecifier.prototype, FormatSpecifier.prototype.toString = function() {
            return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (null == this.width ? "" : Math.max(1, 0 | this.width)) + (this.comma ? "," : "") + (null == this.precision ? "" : "." + Math.max(0, 0 | this.precision)) + (this.trim ? "~" : "") + this.type;
        };
        var prefixExponent, defaultLocale_locale, defaultLocale_format, defaultLocale_formatPrefix, formatTrim = function(s) {
            out: for (var i1, n = s.length, i = 1, i0 = -1; i < n; ++i) switch (s[i]) {
              case ".":
                i0 = i1 = i;
                break;

              case "0":
                0 === i0 && (i0 = i), i1 = i;
                break;

              default:
                if (i0 > 0) {
                    if (!+s[i]) break out;
                    i0 = 0;
                }
            }
            return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
        }, formatRounded = function(x, p) {
            var d = formatDecimal(x, p);
            if (!d) return x + "";
            var coefficient = d[0], exponent = d[1];
            return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
        }, formatTypes = {
            "%": function(x, p) {
                return (100 * x).toFixed(p);
            },
            b: function(x) {
                return Math.round(x).toString(2);
            },
            c: function(x) {
                return x + "";
            },
            d: function(x) {
                return Math.round(x).toString(10);
            },
            e: function(x, p) {
                return x.toExponential(p);
            },
            f: function(x, p) {
                return x.toFixed(p);
            },
            g: function(x, p) {
                return x.toPrecision(p);
            },
            o: function(x) {
                return Math.round(x).toString(8);
            },
            p: function(x, p) {
                return formatRounded(100 * x, p);
            },
            r: formatRounded,
            s: function(x, p) {
                var d = formatDecimal(x, p);
                if (!d) return x + "";
                var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = 3 * Math.max(-8, Math.min(8, Math.floor(exponent / 3)))) + 1, n = coefficient.length;
                return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0];
            },
            X: function(x) {
                return Math.round(x).toString(16).toUpperCase();
            },
            x: function(x) {
                return Math.round(x).toString(16);
            }
        }, src_identity = function(x) {
            return x;
        }, prefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ], src_locale = function(locale) {
            var group = locale.grouping && locale.thousands ? function(grouping, thousands) {
                return function(value, width) {
                    for (var i = value.length, t = [], j = 0, g = grouping[0], length = 0; i > 0 && g > 0 && (length + g + 1 > width && (g = Math.max(1, width - length)), 
                    t.push(value.substring(i -= g, i + g)), !((length += g + 1) > width)); ) g = grouping[j = (j + 1) % grouping.length];
                    return t.reverse().join(thousands);
                };
            }(locale.grouping, locale.thousands) : src_identity, currency = locale.currency, decimal = locale.decimal, numerals = locale.numerals ? function(numerals) {
                return function(value) {
                    return value.replace(/[0-9]/g, function(i) {
                        return numerals[+i];
                    });
                };
            }(locale.numerals) : src_identity, percent = locale.percent || "%";
            function newFormat(specifier) {
                var fill = (specifier = formatSpecifier(specifier)).fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
                "n" === type ? (comma = !0, type = "g") : formatTypes[type] || (null == precision && (precision = 12), 
                trim = !0, type = "g"), (zero || "0" === fill && "=" === align) && (zero = !0, fill = "0", 
                align = "=");
                var prefix = "$" === symbol ? currency[0] : "#" === symbol && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = "$" === symbol ? currency[1] : /[%p]/.test(type) ? percent : "", formatType = formatTypes[type], maybeSuffix = /[defgprs%]/.test(type);
                function format(value) {
                    var i, n, c, valuePrefix = prefix, valueSuffix = suffix;
                    if ("c" === type) valueSuffix = formatType(value) + valueSuffix, value = ""; else {
                        var valueNegative = (value = +value) < 0;
                        if (value = formatType(Math.abs(value), precision), trim && (value = formatTrim(value)), 
                        valueNegative && 0 == +value && (valueNegative = !1), valuePrefix = (valueNegative ? "(" === sign ? sign : "-" : "-" === sign || "(" === sign ? "" : sign) + valuePrefix, 
                        valueSuffix = ("s" === type ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && "(" === sign ? ")" : ""), 
                        maybeSuffix) for (i = -1, n = value.length; ++i < n; ) if (48 > (c = value.charCodeAt(i)) || c > 57) {
                            valueSuffix = (46 === c ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix, 
                            value = value.slice(0, i);
                            break;
                        }
                    }
                    comma && !zero && (value = group(value, 1 / 0));
                    var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
                    switch (comma && zero && (value = group(padding + value, padding.length ? width - valueSuffix.length : 1 / 0), 
                    padding = ""), align) {
                      case "<":
                        value = valuePrefix + value + valueSuffix + padding;
                        break;

                      case "=":
                        value = valuePrefix + padding + value + valueSuffix;
                        break;

                      case "^":
                        value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
                        break;

                      default:
                        value = padding + valuePrefix + value + valueSuffix;
                    }
                    return numerals(value);
                }
                return precision = null == precision ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision)), 
                format.toString = function() {
                    return specifier + "";
                }, format;
            }
            return {
                format: newFormat,
                formatPrefix: function(specifier, value) {
                    var f = newFormat(((specifier = formatSpecifier(specifier)).type = "f", specifier)), e = 3 * Math.max(-8, Math.min(8, Math.floor(src_exponent(value) / 3))), k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
                    return function(value) {
                        return f(k * value) + prefix;
                    };
                }
            };
        };
        !function(definition) {
            defaultLocale_locale = src_locale(definition), defaultLocale_format = defaultLocale_locale.format, 
            defaultLocale_formatPrefix = defaultLocale_locale.formatPrefix;
        }({
            decimal: ".",
            thousands: ",",
            grouping: [ 3 ],
            currency: [ "$", "" ]
        });
        var src_tickFormat = function(start, stop, count, specifier) {
            var precision, step = tickStep(start, stop, count);
            switch ((specifier = formatSpecifier(null == specifier ? ",f" : specifier)).type) {
              case "s":
                var value = Math.max(Math.abs(start), Math.abs(stop));
                return null != specifier.precision || isNaN(precision = function(step, value) {
                    return Math.max(0, 3 * Math.max(-8, Math.min(8, Math.floor(src_exponent(value) / 3))) - src_exponent(Math.abs(step)));
                }(step, value)) || (specifier.precision = precision), defaultLocale_formatPrefix(specifier, value);

              case "":
              case "e":
              case "g":
              case "p":
              case "r":
                null != specifier.precision || isNaN(precision = function(step, max) {
                    return step = Math.abs(step), max = Math.abs(max) - step, Math.max(0, src_exponent(max) - src_exponent(step)) + 1;
                }(step, Math.max(Math.abs(start), Math.abs(stop)))) || (specifier.precision = precision - ("e" === specifier.type));
                break;

              case "f":
              case "%":
                null != specifier.precision || isNaN(precision = function(step) {
                    return Math.max(0, -src_exponent(Math.abs(step)));
                }(step)) || (specifier.precision = precision - 2 * ("%" === specifier.type));
            }
            return defaultLocale_format(specifier);
        };
        function linearish(scale) {
            var domain = scale.domain;
            return scale.ticks = function(count) {
                var d = domain();
                return ticks(d[0], d[d.length - 1], null == count ? 10 : count);
            }, scale.tickFormat = function(count, specifier) {
                var d = domain();
                return src_tickFormat(d[0], d[d.length - 1], null == count ? 10 : count, specifier);
            }, scale.nice = function(count) {
                null == count && (count = 10);
                var step, d = domain(), i0 = 0, i1 = d.length - 1, start = d[i0], stop = d[i1];
                return stop < start && (step = start, start = stop, stop = step, step = i0, i0 = i1, 
                i1 = step), (step = tickIncrement(start, stop, count)) > 0 ? step = tickIncrement(start = Math.floor(start / step) * step, stop = Math.ceil(stop / step) * step, count) : step < 0 && (step = tickIncrement(start = Math.ceil(start * step) / step, stop = Math.floor(stop * step) / step, count)), 
                step > 0 ? (d[i0] = Math.floor(start / step) * step, d[i1] = Math.ceil(stop / step) * step, 
                domain(d)) : step < 0 && (d[i0] = Math.ceil(start * step) / step, d[i1] = Math.floor(stop * step) / step, 
                domain(d)), scale;
            }, scale;
        }
        function linear_linear() {
            var scale = continuous(continuous_identity, continuous_identity);
            return scale.copy = function() {
                return copy(scale, linear_linear());
            }, initRange.apply(scale, arguments), linearish(scale);
        }
        function identity_identity(domain) {
            var unknown;
            function scale(x) {
                return isNaN(x = +x) ? unknown : x;
            }
            return scale.invert = scale, scale.domain = scale.range = function(_) {
                return arguments.length ? (domain = array_map.call(_, d3_scale_src_number), scale) : domain.slice();
            }, scale.unknown = function(_) {
                return arguments.length ? (unknown = _, scale) : unknown;
            }, scale.copy = function() {
                return identity_identity(domain).unknown(unknown);
            }, domain = arguments.length ? array_map.call(domain, d3_scale_src_number) : [ 0, 1 ], 
            linearish(scale);
        }
        var nice = function(domain, interval) {
            var t, i0 = 0, i1 = (domain = domain.slice()).length - 1, x0 = domain[i0], x1 = domain[i1];
            return x1 < x0 && (t = i0, i0 = i1, i1 = t, t = x0, x0 = x1, x1 = t), domain[i0] = interval.floor(x0), 
            domain[i1] = interval.ceil(x1), domain;
        };
        function transformLog(x) {
            return Math.log(x);
        }
        function transformExp(x) {
            return Math.exp(x);
        }
        function transformLogn(x) {
            return -Math.log(-x);
        }
        function transformExpn(x) {
            return -Math.exp(-x);
        }
        function pow10(x) {
            return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
        }
        function reflect(f) {
            return function(x) {
                return -f(-x);
            };
        }
        function loggish(transform) {
            var logs, pows, scale = transform(transformLog, transformExp), domain = scale.domain, base = 10;
            function rescale() {
                return logs = function(base) {
                    return base === Math.E ? Math.log : 10 === base && Math.log10 || 2 === base && Math.log2 || (base = Math.log(base), 
                    function(x) {
                        return Math.log(x) / base;
                    });
                }(base), pows = function(base) {
                    return 10 === base ? pow10 : base === Math.E ? Math.exp : function(x) {
                        return Math.pow(base, x);
                    };
                }(base), domain()[0] < 0 ? (logs = reflect(logs), pows = reflect(pows), transform(transformLogn, transformExpn)) : transform(transformLog, transformExp), 
                scale;
            }
            return scale.base = function(_) {
                return arguments.length ? (base = +_, rescale()) : base;
            }, scale.domain = function(_) {
                return arguments.length ? (domain(_), rescale()) : domain();
            }, scale.ticks = function(count) {
                var r, d = domain(), u = d[0], v = d[d.length - 1];
                (r = v < u) && (i = u, u = v, v = i);
                var p, k, t, i = logs(u), j = logs(v), n = null == count ? 10 : +count, z = [];
                if (!(base % 1) && j - i < n) {
                    if (i = Math.round(i) - 1, j = Math.round(j) + 1, u > 0) {
                        for (;i < j; ++i) for (k = 1, p = pows(i); k < base; ++k) if (!((t = p * k) < u)) {
                            if (t > v) break;
                            z.push(t);
                        }
                    } else for (;i < j; ++i) for (k = base - 1, p = pows(i); k >= 1; --k) if (!((t = p * k) < u)) {
                        if (t > v) break;
                        z.push(t);
                    }
                } else z = ticks(i, j, Math.min(j - i, n)).map(pows);
                return r ? z.reverse() : z;
            }, scale.tickFormat = function(count, specifier) {
                if (null == specifier && (specifier = 10 === base ? ".0e" : ","), "function" != typeof specifier && (specifier = defaultLocale_format(specifier)), 
                count === 1 / 0) return specifier;
                null == count && (count = 10);
                var k = Math.max(1, base * count / scale.ticks().length);
                return function(d) {
                    var i = d / pows(Math.round(logs(d)));
                    return i * base < base - .5 && (i *= base), i <= k ? specifier(d) : "";
                };
            }, scale.nice = function() {
                return domain(nice(domain(), {
                    floor: function(x) {
                        return pows(Math.floor(logs(x)));
                    },
                    ceil: function(x) {
                        return pows(Math.ceil(logs(x)));
                    }
                }));
            }, scale;
        }
        function log() {
            var scale = loggish(transformer()).domain([ 1, 10 ]);
            return scale.copy = function() {
                return copy(scale, log()).base(scale.base());
            }, initRange.apply(scale, arguments), scale;
        }
        function transformSymlog(c) {
            return function(x) {
                return Math.sign(x) * Math.log1p(Math.abs(x / c));
            };
        }
        function transformSymexp(c) {
            return function(x) {
                return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
            };
        }
        function symlogish(transform) {
            var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));
            return scale.constant = function(_) {
                return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
            }, linearish(scale);
        }
        function symlog() {
            var scale = symlogish(transformer());
            return scale.copy = function() {
                return copy(scale, symlog()).constant(scale.constant());
            }, initRange.apply(scale, arguments);
        }
        function transformPow(exponent) {
            return function(x) {
                return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
            };
        }
        function transformSqrt(x) {
            return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
        }
        function transformSquare(x) {
            return x < 0 ? -x * x : x * x;
        }
        function powish(transform) {
            var scale = transform(continuous_identity, continuous_identity), exponent = 1;
            return scale.exponent = function(_) {
                return arguments.length ? 1 === (exponent = +_) ? transform(continuous_identity, continuous_identity) : .5 === exponent ? transform(transformSqrt, transformSquare) : transform(transformPow(exponent), transformPow(1 / exponent)) : exponent;
            }, linearish(scale);
        }
        function pow() {
            var scale = powish(transformer());
            return scale.copy = function() {
                return copy(scale, pow()).exponent(scale.exponent());
            }, initRange.apply(scale, arguments), scale;
        }
        function sqrt() {
            return pow.apply(null, arguments).exponent(.5);
        }
        function quantile_quantile() {
            var unknown, domain = [], range = [], thresholds = [];
            function rescale() {
                var i = 0, n = Math.max(1, range.length);
                for (thresholds = new Array(n - 1); ++i < n; ) thresholds[i - 1] = quantile(domain, i / n);
                return scale;
            }
            function scale(x) {
                return isNaN(x = +x) ? unknown : range[bisect(thresholds, x)];
            }
            return scale.invertExtent = function(y) {
                var i = range.indexOf(y);
                return i < 0 ? [ NaN, NaN ] : [ i > 0 ? thresholds[i - 1] : domain[0], i < thresholds.length ? thresholds[i] : domain[domain.length - 1] ];
            }, scale.domain = function(_) {
                if (!arguments.length) return domain.slice();
                domain = [];
                for (var d, i = 0, n = _.length; i < n; ++i) null == (d = _[i]) || isNaN(d = +d) || domain.push(d);
                return domain.sort(ascending), rescale();
            }, scale.range = function(_) {
                return arguments.length ? (range = array_slice.call(_), rescale()) : range.slice();
            }, scale.unknown = function(_) {
                return arguments.length ? (unknown = _, scale) : unknown;
            }, scale.quantiles = function() {
                return thresholds.slice();
            }, scale.copy = function() {
                return quantile_quantile().domain(domain).range(range).unknown(unknown);
            }, initRange.apply(scale, arguments);
        }
        function quantize_quantize() {
            var unknown, x0 = 0, x1 = 1, n = 1, domain = [ .5 ], range = [ 0, 1 ];
            function scale(x) {
                return x <= x ? range[bisect(domain, x, 0, n)] : unknown;
            }
            function rescale() {
                var i = -1;
                for (domain = new Array(n); ++i < n; ) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
                return scale;
            }
            return scale.domain = function(_) {
                return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [ x0, x1 ];
            }, scale.range = function(_) {
                return arguments.length ? (n = (range = array_slice.call(_)).length - 1, rescale()) : range.slice();
            }, scale.invertExtent = function(y) {
                var i = range.indexOf(y);
                return i < 0 ? [ NaN, NaN ] : i < 1 ? [ x0, domain[0] ] : i >= n ? [ domain[n - 1], x1 ] : [ domain[i - 1], domain[i] ];
            }, scale.unknown = function(_) {
                return arguments.length ? (unknown = _, scale) : scale;
            }, scale.thresholds = function() {
                return domain.slice();
            }, scale.copy = function() {
                return quantize_quantize().domain([ x0, x1 ]).range(range).unknown(unknown);
            }, initRange.apply(linearish(scale), arguments);
        }
        function threshold_threshold() {
            var unknown, domain = [ .5 ], range = [ 0, 1 ], n = 1;
            function scale(x) {
                return x <= x ? range[bisect(domain, x, 0, n)] : unknown;
            }
            return scale.domain = function(_) {
                return arguments.length ? (domain = array_slice.call(_), n = Math.min(domain.length, range.length - 1), 
                scale) : domain.slice();
            }, scale.range = function(_) {
                return arguments.length ? (range = array_slice.call(_), n = Math.min(domain.length, range.length - 1), 
                scale) : range.slice();
            }, scale.invertExtent = function(y) {
                var i = range.indexOf(y);
                return [ domain[i - 1], domain[i] ];
            }, scale.unknown = function(_) {
                return arguments.length ? (unknown = _, scale) : unknown;
            }, scale.copy = function() {
                return threshold_threshold().domain(domain).range(range).unknown(unknown);
            }, initRange.apply(scale, arguments);
        }
        var interval_t0 = new Date(), interval_t1 = new Date();
        function newInterval(floori, offseti, count, field) {
            function interval(date) {
                return floori(date = new Date(+date)), date;
            }
            return interval.floor = interval, interval.ceil = function(date) {
                return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
            }, interval.round = function(date) {
                var d0 = interval(date), d1 = interval.ceil(date);
                return date - d0 < d1 - date ? d0 : d1;
            }, interval.offset = function(date, step) {
                return offseti(date = new Date(+date), null == step ? 1 : Math.floor(step)), date;
            }, interval.range = function(start, stop, step) {
                var previous, range = [];
                if (start = interval.ceil(start), step = null == step ? 1 : Math.floor(step), !(start < stop && step > 0)) return range;
                do {
                    range.push(previous = new Date(+start)), offseti(start, step), floori(start);
                } while (previous < start && start < stop);
                return range;
            }, interval.filter = function(test) {
                return newInterval(function(date) {
                    if (date >= date) for (;floori(date), !test(date); ) date.setTime(date - 1);
                }, function(date, step) {
                    if (date >= date) if (step < 0) for (;++step <= 0; ) for (;offseti(date, -1), !test(date); ) ; else for (;--step >= 0; ) for (;offseti(date, 1), 
                    !test(date); ) ;
                });
            }, count && (interval.count = function(start, end) {
                return interval_t0.setTime(+start), interval_t1.setTime(+end), floori(interval_t0), 
                floori(interval_t1), Math.floor(count(interval_t0, interval_t1));
            }, interval.every = function(step) {
                return step = Math.floor(step), isFinite(step) && step > 0 ? step > 1 ? interval.filter(field ? function(d) {
                    return field(d) % step == 0;
                } : function(d) {
                    return interval.count(0, d) % step == 0;
                }) : interval : null;
            }), interval;
        }
        var millisecond_millisecond = newInterval(function() {}, function(date, step) {
            date.setTime(+date + step);
        }, function(start, end) {
            return end - start;
        });
        millisecond_millisecond.every = function(k) {
            return k = Math.floor(k), isFinite(k) && k > 0 ? k > 1 ? newInterval(function(date) {
                date.setTime(Math.floor(date / k) * k);
            }, function(date, step) {
                date.setTime(+date + step * k);
            }, function(start, end) {
                return (end - start) / k;
            }) : millisecond_millisecond : null;
        };
        var src_millisecond = millisecond_millisecond, durationMinute = (millisecond_millisecond.range, 
        6e4), durationWeek = 6048e5, second_second = newInterval(function(date) {
            date.setTime(date - date.getMilliseconds());
        }, function(date, step) {
            date.setTime(+date + 1e3 * step);
        }, function(start, end) {
            return (end - start) / 1e3;
        }, function(date) {
            return date.getUTCSeconds();
        }), src_second = second_second, minute_minute = (second_second.range, newInterval(function(date) {
            date.setTime(date - date.getMilliseconds() - 1e3 * date.getSeconds());
        }, function(date, step) {
            date.setTime(+date + step * durationMinute);
        }, function(start, end) {
            return (end - start) / durationMinute;
        }, function(date) {
            return date.getMinutes();
        })), src_minute = minute_minute, hour_hour = (minute_minute.range, newInterval(function(date) {
            date.setTime(date - date.getMilliseconds() - 1e3 * date.getSeconds() - date.getMinutes() * durationMinute);
        }, function(date, step) {
            date.setTime(+date + 36e5 * step);
        }, function(start, end) {
            return (end - start) / 36e5;
        }, function(date) {
            return date.getHours();
        })), src_hour = hour_hour, day_day = (hour_hour.range, newInterval(function(date) {
            date.setHours(0, 0, 0, 0);
        }, function(date, step) {
            date.setDate(date.getDate() + step);
        }, function(start, end) {
            return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / 864e5;
        }, function(date) {
            return date.getDate() - 1;
        })), src_day = day_day;
        day_day.range;
        function weekday(i) {
            return newInterval(function(date) {
                date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7), date.setHours(0, 0, 0, 0);
            }, function(date, step) {
                date.setDate(date.getDate() + 7 * step);
            }, function(start, end) {
                return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
            });
        }
        var sunday = weekday(0), monday = weekday(1), tuesday = weekday(2), wednesday = weekday(3), thursday = weekday(4), friday = weekday(5), saturday = weekday(6), month_month = (sunday.range, 
        monday.range, tuesday.range, wednesday.range, thursday.range, friday.range, saturday.range, 
        newInterval(function(date) {
            date.setDate(1), date.setHours(0, 0, 0, 0);
        }, function(date, step) {
            date.setMonth(date.getMonth() + step);
        }, function(start, end) {
            return end.getMonth() - start.getMonth() + 12 * (end.getFullYear() - start.getFullYear());
        }, function(date) {
            return date.getMonth();
        })), src_month = month_month, year_year = (month_month.range, newInterval(function(date) {
            date.setMonth(0, 1), date.setHours(0, 0, 0, 0);
        }, function(date, step) {
            date.setFullYear(date.getFullYear() + step);
        }, function(start, end) {
            return end.getFullYear() - start.getFullYear();
        }, function(date) {
            return date.getFullYear();
        }));
        year_year.every = function(k) {
            return isFinite(k = Math.floor(k)) && k > 0 ? newInterval(function(date) {
                date.setFullYear(Math.floor(date.getFullYear() / k) * k), date.setMonth(0, 1), date.setHours(0, 0, 0, 0);
            }, function(date, step) {
                date.setFullYear(date.getFullYear() + step * k);
            }) : null;
        };
        var src_year = year_year, utcMinute = (year_year.range, newInterval(function(date) {
            date.setUTCSeconds(0, 0);
        }, function(date, step) {
            date.setTime(+date + step * durationMinute);
        }, function(start, end) {
            return (end - start) / durationMinute;
        }, function(date) {
            return date.getUTCMinutes();
        })), src_utcMinute = utcMinute, utcHour = (utcMinute.range, newInterval(function(date) {
            date.setUTCMinutes(0, 0, 0);
        }, function(date, step) {
            date.setTime(+date + 36e5 * step);
        }, function(start, end) {
            return (end - start) / 36e5;
        }, function(date) {
            return date.getUTCHours();
        })), src_utcHour = utcHour, utcDay = (utcHour.range, newInterval(function(date) {
            date.setUTCHours(0, 0, 0, 0);
        }, function(date, step) {
            date.setUTCDate(date.getUTCDate() + step);
        }, function(start, end) {
            return (end - start) / 864e5;
        }, function(date) {
            return date.getUTCDate() - 1;
        })), src_utcDay = utcDay;
        utcDay.range;
        function utcWeekday(i) {
            return newInterval(function(date) {
                date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7), date.setUTCHours(0, 0, 0, 0);
            }, function(date, step) {
                date.setUTCDate(date.getUTCDate() + 7 * step);
            }, function(start, end) {
                return (end - start) / durationWeek;
            });
        }
        var utcSunday = utcWeekday(0), utcMonday = utcWeekday(1), utcTuesday = utcWeekday(2), utcWednesday = utcWeekday(3), utcThursday = utcWeekday(4), utcFriday = utcWeekday(5), utcSaturday = utcWeekday(6), utcMonth = (utcSunday.range, 
        utcMonday.range, utcTuesday.range, utcWednesday.range, utcThursday.range, utcFriday.range, 
        utcSaturday.range, newInterval(function(date) {
            date.setUTCDate(1), date.setUTCHours(0, 0, 0, 0);
        }, function(date, step) {
            date.setUTCMonth(date.getUTCMonth() + step);
        }, function(start, end) {
            return end.getUTCMonth() - start.getUTCMonth() + 12 * (end.getUTCFullYear() - start.getUTCFullYear());
        }, function(date) {
            return date.getUTCMonth();
        })), src_utcMonth = utcMonth, utcYear = (utcMonth.range, newInterval(function(date) {
            date.setUTCMonth(0, 1), date.setUTCHours(0, 0, 0, 0);
        }, function(date, step) {
            date.setUTCFullYear(date.getUTCFullYear() + step);
        }, function(start, end) {
            return end.getUTCFullYear() - start.getUTCFullYear();
        }, function(date) {
            return date.getUTCFullYear();
        }));
        utcYear.every = function(k) {
            return isFinite(k = Math.floor(k)) && k > 0 ? newInterval(function(date) {
                date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k), date.setUTCMonth(0, 1), 
                date.setUTCHours(0, 0, 0, 0);
            }, function(date, step) {
                date.setUTCFullYear(date.getUTCFullYear() + step * k);
            }) : null;
        };
        var src_utcYear = utcYear;
        utcYear.range;
        function localDate(d) {
            if (0 <= d.y && d.y < 100) {
                var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
                return date.setFullYear(d.y), date;
            }
            return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
        }
        function utcDate(d) {
            if (0 <= d.y && d.y < 100) {
                var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
                return date.setUTCFullYear(d.y), date;
            }
            return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
        }
        function newYear(y) {
            return {
                y: y,
                m: 0,
                d: 1,
                H: 0,
                M: 0,
                S: 0,
                L: 0
            };
        }
        var src_defaultLocale_locale, timeFormat, utcFormat, utcParse, pads = {
            "-": "",
            _: " ",
            0: "0"
        }, numberRe = /^\s*\d+/, percentRe = /^%/, requoteRe = /[\\^$*+?|[\]().{}]/g;
        function pad(value, fill, width) {
            var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
            return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
        }
        function requote(s) {
            return s.replace(requoteRe, "\\$&");
        }
        function formatRe(names) {
            return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
        }
        function formatLookup(names) {
            for (var map = {}, i = -1, n = names.length; ++i < n; ) map[names[i].toLowerCase()] = i;
            return map;
        }
        function parseWeekdayNumberSunday(d, string, i) {
            var n = numberRe.exec(string.slice(i, i + 1));
            return n ? (d.w = +n[0], i + n[0].length) : -1;
        }
        function parseWeekdayNumberMonday(d, string, i) {
            var n = numberRe.exec(string.slice(i, i + 1));
            return n ? (d.u = +n[0], i + n[0].length) : -1;
        }
        function parseWeekNumberSunday(d, string, i) {
            var n = numberRe.exec(string.slice(i, i + 2));
            return n ? (d.U = +n[0], i + n[0].length) : -1;
        }
        function parseWeekNumberISO(d, string, i) {
            var n = numberRe.exec(string.slice(i, i + 2));
            return n ? (d.V = +n[0], i + n[0].length) : -1;
        }
        function parseWeekNumberMonday(d, string, i) {
            var n = numberRe.exec(string.slice(i, i + 2));
            return n ? (d.W = +n[0], i + n[0].length) : -1;
        }
        function parseFullYear(d, string, i) {
            var n = numberRe.exec(string.slice(i, i + 4));
            return n ? (d.y = +n[0], i + n[0].length) : -1;
        }
        function parseYear(d, string, i) {
            var n = numberRe.exec(string.slice(i, i + 2));
            return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
        }
        function parseZone(d, string, i) {
            var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
            return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
        }
        function parseMonthNumber(d, string, i) {
            var n = numberRe.exec(string.slice(i, i + 2));
            return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
        }
        function parseDayOfMonth(d, string, i) {
            var n = numberRe.exec(string.slice(i, i + 2));
            return n ? (d.d = +n[0], i + n[0].length) : -1;
        }
        function parseDayOfYear(d, string, i) {
            var n = numberRe.exec(string.slice(i, i + 3));
            return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
        }
        function parseHour24(d, string, i) {
            var n = numberRe.exec(string.slice(i, i + 2));
            return n ? (d.H = +n[0], i + n[0].length) : -1;
        }
        function parseMinutes(d, string, i) {
            var n = numberRe.exec(string.slice(i, i + 2));
            return n ? (d.M = +n[0], i + n[0].length) : -1;
        }
        function parseSeconds(d, string, i) {
            var n = numberRe.exec(string.slice(i, i + 2));
            return n ? (d.S = +n[0], i + n[0].length) : -1;
        }
        function parseMilliseconds(d, string, i) {
            var n = numberRe.exec(string.slice(i, i + 3));
            return n ? (d.L = +n[0], i + n[0].length) : -1;
        }
        function parseMicroseconds(d, string, i) {
            var n = numberRe.exec(string.slice(i, i + 6));
            return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
        }
        function parseLiteralPercent(d, string, i) {
            var n = percentRe.exec(string.slice(i, i + 1));
            return n ? i + n[0].length : -1;
        }
        function parseUnixTimestamp(d, string, i) {
            var n = numberRe.exec(string.slice(i));
            return n ? (d.Q = +n[0], i + n[0].length) : -1;
        }
        function parseUnixTimestampSeconds(d, string, i) {
            var n = numberRe.exec(string.slice(i));
            return n ? (d.Q = 1e3 * +n[0], i + n[0].length) : -1;
        }
        function formatDayOfMonth(d, p) {
            return pad(d.getDate(), p, 2);
        }
        function formatHour24(d, p) {
            return pad(d.getHours(), p, 2);
        }
        function formatHour12(d, p) {
            return pad(d.getHours() % 12 || 12, p, 2);
        }
        function formatDayOfYear(d, p) {
            return pad(1 + src_day.count(src_year(d), d), p, 3);
        }
        function formatMilliseconds(d, p) {
            return pad(d.getMilliseconds(), p, 3);
        }
        function formatMicroseconds(d, p) {
            return formatMilliseconds(d, p) + "000";
        }
        function formatMonthNumber(d, p) {
            return pad(d.getMonth() + 1, p, 2);
        }
        function formatMinutes(d, p) {
            return pad(d.getMinutes(), p, 2);
        }
        function formatSeconds(d, p) {
            return pad(d.getSeconds(), p, 2);
        }
        function formatWeekdayNumberMonday(d) {
            var day = d.getDay();
            return 0 === day ? 7 : day;
        }
        function formatWeekNumberSunday(d, p) {
            return pad(sunday.count(src_year(d), d), p, 2);
        }
        function formatWeekNumberISO(d, p) {
            var day = d.getDay();
            return d = day >= 4 || 0 === day ? thursday(d) : thursday.ceil(d), pad(thursday.count(src_year(d), d) + (4 === src_year(d).getDay()), p, 2);
        }
        function formatWeekdayNumberSunday(d) {
            return d.getDay();
        }
        function formatWeekNumberMonday(d, p) {
            return pad(monday.count(src_year(d), d), p, 2);
        }
        function locale_formatYear(d, p) {
            return pad(d.getFullYear() % 100, p, 2);
        }
        function formatFullYear(d, p) {
            return pad(d.getFullYear() % 1e4, p, 4);
        }
        function formatZone(d) {
            var z = d.getTimezoneOffset();
            return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
        }
        function formatUTCDayOfMonth(d, p) {
            return pad(d.getUTCDate(), p, 2);
        }
        function formatUTCHour24(d, p) {
            return pad(d.getUTCHours(), p, 2);
        }
        function formatUTCHour12(d, p) {
            return pad(d.getUTCHours() % 12 || 12, p, 2);
        }
        function formatUTCDayOfYear(d, p) {
            return pad(1 + src_utcDay.count(src_utcYear(d), d), p, 3);
        }
        function formatUTCMilliseconds(d, p) {
            return pad(d.getUTCMilliseconds(), p, 3);
        }
        function formatUTCMicroseconds(d, p) {
            return formatUTCMilliseconds(d, p) + "000";
        }
        function formatUTCMonthNumber(d, p) {
            return pad(d.getUTCMonth() + 1, p, 2);
        }
        function formatUTCMinutes(d, p) {
            return pad(d.getUTCMinutes(), p, 2);
        }
        function formatUTCSeconds(d, p) {
            return pad(d.getUTCSeconds(), p, 2);
        }
        function formatUTCWeekdayNumberMonday(d) {
            var dow = d.getUTCDay();
            return 0 === dow ? 7 : dow;
        }
        function formatUTCWeekNumberSunday(d, p) {
            return pad(utcSunday.count(src_utcYear(d), d), p, 2);
        }
        function formatUTCWeekNumberISO(d, p) {
            var day = d.getUTCDay();
            return d = day >= 4 || 0 === day ? utcThursday(d) : utcThursday.ceil(d), pad(utcThursday.count(src_utcYear(d), d) + (4 === src_utcYear(d).getUTCDay()), p, 2);
        }
        function formatUTCWeekdayNumberSunday(d) {
            return d.getUTCDay();
        }
        function formatUTCWeekNumberMonday(d, p) {
            return pad(utcMonday.count(src_utcYear(d), d), p, 2);
        }
        function formatUTCYear(d, p) {
            return pad(d.getUTCFullYear() % 100, p, 2);
        }
        function formatUTCFullYear(d, p) {
            return pad(d.getUTCFullYear() % 1e4, p, 4);
        }
        function formatUTCZone() {
            return "+0000";
        }
        function formatLiteralPercent() {
            return "%";
        }
        function formatUnixTimestamp(d) {
            return +d;
        }
        function formatUnixTimestampSeconds(d) {
            return Math.floor(+d / 1e3);
        }
        !function(definition) {
            src_defaultLocale_locale = function(locale) {
                var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_weekdays = locale.days, locale_shortWeekdays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths, periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths), formats = {
                    a: function(d) {
                        return locale_shortWeekdays[d.getDay()];
                    },
                    A: function(d) {
                        return locale_weekdays[d.getDay()];
                    },
                    b: function(d) {
                        return locale_shortMonths[d.getMonth()];
                    },
                    B: function(d) {
                        return locale_months[d.getMonth()];
                    },
                    c: null,
                    d: formatDayOfMonth,
                    e: formatDayOfMonth,
                    f: formatMicroseconds,
                    H: formatHour24,
                    I: formatHour12,
                    j: formatDayOfYear,
                    L: formatMilliseconds,
                    m: formatMonthNumber,
                    M: formatMinutes,
                    p: function(d) {
                        return locale_periods[+(d.getHours() >= 12)];
                    },
                    Q: formatUnixTimestamp,
                    s: formatUnixTimestampSeconds,
                    S: formatSeconds,
                    u: formatWeekdayNumberMonday,
                    U: formatWeekNumberSunday,
                    V: formatWeekNumberISO,
                    w: formatWeekdayNumberSunday,
                    W: formatWeekNumberMonday,
                    x: null,
                    X: null,
                    y: locale_formatYear,
                    Y: formatFullYear,
                    Z: formatZone,
                    "%": formatLiteralPercent
                }, utcFormats = {
                    a: function(d) {
                        return locale_shortWeekdays[d.getUTCDay()];
                    },
                    A: function(d) {
                        return locale_weekdays[d.getUTCDay()];
                    },
                    b: function(d) {
                        return locale_shortMonths[d.getUTCMonth()];
                    },
                    B: function(d) {
                        return locale_months[d.getUTCMonth()];
                    },
                    c: null,
                    d: formatUTCDayOfMonth,
                    e: formatUTCDayOfMonth,
                    f: formatUTCMicroseconds,
                    H: formatUTCHour24,
                    I: formatUTCHour12,
                    j: formatUTCDayOfYear,
                    L: formatUTCMilliseconds,
                    m: formatUTCMonthNumber,
                    M: formatUTCMinutes,
                    p: function(d) {
                        return locale_periods[+(d.getUTCHours() >= 12)];
                    },
                    Q: formatUnixTimestamp,
                    s: formatUnixTimestampSeconds,
                    S: formatUTCSeconds,
                    u: formatUTCWeekdayNumberMonday,
                    U: formatUTCWeekNumberSunday,
                    V: formatUTCWeekNumberISO,
                    w: formatUTCWeekdayNumberSunday,
                    W: formatUTCWeekNumberMonday,
                    x: null,
                    X: null,
                    y: formatUTCYear,
                    Y: formatUTCFullYear,
                    Z: formatUTCZone,
                    "%": formatLiteralPercent
                }, parses = {
                    a: function(d, string, i) {
                        var n = shortWeekdayRe.exec(string.slice(i));
                        return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
                    },
                    A: function(d, string, i) {
                        var n = weekdayRe.exec(string.slice(i));
                        return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
                    },
                    b: function(d, string, i) {
                        var n = shortMonthRe.exec(string.slice(i));
                        return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
                    },
                    B: function(d, string, i) {
                        var n = monthRe.exec(string.slice(i));
                        return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
                    },
                    c: function(d, string, i) {
                        return parseSpecifier(d, locale_dateTime, string, i);
                    },
                    d: parseDayOfMonth,
                    e: parseDayOfMonth,
                    f: parseMicroseconds,
                    H: parseHour24,
                    I: parseHour24,
                    j: parseDayOfYear,
                    L: parseMilliseconds,
                    m: parseMonthNumber,
                    M: parseMinutes,
                    p: function(d, string, i) {
                        var n = periodRe.exec(string.slice(i));
                        return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
                    },
                    Q: parseUnixTimestamp,
                    s: parseUnixTimestampSeconds,
                    S: parseSeconds,
                    u: parseWeekdayNumberMonday,
                    U: parseWeekNumberSunday,
                    V: parseWeekNumberISO,
                    w: parseWeekdayNumberSunday,
                    W: parseWeekNumberMonday,
                    x: function(d, string, i) {
                        return parseSpecifier(d, locale_date, string, i);
                    },
                    X: function(d, string, i) {
                        return parseSpecifier(d, locale_time, string, i);
                    },
                    y: parseYear,
                    Y: parseFullYear,
                    Z: parseZone,
                    "%": parseLiteralPercent
                };
                function newFormat(specifier, formats) {
                    return function(date) {
                        var c, pad, format, string = [], i = -1, j = 0, n = specifier.length;
                        for (date instanceof Date || (date = new Date(+date)); ++i < n; ) 37 === specifier.charCodeAt(i) && (string.push(specifier.slice(j, i)), 
                        null != (pad = pads[c = specifier.charAt(++i)]) ? c = specifier.charAt(++i) : pad = "e" === c ? " " : "0", 
                        (format = formats[c]) && (c = format(date, pad)), string.push(c), j = i + 1);
                        return string.push(specifier.slice(j, i)), string.join("");
                    };
                }
                function newParse(specifier, newDate) {
                    return function(string) {
                        var week, day, d = newYear(1900);
                        if (parseSpecifier(d, specifier, string += "", 0) != string.length) return null;
                        if ("Q" in d) return new Date(d.Q);
                        if ("p" in d && (d.H = d.H % 12 + 12 * d.p), "V" in d) {
                            if (d.V < 1 || d.V > 53) return null;
                            "w" in d || (d.w = 1), "Z" in d ? (week = (day = (week = utcDate(newYear(d.y))).getUTCDay()) > 4 || 0 === day ? utcMonday.ceil(week) : utcMonday(week), 
                            week = src_utcDay.offset(week, 7 * (d.V - 1)), d.y = week.getUTCFullYear(), d.m = week.getUTCMonth(), 
                            d.d = week.getUTCDate() + (d.w + 6) % 7) : (week = (day = (week = newDate(newYear(d.y))).getDay()) > 4 || 0 === day ? monday.ceil(week) : monday(week), 
                            week = src_day.offset(week, 7 * (d.V - 1)), d.y = week.getFullYear(), d.m = week.getMonth(), 
                            d.d = week.getDate() + (d.w + 6) % 7);
                        } else ("W" in d || "U" in d) && ("w" in d || (d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0), 
                        day = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay(), 
                        d.m = 0, d.d = "W" in d ? (d.w + 6) % 7 + 7 * d.W - (day + 5) % 7 : d.w + 7 * d.U - (day + 6) % 7);
                        return "Z" in d ? (d.H += d.Z / 100 | 0, d.M += d.Z % 100, utcDate(d)) : newDate(d);
                    };
                }
                function parseSpecifier(d, specifier, string, j) {
                    for (var c, parse, i = 0, n = specifier.length, m = string.length; i < n; ) {
                        if (j >= m) return -1;
                        if (37 === (c = specifier.charCodeAt(i++))) {
                            if (c = specifier.charAt(i++), !(parse = parses[c in pads ? specifier.charAt(i++) : c]) || (j = parse(d, string, j)) < 0) return -1;
                        } else if (c != string.charCodeAt(j++)) return -1;
                    }
                    return j;
                }
                return formats.x = newFormat(locale_date, formats), formats.X = newFormat(locale_time, formats), 
                formats.c = newFormat(locale_dateTime, formats), utcFormats.x = newFormat(locale_date, utcFormats), 
                utcFormats.X = newFormat(locale_time, utcFormats), utcFormats.c = newFormat(locale_dateTime, utcFormats), 
                {
                    format: function(specifier) {
                        var f = newFormat(specifier += "", formats);
                        return f.toString = function() {
                            return specifier;
                        }, f;
                    },
                    parse: function(specifier) {
                        var p = newParse(specifier += "", localDate);
                        return p.toString = function() {
                            return specifier;
                        }, p;
                    },
                    utcFormat: function(specifier) {
                        var f = newFormat(specifier += "", utcFormats);
                        return f.toString = function() {
                            return specifier;
                        }, f;
                    },
                    utcParse: function(specifier) {
                        var p = newParse(specifier, utcDate);
                        return p.toString = function() {
                            return specifier;
                        }, p;
                    }
                };
            }(definition), timeFormat = src_defaultLocale_locale.format, src_defaultLocale_locale.parse, 
            utcFormat = src_defaultLocale_locale.utcFormat, utcParse = src_defaultLocale_locale.utcParse;
        }({
            dateTime: "%x, %X",
            date: "%-m/%-d/%Y",
            time: "%-I:%M:%S %p",
            periods: [ "AM", "PM" ],
            days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
            shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
            months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
            shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
        });
        Date.prototype.toISOString || utcFormat("%Y-%m-%dT%H:%M:%S.%LZ");
        +new Date("2000-01-01T00:00:00.000Z") || utcParse("%Y-%m-%dT%H:%M:%S.%LZ");
        var time_durationSecond = 1e3, time_durationMinute = 60 * time_durationSecond, time_durationHour = 60 * time_durationMinute, time_durationDay = 24 * time_durationHour, time_durationWeek = 7 * time_durationDay, durationMonth = 30 * time_durationDay, durationYear = 365 * time_durationDay;
        function time_date(t) {
            return new Date(t);
        }
        function time_number(t) {
            return t instanceof Date ? +t : +new Date(+t);
        }
        function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
            var scale = continuous(continuous_identity, continuous_identity), invert = scale.invert, domain = scale.domain, formatMillisecond = format(".%L"), formatSecond = format(":%S"), formatMinute = format("%I:%M"), formatHour = format("%I %p"), formatDay = format("%a %d"), formatWeek = format("%b %d"), formatMonth = format("%B"), formatYear = format("%Y"), tickIntervals = [ [ second, 1, time_durationSecond ], [ second, 5, 5 * time_durationSecond ], [ second, 15, 15 * time_durationSecond ], [ second, 30, 30 * time_durationSecond ], [ minute, 1, time_durationMinute ], [ minute, 5, 5 * time_durationMinute ], [ minute, 15, 15 * time_durationMinute ], [ minute, 30, 30 * time_durationMinute ], [ hour, 1, time_durationHour ], [ hour, 3, 3 * time_durationHour ], [ hour, 6, 6 * time_durationHour ], [ hour, 12, 12 * time_durationHour ], [ day, 1, time_durationDay ], [ day, 2, 2 * time_durationDay ], [ week, 1, time_durationWeek ], [ month, 1, durationMonth ], [ month, 3, 3 * durationMonth ], [ year, 1, durationYear ] ];
            function tickFormat(date) {
                return (second(date) < date ? formatMillisecond : minute(date) < date ? formatSecond : hour(date) < date ? formatMinute : day(date) < date ? formatHour : month(date) < date ? week(date) < date ? formatDay : formatWeek : year(date) < date ? formatMonth : formatYear)(date);
            }
            function tickInterval(interval, start, stop, step) {
                if (null == interval && (interval = 10), "number" == typeof interval) {
                    var target = Math.abs(stop - start) / interval, i = bisector(function(i) {
                        return i[2];
                    }).right(tickIntervals, target);
                    i === tickIntervals.length ? (step = tickStep(start / durationYear, stop / durationYear, interval), 
                    interval = year) : i ? (step = (i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i])[1], 
                    interval = i[0]) : (step = Math.max(tickStep(start, stop, interval), 1), interval = millisecond);
                }
                return null == step ? interval : interval.every(step);
            }
            return scale.invert = function(y) {
                return new Date(invert(y));
            }, scale.domain = function(_) {
                return arguments.length ? domain(array_map.call(_, time_number)) : domain().map(time_date);
            }, scale.ticks = function(interval, step) {
                var t, d = domain(), t0 = d[0], t1 = d[d.length - 1], r = t1 < t0;
                return r && (t = t0, t0 = t1, t1 = t), t = (t = tickInterval(interval, t0, t1, step)) ? t.range(t0, t1 + 1) : [], 
                r ? t.reverse() : t;
            }, scale.tickFormat = function(count, specifier) {
                return null == specifier ? tickFormat : format(specifier);
            }, scale.nice = function(interval, step) {
                var d = domain();
                return (interval = tickInterval(interval, d[0], d[d.length - 1], step)) ? domain(nice(d, interval)) : scale;
            }, scale.copy = function() {
                return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
            }, scale;
        }
        var time = function() {
            return initRange.apply(calendar(src_year, src_month, sunday, src_day, src_hour, src_minute, src_second, src_millisecond, timeFormat).domain([ new Date(2e3, 0, 1), new Date(2e3, 0, 2) ]), arguments);
        }, utcTime = function() {
            return initRange.apply(calendar(src_utcYear, src_utcMonth, utcSunday, src_utcDay, src_utcHour, src_utcMinute, src_second, src_millisecond, utcFormat).domain([ Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2) ]), arguments);
        };
        function sequential_transformer() {
            var t0, t1, k10, transform, unknown, x0 = 0, x1 = 1, interpolator = continuous_identity, clamp = !1;
            function scale(x) {
                return isNaN(x = +x) ? unknown : interpolator(0 === k10 ? .5 : (x = (transform(x) - t0) * k10, 
                clamp ? Math.max(0, Math.min(1, x)) : x));
            }
            return scale.domain = function(_) {
                return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), 
                k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [ x0, x1 ];
            }, scale.clamp = function(_) {
                return arguments.length ? (clamp = !!_, scale) : clamp;
            }, scale.interpolator = function(_) {
                return arguments.length ? (interpolator = _, scale) : interpolator;
            }, scale.unknown = function(_) {
                return arguments.length ? (unknown = _, scale) : unknown;
            }, function(t) {
                return transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), 
                scale;
            };
        }
        function sequential_copy(source, target) {
            return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
        }
        function sequential() {
            var scale = linearish(sequential_transformer()(continuous_identity));
            return scale.copy = function() {
                return sequential_copy(scale, sequential());
            }, initInterpolator.apply(scale, arguments);
        }
        function sequentialLog() {
            var scale = loggish(sequential_transformer()).domain([ 1, 10 ]);
            return scale.copy = function() {
                return sequential_copy(scale, sequentialLog()).base(scale.base());
            }, initInterpolator.apply(scale, arguments);
        }
        function sequentialSymlog() {
            var scale = symlogish(sequential_transformer());
            return scale.copy = function() {
                return sequential_copy(scale, sequentialSymlog()).constant(scale.constant());
            }, initInterpolator.apply(scale, arguments);
        }
        function sequentialPow() {
            var scale = powish(sequential_transformer());
            return scale.copy = function() {
                return sequential_copy(scale, sequentialPow()).exponent(scale.exponent());
            }, initInterpolator.apply(scale, arguments);
        }
        function sequentialSqrt() {
            return sequentialPow.apply(null, arguments).exponent(.5);
        }
        function sequentialQuantile() {
            var domain = [], interpolator = continuous_identity;
            function scale(x) {
                if (!isNaN(x = +x)) return interpolator((bisect(domain, x) - 1) / (domain.length - 1));
            }
            return scale.domain = function(_) {
                if (!arguments.length) return domain.slice();
                domain = [];
                for (var d, i = 0, n = _.length; i < n; ++i) null == (d = _[i]) || isNaN(d = +d) || domain.push(d);
                return domain.sort(ascending), scale;
            }, scale.interpolator = function(_) {
                return arguments.length ? (interpolator = _, scale) : interpolator;
            }, scale.copy = function() {
                return sequentialQuantile(interpolator).domain(domain);
            }, initInterpolator.apply(scale, arguments);
        }
        function diverging_transformer() {
            var t0, t1, t2, k10, k21, transform, unknown, x0 = 0, x1 = .5, x2 = 1, interpolator = continuous_identity, clamp = !1;
            function scale(x) {
                return isNaN(x = +x) ? unknown : (x = .5 + ((x = +transform(x)) - t1) * (x < t1 ? k10 : k21), 
                interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
            }
            return scale.domain = function(_) {
                return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), 
                t2 = transform(x2 = +_[2]), k10 = t0 === t1 ? 0 : .5 / (t1 - t0), k21 = t1 === t2 ? 0 : .5 / (t2 - t1), 
                scale) : [ x0, x1, x2 ];
            }, scale.clamp = function(_) {
                return arguments.length ? (clamp = !!_, scale) : clamp;
            }, scale.interpolator = function(_) {
                return arguments.length ? (interpolator = _, scale) : interpolator;
            }, scale.unknown = function(_) {
                return arguments.length ? (unknown = _, scale) : unknown;
            }, function(t) {
                return transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : .5 / (t1 - t0), 
                k21 = t1 === t2 ? 0 : .5 / (t2 - t1), scale;
            };
        }
        function diverging() {
            var scale = linearish(diverging_transformer()(continuous_identity));
            return scale.copy = function() {
                return sequential_copy(scale, diverging());
            }, initInterpolator.apply(scale, arguments);
        }
        function divergingLog() {
            var scale = loggish(diverging_transformer()).domain([ .1, 1, 10 ]);
            return scale.copy = function() {
                return sequential_copy(scale, divergingLog()).base(scale.base());
            }, initInterpolator.apply(scale, arguments);
        }
        function divergingSymlog() {
            var scale = symlogish(diverging_transformer());
            return scale.copy = function() {
                return sequential_copy(scale, divergingSymlog()).constant(scale.constant());
            }, initInterpolator.apply(scale, arguments);
        }
        function divergingPow() {
            var scale = powish(diverging_transformer());
            return scale.copy = function() {
                return sequential_copy(scale, divergingPow()).exponent(scale.exponent());
            }, initInterpolator.apply(scale, arguments);
        }
        function divergingSqrt() {
            return divergingPow.apply(null, arguments).exponent(.5);
        }
        __webpack_require__.d(__webpack_exports__, "scaleBand", function() {
            return band;
        }), __webpack_require__.d(__webpack_exports__, "scalePoint", function() {
            return point;
        }), __webpack_require__.d(__webpack_exports__, "scaleIdentity", function() {
            return identity_identity;
        }), __webpack_require__.d(__webpack_exports__, "scaleLinear", function() {
            return linear_linear;
        }), __webpack_require__.d(__webpack_exports__, "scaleLog", function() {
            return log;
        }), __webpack_require__.d(__webpack_exports__, "scaleSymlog", function() {
            return symlog;
        }), __webpack_require__.d(__webpack_exports__, "scaleOrdinal", function() {
            return ordinal;
        }), __webpack_require__.d(__webpack_exports__, "scaleImplicit", function() {
            return implicit;
        }), __webpack_require__.d(__webpack_exports__, "scalePow", function() {
            return pow;
        }), __webpack_require__.d(__webpack_exports__, "scaleSqrt", function() {
            return sqrt;
        }), __webpack_require__.d(__webpack_exports__, "scaleQuantile", function() {
            return quantile_quantile;
        }), __webpack_require__.d(__webpack_exports__, "scaleQuantize", function() {
            return quantize_quantize;
        }), __webpack_require__.d(__webpack_exports__, "scaleThreshold", function() {
            return threshold_threshold;
        }), __webpack_require__.d(__webpack_exports__, "scaleTime", function() {
            return time;
        }), __webpack_require__.d(__webpack_exports__, "scaleUtc", function() {
            return utcTime;
        }), __webpack_require__.d(__webpack_exports__, "scaleSequential", function() {
            return sequential;
        }), __webpack_require__.d(__webpack_exports__, "scaleSequentialLog", function() {
            return sequentialLog;
        }), __webpack_require__.d(__webpack_exports__, "scaleSequentialPow", function() {
            return sequentialPow;
        }), __webpack_require__.d(__webpack_exports__, "scaleSequentialSqrt", function() {
            return sequentialSqrt;
        }), __webpack_require__.d(__webpack_exports__, "scaleSequentialSymlog", function() {
            return sequentialSymlog;
        }), __webpack_require__.d(__webpack_exports__, "scaleSequentialQuantile", function() {
            return sequentialQuantile;
        }), __webpack_require__.d(__webpack_exports__, "scaleDiverging", function() {
            return diverging;
        }), __webpack_require__.d(__webpack_exports__, "scaleDivergingLog", function() {
            return divergingLog;
        }), __webpack_require__.d(__webpack_exports__, "scaleDivergingPow", function() {
            return divergingPow;
        }), __webpack_require__.d(__webpack_exports__, "scaleDivergingSqrt", function() {
            return divergingSqrt;
        }), __webpack_require__.d(__webpack_exports__, "scaleDivergingSymlog", function() {
            return divergingSymlog;
        }), __webpack_require__.d(__webpack_exports__, "tickFormat", function() {
            return src_tickFormat;
        });
    }, function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        var ascending = function(a, b) {
            return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
        }, bisector = function(compare) {
            return 1 === compare.length && (compare = function(f) {
                return function(d, x) {
                    return ascending(f(d), x);
                };
            }(compare)), {
                left: function(a, x, lo, hi) {
                    for (null == lo && (lo = 0), null == hi && (hi = a.length); lo < hi; ) {
                        var mid = lo + hi >>> 1;
                        compare(a[mid], x) < 0 ? lo = mid + 1 : hi = mid;
                    }
                    return lo;
                },
                right: function(a, x, lo, hi) {
                    for (null == lo && (lo = 0), null == hi && (hi = a.length); lo < hi; ) {
                        var mid = lo + hi >>> 1;
                        compare(a[mid], x) > 0 ? hi = mid : lo = mid + 1;
                    }
                    return lo;
                }
            };
        };
        var ascendingBisect = bisector(ascending), bisectRight = ascendingBisect.right, bisectLeft = ascendingBisect.left, bisect = bisectRight;
        function count(values, valueof) {
            let count = 0;
            if (void 0 === valueof) for (let value of values) null != value && (value = +value) >= value && ++count; else {
                let index = -1;
                for (let value of values) null != (value = valueof(value, ++index, values)) && (value = +value) >= value && ++count;
            }
            return count;
        }
        function cross_length(array) {
            return 0 | array.length;
        }
        function empty(length) {
            return !(length > 0);
        }
        function arrayify(values) {
            return "object" != typeof values || "length" in values ? values : Array.from(values);
        }
        function cross(...values) {
            const reduce = "function" == typeof values[values.length - 1] && function(reduce) {
                return values => reduce(...values);
            }(values.pop()), lengths = (values = values.map(arrayify)).map(cross_length), j = values.length - 1, index = new Array(j + 1).fill(0), product = [];
            if (j < 0 || lengths.some(empty)) return product;
            for (;;) {
                product.push(index.map((j, i) => values[i][j]));
                let i = j;
                for (;++index[i] === lengths[i]; ) {
                    if (0 === i) return reduce ? product.map(reduce) : product;
                    index[i--] = 0;
                }
            }
        }
        var descending = function(a, b) {
            return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
        };
        function variance(values, valueof) {
            let delta, count = 0, mean = 0, sum = 0;
            if (void 0 === valueof) for (let value of values) null != value && (value = +value) >= value && (sum += (delta = value - mean) * (value - (mean += delta / ++count))); else {
                let index = -1;
                for (let value of values) null != (value = valueof(value, ++index, values)) && (value = +value) >= value && (sum += (delta = value - mean) * (value - (mean += delta / ++count)));
            }
            if (count > 1) return sum / (count - 1);
        }
        function deviation(values, valueof) {
            const v = variance(values, valueof);
            return v ? Math.sqrt(v) : v;
        }
        var extent = function(values, valueof) {
            let min, max;
            if (void 0 === valueof) for (const value of values) null != value && (void 0 === min ? value >= value && (min = max = value) : (min > value && (min = value), 
            max < value && (max = value))); else {
                let index = -1;
                for (let value of values) null != (value = valueof(value, ++index, values)) && (void 0 === min ? value >= value && (min = max = value) : (min > value && (min = value), 
                max < value && (max = value)));
            }
            return [ min, max ];
        }, identity = function(x) {
            return x;
        };
        function group(values, ...keys) {
            return nest(values, identity, identity, keys);
        }
        function groups(values, ...keys) {
            return nest(values, Array.from, identity, keys);
        }
        function rollup(values, reduce, ...keys) {
            return nest(values, identity, reduce, keys);
        }
        function rollups(values, reduce, ...keys) {
            return nest(values, Array.from, reduce, keys);
        }
        function nest(values, map, reduce, keys) {
            return function regroup(values, i) {
                if (i >= keys.length) return reduce(values);
                const groups = new Map(), keyof = keys[i++];
                let index = -1;
                for (const value of values) {
                    const key = keyof(value, ++index, values), group = groups.get(key);
                    group ? group.push(value) : groups.set(key, [ value ]);
                }
                for (const [key, values] of groups) groups.set(key, regroup(values, i));
                return map(groups);
            }(values, 0);
        }
        var array_array = Array.prototype, slice = array_array.slice, map = array_array.map, constant = function(x) {
            return function() {
                return x;
            };
        }, range = function(start, stop, step) {
            start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, 
            start = 0, 1) : n < 3 ? 1 : +step;
            for (var i = -1, n = 0 | Math.max(0, Math.ceil((stop - start) / step)), range = new Array(n); ++i < n; ) range[i] = start + i * step;
            return range;
        }, e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2), ticks = function(start, stop, count) {
            var reverse, n, ticks, step, i = -1;
            if (count = +count, (start = +start) === (stop = +stop) && count > 0) return [ start ];
            if ((reverse = stop < start) && (n = start, start = stop, stop = n), 0 === (step = tickIncrement(start, stop, count)) || !isFinite(step)) return [];
            if (step > 0) for (start = Math.ceil(start / step), stop = Math.floor(stop / step), 
            ticks = new Array(n = Math.ceil(stop - start + 1)); ++i < n; ) ticks[i] = (start + i) * step; else for (start = Math.floor(start * step), 
            stop = Math.ceil(stop * step), ticks = new Array(n = Math.ceil(start - stop + 1)); ++i < n; ) ticks[i] = (start - i) / step;
            return reverse && ticks.reverse(), ticks;
        };
        function tickIncrement(start, stop, count) {
            var step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log(step) / Math.LN10), error = step / Math.pow(10, power);
            return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
        }
        function tickStep(start, stop, count) {
            var step0 = Math.abs(stop - start) / Math.max(0, count), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
            return error >= e10 ? step1 *= 10 : error >= e5 ? step1 *= 5 : error >= e2 && (step1 *= 2), 
            stop < start ? -step1 : step1;
        }
        var sturges = function(values) {
            return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
        }, src_bin = function() {
            var value = identity, domain = extent, threshold = sturges;
            function histogram(data) {
                Array.isArray(data) || (data = Array.from(data));
                var i, x, n = data.length, values = new Array(n);
                for (i = 0; i < n; ++i) values[i] = value(data[i], i, data);
                var xz = domain(values), x0 = xz[0], x1 = xz[1], tz = threshold(values, x0, x1);
                Array.isArray(tz) || (tz = tickStep(x0, x1, tz), tz = range(Math.ceil(x0 / tz) * tz, x1, tz));
                for (var m = tz.length; tz[0] <= x0; ) tz.shift(), --m;
                for (;tz[m - 1] > x1; ) tz.pop(), --m;
                var bin, bins = new Array(m + 1);
                for (i = 0; i <= m; ++i) (bin = bins[i] = []).x0 = i > 0 ? tz[i - 1] : x0, bin.x1 = i < m ? tz[i] : x1;
                for (i = 0; i < n; ++i) x0 <= (x = values[i]) && x <= x1 && bins[bisect(tz, x, 0, m)].push(data[i]);
                return bins;
            }
            return histogram.value = function(_) {
                return arguments.length ? (value = "function" == typeof _ ? _ : constant(_), histogram) : value;
            }, histogram.domain = function(_) {
                return arguments.length ? (domain = "function" == typeof _ ? _ : constant([ _[0], _[1] ]), 
                histogram) : domain;
            }, histogram.thresholds = function(_) {
                return arguments.length ? (threshold = "function" == typeof _ ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), 
                histogram) : threshold;
            }, histogram;
        }, number = function(x) {
            return null === x ? NaN : +x;
        };
        function* numbers(values, valueof) {
            if (void 0 === valueof) for (let value of values) null != value && (value = +value) >= value && (yield value); else {
                let index = -1;
                for (let value of values) null != (value = valueof(value, ++index, values)) && (value = +value) >= value && (yield value);
            }
        }
        function quantile(values, p, valueof) {
            return quantileSorted(Float64Array.from(numbers(values, valueof)).sort(ascending), p);
        }
        function quantileSorted(values, p, valueof = number) {
            if (n = values.length) {
                if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
                if (p >= 1) return +valueof(values[n - 1], n - 1, values);
                var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values);
                return value0 + (+valueof(values[i0 + 1], i0 + 1, values) - value0) * (i - i0);
            }
        }
        var freedmanDiaconis = function(values, min, max) {
            return values = map.call(values, number).sort(ascending), Math.ceil((max - min) / (2 * (quantile(values, .75) - quantile(values, .25)) * Math.pow(values.length, -1 / 3)));
        }, scott = function(values, min, max) {
            return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
        };
        function max_max(values, valueof) {
            let max;
            if (void 0 === valueof) for (const value of values) null != value && (max < value || void 0 === max && value >= value) && (max = value); else {
                let index = -1;
                for (let value of values) null != (value = valueof(value, ++index, values)) && (max < value || void 0 === max && value >= value) && (max = value);
            }
            return max;
        }
        function maxIndex(values, valueof) {
            let max, maxIndex = -1, index = -1;
            if (void 0 === valueof) for (const value of values) ++index, null != value && (max < value || void 0 === max && value >= value) && (max = value, 
            maxIndex = index); else for (let value of values) null != (value = valueof(value, ++index, values)) && (max < value || void 0 === max && value >= value) && (max = value, 
            maxIndex = index);
            return maxIndex;
        }
        function mean(values, valueof) {
            let count = 0, sum = 0;
            if (void 0 === valueof) for (let value of values) null != value && (value = +value) >= value && (++count, 
            sum += value); else {
                let index = -1;
                for (let value of values) null != (value = valueof(value, ++index, values)) && (value = +value) >= value && (++count, 
                sum += value);
            }
            if (count) return sum / count;
        }
        function quickselect(array, k, left = 0, right = array.length - 1, compare = ascending) {
            for (;right > left; ) {
                if (right - left > 600) {
                    const n = right - left + 1, m = k - left + 1, z = Math.log(n), s = .5 * Math.exp(2 * z / 3), sd = .5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
                    quickselect(array, k, Math.max(left, Math.floor(k - m * s / n + sd)), Math.min(right, Math.floor(k + (n - m) * s / n + sd)), compare);
                }
                const t = array[k];
                let i = left, j = right;
                for (swap(array, left, k), compare(array[right], t) > 0 && swap(array, left, right); i < j; ) {
                    for (swap(array, i, j), ++i, --j; compare(array[i], t) < 0; ) ++i;
                    for (;compare(array[j], t) > 0; ) --j;
                }
                0 === compare(array[left], t) ? swap(array, left, j) : swap(array, ++j, right), 
                j <= k && (left = j + 1), k <= j && (right = j - 1);
            }
            return array;
        }
        function swap(array, i, j) {
            const t = array[i];
            array[i] = array[j], array[j] = t;
        }
        var median = function(values, valueof) {
            if (!(values = Float64Array.from(numbers(values, valueof))).length) return;
            const n = values.length, i = n >> 1;
            return quickselect(values, i - 1, 0), 0 == (1 & n) && quickselect(values, i, i), 
            quantile(values, .5);
        };
        function merge(arrays) {
            return Array.from(function*(arrays) {
                for (const array of arrays) yield* array;
            }(arrays));
        }
        function min_min(values, valueof) {
            let min;
            if (void 0 === valueof) for (const value of values) null != value && (min > value || void 0 === min && value >= value) && (min = value); else {
                let index = -1;
                for (let value of values) null != (value = valueof(value, ++index, values)) && (min > value || void 0 === min && value >= value) && (min = value);
            }
            return min;
        }
        function minIndex(values, valueof) {
            let min, minIndex = -1, index = -1;
            if (void 0 === valueof) for (const value of values) ++index, null != value && (min > value || void 0 === min && value >= value) && (min = value, 
            minIndex = index); else for (let value of values) null != (value = valueof(value, ++index, values)) && (min > value || void 0 === min && value >= value) && (min = value, 
            minIndex = index);
            return minIndex;
        }
        function pairs(values, pairof = function(a, b) {
            return [ a, b ];
        }) {
            const pairs = [];
            let previous, first = !1;
            for (const value of values) first && pairs.push(pairof(previous, value)), previous = value, 
            first = !0;
            return pairs;
        }
        var permute = function(source, keys) {
            return Array.from(keys, key => source[key]);
        };
        function least(values, compare = ascending) {
            let min, defined = !1;
            if (1 === compare.length) {
                let minValue;
                for (const element of values) {
                    const value = compare(element);
                    (defined ? ascending(value, minValue) < 0 : 0 === ascending(value, value)) && (min = element, 
                    minValue = value, defined = !0);
                }
            } else for (const value of values) (defined ? compare(value, min) < 0 : 0 === compare(value, value)) && (min = value, 
            defined = !0);
            return min;
        }
        function leastIndex(values, compare = ascending) {
            if (1 === compare.length) return minIndex(values, compare);
            let minValue, min = -1, index = -1;
            for (const value of values) ++index, (min < 0 ? 0 === compare(value, value) : compare(value, minValue) < 0) && (minValue = value, 
            min = index);
            return min;
        }
        function greatest(values, compare = ascending) {
            let max, defined = !1;
            if (1 === compare.length) {
                let maxValue;
                for (const element of values) {
                    const value = compare(element);
                    (defined ? ascending(value, maxValue) > 0 : 0 === ascending(value, value)) && (max = element, 
                    maxValue = value, defined = !0);
                }
            } else for (const value of values) (defined ? compare(value, max) > 0 : 0 === compare(value, value)) && (max = value, 
            defined = !0);
            return max;
        }
        function greatestIndex(values, compare = ascending) {
            if (1 === compare.length) return maxIndex(values, compare);
            let maxValue, max = -1, index = -1;
            for (const value of values) ++index, (max < 0 ? 0 === compare(value, value) : compare(value, maxValue) > 0) && (maxValue = value, 
            max = index);
            return max;
        }
        function scan(values, compare) {
            const index = leastIndex(values, compare);
            return index < 0 ? void 0 : index;
        }
        function shuffle(array, i0 = 0, i1 = array.length) {
            for (var t, i, m = i1 - (i0 = +i0); m; ) i = Math.random() * m-- | 0, t = array[m + i0], 
            array[m + i0] = array[i + i0], array[i + i0] = t;
            return array;
        }
        function sum(values, valueof) {
            let sum = 0;
            if (void 0 === valueof) for (let value of values) (value = +value) && (sum += value); else {
                let index = -1;
                for (let value of values) (value = +valueof(value, ++index, values)) && (sum += value);
            }
            return sum;
        }
        var src_transpose = function(matrix) {
            if (!(n = matrix.length)) return [];
            for (var i = -1, m = min_min(matrix, transpose_length), transpose = new Array(m); ++i < m; ) for (var n, j = -1, row = transpose[i] = new Array(n); ++j < n; ) row[j] = matrix[j][i];
            return transpose;
        };
        function transpose_length(d) {
            return d.length;
        }
        var zip = function() {
            return src_transpose(arguments);
        };
        __webpack_require__.d(__webpack_exports__, "bisect", function() {
            return bisect;
        }), __webpack_require__.d(__webpack_exports__, "bisectRight", function() {
            return bisectRight;
        }), __webpack_require__.d(__webpack_exports__, "bisectLeft", function() {
            return bisectLeft;
        }), __webpack_require__.d(__webpack_exports__, "ascending", function() {
            return ascending;
        }), __webpack_require__.d(__webpack_exports__, "bisector", function() {
            return bisector;
        }), __webpack_require__.d(__webpack_exports__, "count", function() {
            return count;
        }), __webpack_require__.d(__webpack_exports__, "cross", function() {
            return cross;
        }), __webpack_require__.d(__webpack_exports__, "descending", function() {
            return descending;
        }), __webpack_require__.d(__webpack_exports__, "deviation", function() {
            return deviation;
        }), __webpack_require__.d(__webpack_exports__, "extent", function() {
            return extent;
        }), __webpack_require__.d(__webpack_exports__, "group", function() {
            return group;
        }), __webpack_require__.d(__webpack_exports__, "groups", function() {
            return groups;
        }), __webpack_require__.d(__webpack_exports__, "rollup", function() {
            return rollup;
        }), __webpack_require__.d(__webpack_exports__, "rollups", function() {
            return rollups;
        }), __webpack_require__.d(__webpack_exports__, "bin", function() {
            return src_bin;
        }), __webpack_require__.d(__webpack_exports__, "histogram", function() {
            return src_bin;
        }), __webpack_require__.d(__webpack_exports__, "thresholdFreedmanDiaconis", function() {
            return freedmanDiaconis;
        }), __webpack_require__.d(__webpack_exports__, "thresholdScott", function() {
            return scott;
        }), __webpack_require__.d(__webpack_exports__, "thresholdSturges", function() {
            return sturges;
        }), __webpack_require__.d(__webpack_exports__, "max", function() {
            return max_max;
        }), __webpack_require__.d(__webpack_exports__, "maxIndex", function() {
            return maxIndex;
        }), __webpack_require__.d(__webpack_exports__, "mean", function() {
            return mean;
        }), __webpack_require__.d(__webpack_exports__, "median", function() {
            return median;
        }), __webpack_require__.d(__webpack_exports__, "merge", function() {
            return merge;
        }), __webpack_require__.d(__webpack_exports__, "min", function() {
            return min_min;
        }), __webpack_require__.d(__webpack_exports__, "minIndex", function() {
            return minIndex;
        }), __webpack_require__.d(__webpack_exports__, "pairs", function() {
            return pairs;
        }), __webpack_require__.d(__webpack_exports__, "permute", function() {
            return permute;
        }), __webpack_require__.d(__webpack_exports__, "quantile", function() {
            return quantile;
        }), __webpack_require__.d(__webpack_exports__, "quantileSorted", function() {
            return quantileSorted;
        }), __webpack_require__.d(__webpack_exports__, "quickselect", function() {
            return quickselect;
        }), __webpack_require__.d(__webpack_exports__, "range", function() {
            return range;
        }), __webpack_require__.d(__webpack_exports__, "least", function() {
            return least;
        }), __webpack_require__.d(__webpack_exports__, "leastIndex", function() {
            return leastIndex;
        }), __webpack_require__.d(__webpack_exports__, "greatest", function() {
            return greatest;
        }), __webpack_require__.d(__webpack_exports__, "greatestIndex", function() {
            return greatestIndex;
        }), __webpack_require__.d(__webpack_exports__, "scan", function() {
            return scan;
        }), __webpack_require__.d(__webpack_exports__, "shuffle", function() {
            return shuffle;
        }), __webpack_require__.d(__webpack_exports__, "sum", function() {
            return sum;
        }), __webpack_require__.d(__webpack_exports__, "ticks", function() {
            return ticks;
        }), __webpack_require__.d(__webpack_exports__, "tickIncrement", function() {
            return tickIncrement;
        }), __webpack_require__.d(__webpack_exports__, "tickStep", function() {
            return tickStep;
        }), __webpack_require__.d(__webpack_exports__, "transpose", function() {
            return src_transpose;
        }), __webpack_require__.d(__webpack_exports__, "variance", function() {
            return variance;
        }), __webpack_require__.d(__webpack_exports__, "zip", function() {
            return zip;
        });
    } ]).default;
});
//# sourceMappingURL=react-seda-scatterplot.min.js.map